//@version=5
indicator("Futures Trading Algo Premium", overlay=true, precision=0, explicit_plot_zorder=true, max_labels_count=500)
// Get user input
sensitivity = input.int(defval=6, title="Sensitivity", minval=1, maxval=20)

keltner_length = 10
atrPeriod = 10
factor = 3.5
Barcolloring = input.string("Version 1", options=["Version 1", "Version 2"], title="Bar Coloring")
tpmode = input.string("Version 1", options=['Version 2', "Version 1",'Close'], title="TP Signals Mode")
showrevsig = input.bool(false, 'Reversal Signals')
show_rev = input.bool(false, 'Reversal Cloud')
show_ha = input.bool(false, 'Trend Tracker')
Show_rangefilter = input.bool(false, 'Trend Catcher')
Show_SuperIchi = input.bool(false, 'SuperIchi')
// Signal Generation
supertrend(_src, factor, atrLen) =>
	atr = ta.atr(atrLen)
	upperBand = _src + factor * atr
	lowerBand = _src - factor * atr
	prevLowerBand = nz(lowerBand[1])
	prevUpperBand = nz(upperBand[1])
	lowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand
	upperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand
	int direction = na
	float superTrend = na
	prevSuperTrend = superTrend[1]
	if na(atr[1])
		direction := 1
	else if prevSuperTrend == prevUpperBand
		direction := close > upperBand ? -1 : 1
	else
		direction := close < lowerBand ? 1 : -1
	superTrend := direction == -1 ? lowerBand : upperBand
	[superTrend, direction] 
	


// SMA 
ocAvg       = math.avg(open, close)
sma44        = ta.sma(close, 8)
sma55        = ta.sma(close, 9)
sma99        = ta.sma(close, 13)
psarr        = ta.sar(0.02, 0.02, 0.2)

//*in Easy Words Super Trend + SMA = Signals
[supertrend, direction] = supertrend(close, sensitivity, 11)


sourceee = close, period = 150

// High Lows
y1 = low - (ta.atr(30) * 2), y1B = low - ta.atr(30)
y2 = high + (ta.atr(30) * 2), y2B = high + ta.atr(30)

bull = ta.crossover(close, supertrend) and close >= sma99
bear = ta.crossunder(close, supertrend) and close <= sma99

// Braid Filter

//-- Inputs
maType = input.string('McGinley', 'Filter', options=['EMA', 'DEMA', 'TEMA', 'WMA', 'VWMA', 'SMA', 'SMMA', 'HMA', 'LSMA', 'Kijun', 'McGinley', 'RMA'])
Period1 = 3
Period2 = 7
Period3 = 20
PipsMinSepPercent = input(80, 'Filter Strength')

//-- Moving Average
ma(type, src, len) =>
    float result = 0
    if type == 'SMA'  // Simple
        result := ta.sma(src, len)
        result
    if type == 'EMA'  // Exponential
        result := ta.ema(src, len)
        result
    if type == 'DEMA'  // Double Exponential
        e = ta.ema(src, len)
        result := 2 * e - ta.ema(e, len)
        result
    if type == 'TEMA'  // Triple Exponential
        e = ta.ema(src, len)
        result := 3 * (e - ta.ema(e, len)) + ta.ema(ta.ema(e, len), len)
        result
    if type == 'WMA'  // Weighted
        result := ta.wma(src, len)
        result
    if type == 'VWMA'  // Volume Weighted
        result := ta.vwma(src, len)
        result
    if type == 'SMMA'  // Smoothed
        w = ta.wma(src, len)
        result := na(w[1]) ? ta.sma(src, len) : (w[1] * (len - 1) + src) / len
        result
    if type == 'RMA'
        result := ta.rma(src, len)
        result
    if type == 'HMA'  // Hull
        result := ta.wma(2 * ta.wma(src, len / 2) - ta.wma(src, len), math.round(math.sqrt(len)))
        result
    if type == 'LSMA'  // Least Squares
        result := ta.linreg(src, len, 0)
        result
    if type == 'Kijun'  //Kijun-sen
        kijun = math.avg(ta.lowest(len), ta.highest(len))
        result := kijun
        result
    if type == 'McGinley'
        mg = 0.0
        mg := na(mg[1]) ? ta.ema(src, len) : mg[1] + (src - mg[1]) / (len * math.pow(src / mg[1], 4))
        result := mg
        result
    result

//-- Braid Filter   
ma01 = ma(maType, close, Period1)
ma02 = ma(maType, open, Period2)
ma03 = ma(maType, close, Period3)

max = math.max(math.max(ma01, ma02), ma03)
min = math.min(math.min(ma01, ma02), ma03)
dif = max - min

filter = ta.atr(14) * PipsMinSepPercent / 100

//-- Plots
BraidColor = ma01 > ma02 and dif > filter ? color.green : ma02 > ma01 and dif > filter ? color.red : color.gray

//plot(dif, 'Braid', BraidColor, 5, plot.style_columns)
//plot(filter, 'Filter', color.new(color.blue, 0), 2, plot.style_line)
//bgcolor(BraidColor, transp=90)

// Braid Filter Finish

//buy  = bull and ma01 > ma02 and dif > filter ? label.new(bar_index, y1, "▲", xloc.bar_index, yloc.price, #04994b, label.style_label_up, color.white, size.normal) : na
//sell = bear and ma02 > ma01 and dif > filter ? label.new(bar_index, y2, "▼", xloc.bar_index, yloc.price, #b4060d, label.style_label_down, color.white, size.normal) : na


buy  =  bull ? label.new(bar_index, y1, sma44 >= sma55 ? "▲" : "▲+", xloc.bar_index, yloc.price, #04994b, label.style_label_up, color.white, size.normal) : na
sell =  bear ? label.new(bar_index, y2, sma44 <= sma55 ? "▼" : "▼+", xloc.bar_index, yloc.price, #b4060d, label.style_label_down, color.white, size.normal) : na

[supertrends, directions] = ta.supertrend(factor, atrPeriod)
bodyMiddle = plot((open + close) / 2, display=display.none)
// Trend Catcher Indicator (Example)
ema100 = ta.ema(close, 10)
ema200 = ta.ema(close, 20)
trendCatcher = ta.crossover(ema100, ema200) ? 1 : ta.crossunder(ema100, ema200) ? -1 : 0
trendColor = trendCatcher == 1 ? color.rgb(90, 23, 102) : na
barcolor(trendColor)
// Colored candles


// Take Profit Script

colorsr = 'DARK'
bullcolorr = colorsr == 'DARK' ?  color.rgb(0, 255, 8) : #00DBFF
bearcolorr = colorsr == 'DARK' ?  color.rgb(255, 0, 0) : #E91E63

TE1 = true
TE2 = true
TE3 = true
//TE4 = input(true, 'TE - 4' , group="Money Moves [Trend Exhaustion]" , inline = "TEX")

rsiLengthInput = 22
rsiSourceInput = close
maTypeInput = ta.sma(close, 14)
up66 = ta.rma(math.max(ta.change(rsiSourceInput), 0), rsiLengthInput)
downw = ta.rma(-math.min(ta.change(rsiSourceInput), 0), rsiLengthInput)
rsi66 = downw == 0 ? 100 : up66 == 0 ? 0 : 100 - (100 / (1 + up66 / downw))
rsiMA = maTypeInput

long1 = ta.crossover(rsi66, 30)
//long4 = ta.crossover(rsi66, 10)

// SHORT
short1 = ta.crossunder(rsi66, 70)
//short4 = ta.crossunder(rsi66, 90)

// LONG
plotshape(long1 and showrevsig == true and close < supertrend and TE1, "GO LONG 1", style=shape.circle, location=location.belowbar,size=size.tiny, color = color.new(bullcolorr , 60) , text="▲" , textcolor = bullcolorr , editable = false)
//plotshape(long4 and ShowTEX, "GO LONG 4", style=shape.circle, location=location.belowbar,size=size.tiny, color=color.gray, text="4")

// SHORT
plotshape(short1 and showrevsig == true and close > supertrend and TE1, "GO SHORT 1", style=shape.circle, location=location.abovebar,size=size.tiny,  color = color.new(bearcolorr , 60) , text="▼" , textcolor = bearcolorr , editable = false)
//plotshape(short4 and ShowTEX, "GO SHORT 4", style=shape.circle, location=location.abovebar,size=size.tiny, color=color.gray, text="4")


// TP Points Script
maj = (tpmode == 'Version 1' ? true : false)

maj_qual = 13
maj_len = 40
min_qual = 5
min_len = 5
minn = false

selll = 0.0
buyy = 0.0

lele(qual, len) =>
    bindex = 0.0
    sindex = 0.0
    bindex := nz(bindex[1], 0)
    sindex := nz(sindex[1], 0)
    ret = 0
    if close > close[4]
        bindex += 1
        bindex
    if close < close[4]
        sindex += 1
        sindex
    if bindex > qual and close < open and high >= ta.highest(high, len)
        bindex := 0
        ret := -1
        ret
    if sindex > qual and close > open and low <= ta.lowest(low, len)
        sindex := 0
        ret := 1
        ret
    return_1 = ret
    return_1

major = lele(maj_qual, maj_len)
minor = lele(min_qual, min_len)

if minor == -1 and minn == true
    selll := 1
    selll
if major == -1 and maj == true
    selll := 2
    selll
if major == -1 and maj == true and minor == -1 and minn == true
    selll := 3
    selll

if minor == 1 and minn == true
    buyy := 1
    buyy
if major == 1 and maj == true
    buyy := 2
    buyy
if major == 1 and maj == true and minor == 1 and minn == true
    buyy := 3
    buyy

plotshape(selll == 2, style=shape.xcross,location=location.abovebar, color=color.new(#354996, 0), textcolor=color.new(color.white, 0), offset=0)

plotshape(buyy == 2, style=shape.xcross, location=location.belowbar, color=color.new(#354996, 0), textcolor=color.new(color.white, 0), offset=0)




//-----------------------------------------------------------------------------}


// Cobra Algo Cloud

source = input(ohlc4, 'Source')
ma2 = input.string(title='Cloud MA Type', options=['sma', 'ema', 'wma', 'vwma', 'rma', 'alma', 'hma', 'jma', 'frama-o','frama-m','dema','tema','zlema','smma','kma','tma','gmma','vida','cma','rema'], defval='ema')
ma = input.string(title='Ribbon MA Type', options=['sma', 'ema', 'wma', 'vwma', 'rma', 'alma', 'hma', 'jma', 'frama-o','frama-m','dema','tema','zlema','smma','kma','tma','gmma','vida','cma','rema'], defval='ema')
Theme = input.string(title='Theme', options=['Theme 1', 'Theme 2', 'Theme 3', 'No fill'], defval='Theme 1')
show_cross = input(title='Show Cross', defval=true)
userib = input(title = 'use ribbon for cross', defval = false, tooltip = 'changes the longema cross(shown as circles by defualt) from the cloud {2,6} cross to ribbon {1,2} cross')

show_seq = input.bool(defval=true,title='Show sequence', inline = 'show_seq', group = 'sequence')
seq_back = input.int(4, title = ':lookback', inline = 'show_seq', group = 'sequence')


//---Jurik MA
phase = 0
power = 1

calc_jma(_src, _length, _phase, _power) =>
    phaseRatio = _phase < -100 ? 0.5 : _phase > 100 ? 2.5 : _phase / 100 + 1.5

    beta = 0.45 * (_length - 1) / (0.45 * (_length - 1) + 2)
    alpha = math.pow(beta, _power)

    e0 = 0.0
    e0 := (1 - alpha) * _src + alpha * nz(e0[1])

    e1 = 0.0
    e1 := (_src - e0) * (1 - beta) + beta * nz(e1[1])

    jma = 0.0
    e2 = 0.0
    e2 := (e0 + phaseRatio * e1 - nz(jma[1])) * math.pow(1 - alpha, 2) + math.pow(alpha, 2) * nz(e2[1])

    jma := e2 + nz(jma[1])
    jma


FC = input.int(defval=5, minval=1, title='FRAMA FC', inline = 'FC', group = 'FRAMA')
SC = input.int(defval=50, minval=1, title=': SC', inline = 'FC', group = 'FRAMA')
//---FRAMA originale---
frama(source, c) =>
    out = 0.0
    len1 = c / 2
    e = 2.7182818284590452353602874713527
    w = math.log(2 / (SC + 1)) / math.log(e)  // Natural logarithm (ln(2/(SC+1))) workaround
    H1 = ta.highest(high, len1)
    L1 = ta.lowest(low, len1)
    N1 = (H1 - L1) / len1
    H2 = ta.highest(high, len1)[len1]
    L2 = ta.lowest(low, len1)[len1]
    N2 = (H2 - L2) / len1
    H3 = ta.highest(high, c)
    L3 = ta.lowest(low, c)
    N3 = (H3 - L3) / c
    dimen1 = (math.log(N1 + N2) - math.log(N3)) / math.log(2)
    dimen = N1 > 0 and N2 > 0 and N3 > 0 ? dimen1 : nz(dimen1[1])
    alpha1 = math.exp(w * (dimen - 1))
    oldalpha = alpha1 > 1 ? 1 : alpha1 < 0.01 ? 0.01 : alpha1
    oldN = (2 - oldalpha) / oldalpha
    N = (SC - FC) * (oldN - 1) / (SC - 1) + FC
    alpha_ = 2 / (N + 1)
    alpha = alpha_ < 2 / (SC + 1) ? 2 / (SC + 1) : alpha_ > 1 ? 1 : alpha_
    out := (1 - alpha) * nz(out[1]) + alpha * source
    out
//------FRAMA modificato---------
frama_mod(source, c) =>
    float result = 0
    int len1 = c / 2
    frama_SC = 200
    frama_FC = 1
    e = 2.7182818284590452353602874713527
    w = math.log(2 / (frama_SC + 1)) / math.log(e)  // Natural logarithm (ln(2/(SC+1))) workaround
    H1 = ta.highest(high, len1)
    L1 = ta.lowest(low, len1)
    N1 = (H1 - L1) / len1
    H2_ = ta.highest(high, len1)
    H2 = H2_[len1]
    L2_ = ta.lowest(low, len1)
    L2 = L2_[len1]
    N2 = (H2 - L2) / len1
    H3 = ta.highest(high, c)
    L3 = ta.lowest(low, c)
    N3 = (H3 - L3) / c
    dimen1 = (math.log(N1 + N2) - math.log(N3)) / math.log(2)
    dimen = N1 > 0 and N2 > 0 and N3 > 0 ? dimen1 : nz(dimen1[1])
    alpha1 = math.exp(w * (dimen - 1))
    oldalpha = alpha1 > 1 ? 1 : alpha1 < 0.01 ? 0.01 : alpha1
    oldN = (2 - oldalpha) / oldalpha
    N = (frama_SC - frama_FC) * (oldN - 1) / (frama_SC - 1) + frama_FC
    alpha_ = 2 / (N + 1)
    alpha = alpha_ < 2 / (frama_SC + 1) ? 2 / (frama_SC + 1) : alpha_ > 1 ? 1 : alpha_
    //frama = 0.0
    result := (1 - alpha) * nz(result[1]) + alpha * source
    result

//------------------------------------    
//---Double exp moving average (DEMA)
calc_dema(source, c) =>
    dema1 = ta.ema(source, c)
    dema2 = ta.ema(dema1, c)
    dExpoMA = 2 * dema1 - dema2
    dExpoMA

//---Triple exp moving average (TEMA)  
calc_tema(source, c) =>
    tExpo1 = ta.ema(source, c)
    tExpo2 = ta.ema(tExpo1, c)
    tExpo3 = ta.ema(tExpo2, c)
    tExpoMA = 3 * tExpo1 - 3 * tExpo2 + tExpo3
    tExpoMA

//---Zero-Lag Exponential Moving Average (ZLEMA)
calc_zlema(source, c) =>
    zLagExpo1 = (c - 1) / 2
    zLagExpo2 = source + source - source[zLagExpo1]
    zLagExpoMA = ta.ema(zLagExpo2, c)
    zLagExpoMA

//---Smoothed Moving Average (SMMA)
calc_smma(source, c) =>
    smmaMA = 0.0
    smmaMA := na(smmaMA[1]) ? ta.sma(source, c) : (smmaMA[1] * (c - 1) + source) / c
    smmaMA

//---Kaufman Adaptive Moving Average (KAMA)
kaufmanFast = input(title='Kaufman Fast', defval=2, inline = 'kaufmanFast', group = 'KMA')
kaufmanSlow = input(title=': Slow', defval=30, inline = 'kaufmanFast', group = 'KMA')

calc_kama(source, c) =>
    kaMA1 = math.abs(ta.change(source, c))
    kaufmanVol = math.sum(math.abs(ta.change(source)), c)
    kaufmanEff = kaufmanVol != 0 ? kaMA1 / kaufmanVol : 0
    kaufmanFast2 = 2 / (kaufmanFast + 1)
    kaufmanSlow2 = 2 / (kaufmanSlow + 1)
    kaufmanSC = math.pow(kaufmanEff * (kaufmanFast2 - kaufmanSlow2) + kaufmanSlow2, 2)
    kaMA = 0.0
    kaMA := kaufmanSC * source + (1 - kaufmanSC) * nz(kaMA[1])
    kaMA


//---Triangular Moving Average (TMA)
calc_tma(source, c) =>
    triMA = ta.sma(ta.sma(source, math.ceil(c / 2)), math.floor(c / 2) + 1)
    triMA


//Geometric Mean Moving Average (GMMA)
calc_gmma(source, c) =>
    lmean = math.log(source)
    smean = math.sum(lmean, c)
    geoMA = math.exp(smean / c)
    geoMA

//---Variable Index Dynamic Average (VIDA)
calc_vida(source, c) =>
    mom = ta.change(source)
    upSum = math.sum(math.max(mom, 0), c)
    downSum = math.sum(-math.min(mom, 0), c)
    cmo = math.abs((upSum - downSum) / (upSum + downSum))
    F = 2 / (c + 1)
    vida = 0.0
    vida := source * F * cmo + nz(vida[1]) * (1 - F * cmo)
    vida

//---Corrective Moving average (CMA)
calc_cma(source, c) =>
    sma = ta.sma(source, c)
    cma = sma
    v1 = ta.variance(source, c)
    v2 = math.pow(nz(cma[1], cma) - sma, 2)
    v3 = v1 == 0 or v2 == 0 ? 1 : v2 / (v1 + v2)

    var tolerance = math.pow(10, -5)
    float err = 1

    // Gain Factor
    float kPrev = 1
    float k = 1

    for i = 0 to 5000 by 1
        if err > tolerance
            k := v3 * kPrev * (2 - kPrev)
            err := kPrev - k
            kPrev := k
            kPrev

    cma := nz(cma[1], source) + k * (sma - nz(cma[1], source))
    cma

//---Ramnge EMA (REMA)
calc_range_ema(source, c) =>
    alpha = 2 / (1 + c)
    weight = high - low
    weight := weight == 0 ? syminfo.pointvalue : weight
    num = 0.0
    den = 0.0
    num := na(num[1]) ? weight * source : num[1] + alpha * (weight * source - num[1])
    den := na(den[1]) ? weight : den[1] + alpha * (weight - den[1])
    ma = num / den
    ma

// Ribbion

getMa1(c) =>
    switch ma 
        'sma' => ta.sma(source,c)
        'ema' => ta.ema(source,c)
        'wma' => ta.wma(source,c)
        'vwma' => ta.vwma(source,c)
        'rma' => ta.rma(source,c)
        'alma' => ta.alma(source,c, 0.85, 6)
        'hma' => ta.hma(source,c)
        'jma' => calc_jma(source,c, phase, power)
        'frama-o' => frama(source, c)
        'frama-m' => frama_mod(source, c)
        'dema' => calc_dema(source, c)
        'tema' => calc_tema(source, c)
        'zlema' => calc_zlema(source, c)
        'smma' => calc_smma(source, c)
        'kma' => calc_kama(source, c)
        'tma' => calc_tma(source, c)
        'gmma' => calc_gmma(source, c)
        'vida' => calc_vida(source, c)
        'cma' => calc_cma(source, c)
        'rema' => calc_range_ema(source, c)




getMa(c) =>
    switch ma2 
        'sma' => ta.sma(source,c)
        'ema' => ta.ema(source,c)
        'wma' => ta.wma(source,c)
        'vwma' => ta.vwma(source,c)
        'rma' => ta.rma(source,c)
        'alma' => ta.alma(source,c, 0.85, 6)
        'hma' => ta.hma(source,c)
        'jma' => calc_jma(source,c, phase, power)
        'frama-o' => frama(source, c)
        'frama-m' => frama_mod(source, c)
        'dema' => calc_dema(source, c)
        'tema' => calc_tema(source, c)
        'zlema' => calc_zlema(source, c)
        'smma' => calc_smma(source, c)
        'kma' => calc_kama(source, c)
        'tma' => calc_tma(source, c)
        'gmma' => calc_gmma(source, c)
        'vida' => calc_vida(source, c)
        'cma' => calc_cma(source, c)
        'rema' => calc_range_ema(source, c)


colour1 = color.new(#008000, 85)
colour2 = color.new(#7f0d0d, 85)
colour3 = color.new(#807800, 85)
colour4 = color.new(#290D7F, 85)
colour5 = color.new(#00807C, 85)
colour6 = color.new(#7F430D, 85)

c01 = Theme == 'Theme 1' ? colour1 : Theme == 'Theme 2' ? colour3 : Theme == 'Theme 3' ? colour5 : Theme == 'No fill' ? #FFFFFF00 : na
c02 = Theme == 'Theme 1' ? colour2 : Theme == 'Theme 2' ? colour4 : Theme == 'Theme 3' ? colour6 : Theme == 'N0 fill' ? #FFFFFF00 : na

cl1 = input.int(2, title='Cloud', inline='Cloud', group='MA cloud')
cl2 = input.int(6, title='/2', inline='Cloud', group='MA cloud')
cl3 = input.int(11, title='/3', inline='Cloud', group='MA cloud')
cl4 = input.int(18, title='/4', inline='Cloud', group='MA cloud')
cl5 = input.int(21, title='/5', inline='Cloud', group='MA cloud')
cl6 = input.int(24, title='/6', inline='Cloud', group='MA cloud')
cl7 = input.int(28, title='/7', inline='Cloud', group='MA cloud')
cl8 = input.int(34, title='/8', inline='Cloud', group='MA cloud')



rl1 = input.int(6, title='Ribbon', inline='Ribbon', group='MA Ribbon')
rl2 = input.int(13, title='/2', inline='Ribbon', group='MA Ribbon')
rl3 = input.int(20, title='/3', inline='Ribbon', group='MA Ribbon')
rl4 = input.int(28, title='/4', inline='Ribbon', group='MA Ribbon')
rl5 = input.int(36, title='/5', inline='Ribbon', group='MA Ribbon')
rl6 = input.int(45, title='/6', inline='Ribbon', group='MA Ribbon')
rl7 = input.int(55, title='/7', inline='Ribbon', group='MA Ribbon')
rl8 = input.int(444, title='/8', inline='Ribbon', group='MA Ribbon')


rib1 = getMa1(rl1)
rib2 = getMa1(rl2)
rib3 = getMa1(rl3)
rib4 = getMa1(rl4)
rib5 = getMa1(rl5)
rib6 = getMa1(rl6)
rib7 = getMa1(rl7)
rib8 = getMa1(rl8)

plot(rib1, color=color.new(#F5B771, 0), title='1', linewidth=2, display=display.none)
plot(rib2, color=color.new(#F5B056, 0), title='2', linewidth=2, display=display.none)
plot(rib3, color=color.new(#F57B4E, 0), title='3', linewidth=2, display=display.none)
plot(rib4, color=color.new(#F56D58, 0), title='4', linewidth=2, display=display.none)
plot(rib5, color=color.new(#F57D51, 0), title='5', linewidth=2, display=display.none)
plot(rib6, color=color.new(#F55151, 0), title='6', linewidth=2, display=display.none)
plot(rib7, color=color.new(#AA2707, 0), title='7', linewidth=2, display=display.none)
plot(rib8, color=color.new(#AA0000, 0), title='8', linewidth=2, display=display.none)

sma8 = getMa(cl8)
sma7 = getMa(cl7)
sma6 = getMa(cl6)
sma5 = getMa(cl5)
sma4 = getMa(cl4)
sma3 = getMa(cl3)
sma2 = getMa(cl2)
sma1 = getMa(cl1)

l8 = plot(sma8, display=display.none, editable=false)
l7 = plot(sma7, display=display.none, editable=false)
l6 = plot(sma6, display=display.none, editable=false)
l5 = plot(sma5, display=display.none, editable=false)
l4 = plot(sma4, display=display.none, editable=false)
l3 = plot(sma3, display=display.none, editable=false)
l2 = plot(sma2, display=display.none, editable=false)
l1 = plot(sma1, display=display.none, editable=false)
// --> fill
fill(l8, l1, color=sma7 <= source ? c01 : c02, editable=false)
fill(l7, l1, color=sma7 <= source ? c01 : c02, editable=false)
fill(l6, l1, color=sma6 <= source ? c01 : c02, editable=false)
fill(l5, l1, color=sma5 <= source ? c01 : c02, editable=false)
fill(l4, l1, color=sma4 <= source ? c01 : c02, editable=false)
fill(l3, l1, color=sma3 <= source ? c01 : c02, editable=false)
fill(l2, l1, color=sma2 <= source ? c01 : c02, editable=false)


//plotchar(show_seq ? setupCount == 1 : na, char='', text='1', textcolor=setupCountColor, color=setupCountColor, location=location.abovebar, size=size.tiny)
//plotchar(show_seq ? setupCount == 2 : na, char='', text='2', textcolor=setupCountColor, color=setupCountColor, location=location.abovebar, size=size.tiny, display = display.none)
//plotchar(show_seq ? setupCount == 3 : na, char='', text='3', textcolor=setupCountColor, color=setupCountColor, location=location.abovebar, size=size.tiny, display = display.none)
//plotchar(show_seq ? setupCount == 4 : na, char='', text='4', textcolor=setupCountColor, color=setupCountColor, location=location.abovebar, size=size.tiny, display = display.none)
//plotchar(show_seq ? setupCount == 5 : na, char='', text='5', textcolor=setupCountColor, color=setupCountColor, location=location.abovebar, size=size.tiny, display = display.none)
//plotchar(show_seq ? setupCount == 6 : na, char='', text='6', textcolor=setupCountColor, color=setupCountColor, location=location.abovebar, size=size.tiny, display = display.none)
//plotchar(show_seq ? setupCount == 7 : na, char='', text='7', textcolor=setupCountColor, color=setupCountColor, location=location.abovebar, size=size.tiny, display = display.none)
//plotchar(show_seq ? setupCount == 8 : na, char='', text='8', textcolor=setupCountColor, color=setupCountColor, location=location.abovebar, size=size.tiny)
//plotchar(show_seq ? setupCount == 9 : na, char='', text='9', textcolor=setupCountColor, color=setupCountColor, location=location.abovebar, size=size.tiny)


// ALERTS {

// } ALERTS



// Bar Coloring


// Input
fastLength = input(title="Fast Length", defval=12)
slowLength = input(title="Slow Length", defval=26)
srrrc = input(title="Source", defval=close)
signalLength = input.int(title="Signal Smoothing",  minval = 1, maxval = 50, defval = 9)

// Data reference
[macd, signal, hist] = ta.macd(srrrc, fastLength, slowLength, signalLength)

// 4 level of green
greenHigh = #05df09
greenMidHigh = #05df09
greenMidLow = #388E3C
greenLow = #5f3a97

// Yellow
yellowLow = #5f3a97

// 4 level of red
redHigh = #ea0402
redMidHigh = #ea0402
redMidLow = #cc0402
redLow = #5f3a97

// Default color
candleBody = yellowLow

// Ranging trend
if hist > 0
    if hist > hist[1] and hist[1] > 0
        candleBody := greenLow
        
if hist < 0
    if hist < hist[1] and hist[1] < 0
        candleBody := redLow

// Bullish trend
if macd > 0 and hist > 0
    candleBody := greenMidLow
    
    if hist > hist[1] and macd[1] > 0 and hist[1] > 0
        candleBody := greenMidHigh
        
        if hist > hist[2] and macd[2] > 0 and hist[2] > 0
            candleBody := greenHigh

// Bearish trend
if macd < 0 and hist < 0
    candleBody := redMidLow
    
    if hist < hist[1] and macd[1] < 0 and hist[1] < 0
        candleBody := redMidHigh
        
        if hist < hist[2] and macd[2] < 0 and hist[2] < 0
            candleBody := redHigh

barcolor(Barcolloring == "Version 1" ? candleBody : close > supertrends ? color.rgb(102, 255, 0) : color.rgb(255, 0, 0)) // Include suggestion by Shaheen204

// TP Signals

multiplier = input.float(title='TP', defval=2, minval=1)
src5 = close
len5 = input.int(title='TP length', defval=150, minval=1)
offset = 0

calcSlope(src5, len5) =>
    sumX = 0.0
    sumY = 0.0
    sumXSqr = 0.0
    sumXY = 0.0
    for i = 1 to len5 by 1
        val = src5[len5 - i]
        per = i + 1.0
        sumX += per
        sumY += val
        sumXSqr += per * per
        sumXY += val * per
        sumXY


    slope = (len5 * sumXY - sumX * sumY) / (len5 * sumXSqr - sumX * sumX)
    average = sumY / len5
    intercept = average - slope * sumX / len5 + slope
    [slope, average, intercept]

var float tmp = na
[s, a, i] = calcSlope(src5, len5)

vwap1 = i + s * (len5 - offset)
sdev = ta.stdev(close, len5)
dev = multiplier * sdev
top = vwap1 + dev
bott = vwap1 - dev

//
z1 = vwap1 + dev
x1 = vwap1 - dev

low1 = ta.crossover(close, x1)
high1 = ta.crossunder(close, z1)

plotshape(tpmode == "Version 2" and close < supertrend ? low1 : na, title='low', text='TP', color=color.new(color.red, 0), style=shape.labelup, location=location.belowbar, size=size.small, textcolor=color.new(color.white, 0))  //plot for buy icon
plotshape(tpmode == "Version 2" and close > supertrend ? high1 : na, title='high', text='TP', color=color.new(color.green, 0), style=shape.labeldown, location=location.abovebar, size=size.small, textcolor=color.new(color.white, 0))  //plot for sell icon

// PullBack Signals

start = input.float(title='Start', step=0.00005, defval=0.0134)
increment = input.float(title='Increment', step=0.00005, defval=0.)
maximum = input.float(title='Maximum', step=0.01, defval=0.21)
width = input.int(title='Point Width', minval=1, defval=20)
highlightStartPoints = input(title='Highlight Start Points ?', defval=true)

Curly_Fries = input(150, title='Fast')

EmaClD   = input.bool(true, title="Show TP/SL Points", tooltip="Show TP | Stop Loss Points")

Popeyes = input(200, title='Medium')
Chicken_Sandwich = input(250, 'Slow')
ema_150 = ta.ema(close, Curly_Fries)
ema_200 = ta.ema(close, Popeyes)
ema_250 = ta.ema(close, Chicken_Sandwich)
//a = plot(ema_150, transp=100)
//b = plot(ema_200, transp=100)
//c = plot(ema_250, transp=100)
up = ema_150 > ema_250
down = ema_150 < ema_250
mycolor = up and EmaClD  ? color.rgb(0, 255, 234, 71) : down and EmaClD ? color.rgb(255, 12, 32, 72) : na

//fill(a, c, color=mycolor, transp=70)


psar = ta.sar(start, increment, maximum)
dir = psar < close ? 1 : -1

//psarColor = psar < close ? color.rgb(6, 197, 255) : color.rgb(255, 0, 0)


plotshape( close > supertrend and dir == 1 and dir[1] == -1 and highlightStartPoints and ma01 > ma02 and dif > filter ? psar and up : na, title='Up Trend Pullback', style=shape.labelup, location=location.belowbar, size=size.tiny, text='▲', textcolor= color.white, color=#8800ed, transp=0)
plotshape( close < supertrend and dir == -1 and dir[1] == 1 and highlightStartPoints and ma02 > ma01 and dif > filter ? psar and down : na, title='Down Trend Pullback', style=shape.labeldown, location=location.abovebar, size=size.tiny, text='▼', textcolor= color.white, color=#8800ed, transp=0)


// Lux Algo Reversal BAnd


//func
kama(ssrc, llen) =>
    kama = 0.0
    sum_1 = math.sum(math.abs(ssrc - ssrc[1]), llen)
    sum_2 = math.sum(math.abs(ssrc - ssrc[1]), llen)
    kama := nz(kama[1]) + math.pow((sum_1 != 0 ? math.abs(ssrc - ssrc[llen]) / sum_2 : 0) * (0.288 - 0.0666) + 0.0666, 2) * (ssrc - nz(kama[1]))
    kama

//inputs
llength = input(50, title='Band Length')
bd1 = input(9, title='Frontrun Band Deviation')
bd2 = input(11, title='Initial Band Deviation')
bd3 = input(14, title='Final Band Deviation')

//logic
rg = kama(ta.tr, llength)
basis = kama(close, llength)
upper1 = basis + rg * bd1
upper2 = basis + rg * bd2
upper3 = basis + rg * bd3
lower1 = basis - rg * bd1
lower2 = basis - rg * bd2
lower3 = basis - rg * bd3

//ploting
pp1 = plot(show_rev ? upper1 : na, transp=100)
pp2 = plot(show_rev ? upper2  : na, transp=100)
pp3 = plot(show_rev ? upper3  : na, transp=100)
pp4 = plot(show_rev ? lower1  : na, transp=100)
pp5 = plot(show_rev ? lower2  : na, transp=100)
pp6 = plot(show_rev ? lower3  : na, transp=100)
fill(pp1, pp2, color=color.new(#57202c, 70))
fill(pp2, pp3, color=color.new(#57202c, 50))
fill(pp4, pp5, color=color.new(#103c3c, 70))
fill(pp5, pp6, color=color.new(#103c3c, 50))

// Dashboard


showDashboard     = input(true, "Show Dashboard", group="TREND DASHBOARD")
locationDashboard = input.string("Middle Right", "Table Location", ["Top Right", "Middle Right", "Bottom Right", "Top Center", "Middle Center", "Bottom Center", "Top Left", "Middle Left", "Bottom Left"], group="TREND DASHBOARD")
tableTextColor    = input(color.new(#b1b3be, 2), "Table Text Color", group="TREND DASHBOARD")
tableBgColor      = input(color.new(#232534,65), "Table Background Color", group="TREND DASHBOARD")
sizeDashboard     = input.string("Tiny", "Table Size", ["Large", "Normal", "Small", "Tiny"], group="TREND DASHBOARD")

// Functions
f_chartTfInMinutes() =>
    float _resInMinutes = timeframe.multiplier * (
      timeframe.isseconds ? 1. / 60             :
      timeframe.isminutes ? 1.                  :
      timeframe.isdaily   ? 60. * 24            :
      timeframe.isweekly  ? 60. * 24 * 7        :
      timeframe.ismonthly ? 60. * 24 * 30.4375  : na)

// Get components
emae  = ta.ema(close, 144)
emaBull = close > emae
equal_tf(res) => str.tonumber(res) == f_chartTfInMinutes()
higher_tf(res) => str.tonumber(res) > f_chartTfInMinutes()
too_small_tf(res) => (timeframe.isweekly and res=="1") or (timeframe.ismonthly and str.tonumber(res) < 10)
securityNoRep1(sym, res, srce) =>
    bool bulle = na
    bulle := equal_tf(res) ? srce : bulle
    bulle := higher_tf(res) ? request.security(sym, res, srce, barmerge.gaps_off, barmerge.lookahead_on) : bulle
    bull_array = request.security_lower_tf(syminfo.tickerid, higher_tf(res) ? str.tostring(f_chartTfInMinutes()) : too_small_tf(res) ? (timeframe.isweekly ? "3" : "10") : res, srce)
    if array.size(bull_array) > 1 and not equal_tf(res) and not higher_tf(res)
        bulle := array.pop(bull_array)
    array.clear(bull_array)
    bulle
TF1Bull   = securityNoRep1(syminfo.tickerid, "1"   , emaBull)
TF3Bull   = securityNoRep1(syminfo.tickerid, "3"   , emaBull)
TF5Bull   = securityNoRep1(syminfo.tickerid, "5"   , emaBull)
TF15Bull  = securityNoRep1(syminfo.tickerid, "15"  , emaBull)
TF30Bull  = securityNoRep1(syminfo.tickerid, "30"  , emaBull)
TF60Bull  = securityNoRep1(syminfo.tickerid, "60"  , emaBull)
TF120Bull = securityNoRep1(syminfo.tickerid, "120" , emaBull)
TF240Bull = securityNoRep1(syminfo.tickerid, "240" , emaBull)
TF480Bull = securityNoRep1(syminfo.tickerid, "480" , emaBull)
TFDBull   = securityNoRep1(syminfo.tickerid, "1440", emaBull)

var dashboard_loc  = locationDashboard == "Top Right" ? position.top_right : locationDashboard == "Middle Right" ? position.middle_right : locationDashboard == "Bottom Right" ? position.bottom_right : locationDashboard == "Top Center" ? position.top_center : locationDashboard == "Middle Center" ? position.middle_center : locationDashboard == "Bottom Center" ? position.bottom_center : locationDashboard == "Top Left" ? position.top_left : locationDashboard == "Middle Left" ? position.middle_left : position.bottom_left
var dashboard_size = sizeDashboard == "Large" ? size.large : sizeDashboard == "Normal" ? size.normal : sizeDashboard == "Small" ? size.small : size.tiny
var dashboard      = showDashboard ? table.new(dashboard_loc, 2, 15, tableBgColor, #404250, 1, tableBgColor, 1) : na
dashboard_cell(column, row, txt, signal=false) => table.cell(dashboard, column, row, txt, 0, 0, signal ? #737581 : tableTextColor, text_size=dashboard_size)
dashboard_cell_bg(column, row, col) => table.cell_set_bgcolor(dashboard, column, row, col)
if barstate.islast and showDashboard
    dashboard_cell(0, 0 , "Futures Algo")
    dashboard_cell(0, 1 , "Current Position")
    dashboard_cell(0, 2 , "Current Trend")
    dashboard_cell(0, 3 , "Volume")
    dashboard_cell(0, 4 , "Timeframe")
    dashboard_cell(0, 5 , "1 min:")
    dashboard_cell(0, 6 , "3 min:")
    dashboard_cell(0, 7 , "5 min:")
    dashboard_cell(0, 8 , "15 min:")
    dashboard_cell(0, 9 , "30 min:")
    dashboard_cell(0, 10, "1 H:")
    dashboard_cell(0, 11, "2 H:")
    dashboard_cell(0, 12, "4 H:")
    dashboard_cell(0, 13, "8 H:")
    dashboard_cell(0, 14, "Daily:")
    dashboard_cell(1, 0 , "Premium")
    dashboard_cell(1, 1 , emaBull ? "Bullish" : "Bearish", true), dashboard_cell_bg(1, 1, emaBull ? color.new(#125e5a, 10) : color.new(#672230, 10))
    dashboard_cell(1, 2 , str.tostring(math.round_to_mintick(volume)))
    dashboard_cell(1, 3 , "Trends")
    dashboard_cell(1, 4 , TF1Bull   ? "Bullish" : "Bearish", true), dashboard_cell_bg(1, 4 , TF1Bull   ? color.new(#125e5a, 10) : color.new(#672230, 10))
    dashboard_cell(1, 5 , TF3Bull   ? "Bullish" : "Bearish", true), dashboard_cell_bg(1, 5 , TF3Bull   ? color.new(#125e5a, 10) : color.new(#672230, 10))
    dashboard_cell(1, 6 , TF5Bull   ? "Bullish" : "Bearish", true), dashboard_cell_bg(1, 6 , TF5Bull   ? color.new(#125e5a, 10) : color.new(#672230, 10))
    dashboard_cell(1, 7 , TF15Bull  ? "Bullish" : "Bearish", true), dashboard_cell_bg(1, 7 , TF15Bull  ? color.new(#125e5a, 10) : color.new(#672230, 10))
    dashboard_cell(1, 8 , TF30Bull  ? "Bullish" : "Bearish", true), dashboard_cell_bg(1, 8 , TF30Bull  ? color.new(#125e5a, 10) : color.new(#672230, 10))
    dashboard_cell(1, 9, TF60Bull  ? "Bullish" : "Bearish", true), dashboard_cell_bg(1, 9, TF60Bull  ? color.new(#125e5a, 10) : color.new(#672230, 10))
    dashboard_cell(1, 10, TF120Bull ? "Bullish" : "Bearish", true), dashboard_cell_bg(1, 10, TF120Bull ? color.new(#125e5a, 10) : color.new(#672230, 10))
    dashboard_cell(1, 11, TF240Bull ? "Bullish" : "Bearish", true), dashboard_cell_bg(1, 11, TF240Bull ? color.new(#125e5a, 10) : color.new(#672230, 10))
    dashboard_cell(1, 12, TF480Bull ? "Bullish" : "Bearish", true), dashboard_cell_bg(1, 12, TF480Bull ? color.new(#125e5a, 10) : color.new(#672230, 10))
    dashboard_cell(1, 13, TFDBull   ? "Bullish" : "Bearish", true), dashboard_cell_bg(1, 13, TFDBull   ? color.new(#125e5a, 10) : color.new(#672230, 10))

// 
// Ha Market Bias //

tf(_res, _exp, gaps_on) =>
    gaps_on == 0 ? request.security(syminfo.tickerid, _res, _exp) : gaps_on == true ? request.security(syminfo.tickerid, _res, _exp, barmerge.gaps_on, barmerge.lookahead_off) : request.security(syminfo.tickerid, _res, _exp, barmerge.gaps_off, barmerge.lookahead_off)

ha_htf = ''
ha_len = 100
ha_len2 = 100

// Calculations {
o = ta.ema(open, ha_len)
c = ta.ema(close, ha_len)
h = ta.ema(high, ha_len)
l = ta.ema(low, ha_len)

haclose = tf(ha_htf, (o + h + l + c) / 4, 0)
xhaopen = tf(ha_htf, (o + c) / 2, 0)
haopen = na(xhaopen[1]) ? (o + c) / 2 : (xhaopen[1] + haclose[1]) / 2
hahigh = math.max(h, math.max(haopen, haclose))
halow = math.min(l, math.min(haopen, haclose))


o2 = tf(ha_htf, ta.ema(haopen, ha_len2), 0)
c2 = tf(ha_htf, ta.ema(haclose, ha_len2), 0)
h2 = tf(ha_htf, ta.ema(hahigh, ha_len2), 0)
l22 = tf(ha_htf, ta.ema(halow, ha_len2), 0)

ha_avg = (h2 + l22) / 2
// }
    
// Oscillator {
osc_len = 7

osc_bias = 100 *(c2 - o2)
osc_smooth = ta.ema(osc_bias, osc_len)

sigcolor = 
  (osc_bias > 0) and (osc_bias >= osc_smooth) ? color.new(color.lime, 35) : 
  (osc_bias > 0) and (osc_bias < osc_smooth) ? color.new(color.lime, 75) : 
  (osc_bias < 0) and (osc_bias <= osc_smooth) ? color.new(color.red, 35) : 
  (osc_bias < 0) and (osc_bias > osc_smooth) ? color.new(color.red, 75) :
  na
// }

// Plots {
p_h = plot(h2, "Bias High", color=color(na), display=display.none, editable=false)
p_l = plot(l22, "Bias Low", color=color(na), display=display.none, editable=false)
p_avg = plot(ha_avg, "Bias Avergae", color=color(na), display=display.none, editable=false)


fill(p_l, p_h, show_ha ? sigcolor : na)
col = o2 > c2 ? color.red : color.lime
// }

// Range Filter DW


//---------------------Range Filter----------------------------------------------------------------------------------------------------------------------

//Conditional Sampling EMA Function 
Cond_EMA(x, cond, n) =>
    var val = array.new_float(0)
    var ema_val = array.new_float(1)
    if cond
        array.push(val, x)
        if array.size(val) > 1
            array.remove(val, 0)
        if na(array.get(ema_val, 0))
            array.fill(ema_val, array.get(val, 0))
        array.set(ema_val, 0, (array.get(val, 0) - array.get(ema_val, 0)) * (2 / (n + 1)) + array.get(ema_val, 0))
    EMA = array.get(ema_val, 0)
    EMA

//Conditional Sampling SMA Function
Cond_SMA(x, cond, n) =>
    var vals = array.new_float(0)
    if cond
        array.push(vals, x)
        if array.size(vals) > n
            array.remove(vals, 0)
    SMA = array.avg(vals)
    SMA

//Standard Deviation Function
Stdev(x, n) =>
    math.sqrt(Cond_SMA(math.pow(x, 2), 1, n) - math.pow(Cond_SMA(x, 1, n), 2))

//Range Size Function
rng_size(x, scale, qty, n) =>
    ATR = Cond_EMA(ta.tr(true), 1, n)
    AC = Cond_EMA(math.abs(x - x[1]), 1, n)
    SD = Stdev(x, n)
    rng_size = scale == 'Pips' ? qty * 0.0001 : scale == 'Points' ? qty * syminfo.pointvalue : scale == '% of Price' ? close * qty / 100 : scale == 'ATR' ? qty * ATR : scale == 'Average Change' ? qty * AC : scale == 'Standard Deviation' ? qty * SD : scale == 'Ticks' ? qty * syminfo.mintick : qty
    rng_size

//Two Type Range Filter Function
rng_filt(h, l, rng_, n, type, smooth, sn, av_rf, av_n) =>
    rng_smooth = Cond_EMA(rng_, 1, sn)
    r = smooth ? rng_smooth : rng_
    var rfilt = array.new_float(2, (h + l) / 2)
    array.set(rfilt, 1, array.get(rfilt, 0))
    if type == 'Type 1'
        if h - r > array.get(rfilt, 1)
            array.set(rfilt, 0, h - r)
        if l + r < array.get(rfilt, 1)
            array.set(rfilt, 0, l + r)
    if type == 'Type 2'
        if h >= array.get(rfilt, 1) + r
            array.set(rfilt, 0, array.get(rfilt, 1) + math.floor(math.abs(h - array.get(rfilt, 1)) / r) * r)
        if l <= array.get(rfilt, 1) - r
            array.set(rfilt, 0, array.get(rfilt, 1) - math.floor(math.abs(l - array.get(rfilt, 1)) / r) * r)
    rng_filt1 = array.get(rfilt, 0)
    hi_band1 = rng_filt1 + r
    lo_band1 = rng_filt1 - r
    rng_filt2 = Cond_EMA(rng_filt1, rng_filt1 != rng_filt1[1], av_n)
    hi_band2 = Cond_EMA(hi_band1, rng_filt1 != rng_filt1[1], av_n)
    lo_band2 = Cond_EMA(lo_band1, rng_filt1 != rng_filt1[1], av_n)
    rng_filt = av_rf ? rng_filt2 : rng_filt1
    hi_band = av_rf ? hi_band2 : hi_band1
    lo_band = av_rf ? lo_band2 : lo_band1
    [hi_band, lo_band, rng_filt]

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------
//Inputs
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------

//Filter Type
f_type = 'Type 2'

//Movement Source
mov_src = 'Close'

//Range Size Inputs
rng_qty = 2.618
rng_scale = 'Average Change'

//Range Period
rng_per = 14

//Range Smoothing Inputs
smooth_range = true
smooth_per = 27

//Filter Value Averaging Inputs
av_vals = false
av_samples = 2

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------
//Definitions
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------

//High And Low Values
h_val = mov_src == 'Wicks' ? high : close
l_val = mov_src == 'Wicks' ? low : close

//Range Filter Values
[h_band, l_band, filt] = rng_filt(h_val, l_val, rng_size((h_val + l_val) / 2, rng_scale, rng_qty, rng_per), rng_per, f_type, smooth_range, smooth_per, av_vals, av_samples)

//Direction Conditions
var fdir = 0.0
fdir := filt > filt[1] ? 1 : filt < filt[1] ? -1 : fdir
upward = fdir == 1 ? 1 : 0
downward = fdir == -1 ? 1 : 0

//Colors
filt_color = upward ? #36db7f : downward ? #be130f : #cccccc

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------
//Outputs
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------

//Filter Plot
filt_plot = plot(Show_rangefilter ? filt : na, color=filt_color, linewidth=3, title='Filter', transp=0)

//Bar Color

//External Trend Output
plot(fdir, editable=false, display=display.none, title='External Output - Trend Signal', transp=100)


// Superlchi + TBO 

tenkan_len  = 6
tenkan_mult = 2

kijun_len   = 5
kijun_mult  = 3.

spanB_len   = 26
spanB_mult  = 4.

offsett      = 0
//------------------------------------------------------------------------------
avg(srcc,length,mult)=>
    atr = ta.atr(length)*mult
    up = hl2 + atr
    dn = hl2 - atr
    upper = 0.,lower = 0.
    upper := srcc[1] < upper[1] ? math.min(up,upper[1]) : up
    lower := srcc[1] > lower[1] ? math.max(dn,lower[1]) : dn
    
    os = 0,max = 0.,min = 0.
    os := srcc > upper ? 1 : srcc < lower ? 0 : os[1]
    spt = os == 1 ? lower : upper
    max := ta.cross(srcc,spt) ? math.max(srcc,max[1]) : os == 1 ? math.max(srcc,max[1]) : spt
    min := ta.cross(srcc,spt) ? math.min(srcc,min[1]) : os == 0 ? math.min(srcc,min[1]) : spt
    math.avg(max,min)
//------------------------------------------------------------------------------
tenkan = avg(close,tenkan_len,tenkan_mult)
kijun = avg(close,kijun_len,kijun_mult)

senkouA = math.avg(kijun,tenkan)
senkouB = avg(close,spanB_len,spanB_mult)
//------------------------------------------------------------------------------
tenkan_css = #2157f3
kijun_css = #ff5d00

cloud_a = color.new(color.teal,80)
cloud_b = color.new(color.red,80)

chikou_css = #7b1fa2

plot(Show_SuperIchi ? tenkan : na,'Tenkan-Sen',tenkan_css)
plot(Show_SuperIchi ? kijun : na,'Kijun-Sen',kijun_css)

plot(ta.crossover(tenkan,kijun) and Show_SuperIchi ? kijun : na,'Crossover',#2157f3,3,plot.style_circles)
plot(ta.crossunder(tenkan,kijun) and Show_SuperIchi ? kijun : na,'Crossunder',#ff5d00,3,plot.style_circles)

A = plot(Show_SuperIchi ? senkouA : na,'Senkou Span A',na,offset=offsett-1)
B = plot(Show_SuperIchi ? senkouB : na,'Senkou Span B',na,offset=offsett-1)
fill(A,B,senkouA > senkouB ? cloud_a : cloud_b)

plot(close,'Chikou',chikou_css,offset=-offsett+1,display=display.none)

