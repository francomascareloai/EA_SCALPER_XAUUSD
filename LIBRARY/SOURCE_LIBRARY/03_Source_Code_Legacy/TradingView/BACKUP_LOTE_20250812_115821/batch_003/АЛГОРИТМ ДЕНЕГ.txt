//@version=5

// Благодарность приветствуется !
// Donations  ~ BTC ~ 1EpDN7pg1WqURcK7te5kQtgx3H17wuHiV7

indicator(title="[$/АЛГОРИТМ ДЕНЕГ/$[V5]", shorttitle='*$/АЛГОРИТМ ДЕНЕГ/$*', overlay=true, max_bars_back=1200, max_lines_count=500, max_labels_count=500) 

confidence(pearsonR) =>
    switch
        pearsonR < 0.2  => "Крайне слабый"
        pearsonR < 0.3  => "Очень слабый"
        pearsonR < 0.4  => "Слабый"
        pearsonR < 0.5  => "В основном слабый"
        pearsonR < 0.6  => "Относительно слабый"
        pearsonR < 0.7  => "Умеренно слабый"
        pearsonR < 0.8  => "Умеренный"
        pearsonR < 0.9  => "Умеренно сильный"
        pearsonR < 0.92 => "В основном сильный"
        pearsonR < 0.94 => "Сильный"
        pearsonR < 0.96 => "Очень сильный"
        pearsonR < 0.98 => "Исключительно сильный"
        =>                        "Ультра сильный"

getTablePosition(string pos) =>
    switch pos
        "Справа внизу"   => position.bottom_right
        "Внизу по центру" => position.bottom_center        
        "Слева внизу"   => position.bottom_left
        "Справа вверху"     => position.top_right
        "Слева вверху"      => position.top_left
        "Вверху по центру"    => position.top_center
        "Правый центр"  => position.middle_right
        =>                 position.middle_left // "Слева в центре" - по умолчанию

// Рассчитать отклонения для заданной длины
calcDev(float source, int length) =>
    float logSource  = math.log(source)
    var int period_1 = length - 1
    if barstate.islast
        float sumX  = 0.0
        float sumXX = 0.0
        float sumYX = 0.0
        float sumY  = 0.0
        for int i=1 to length
            float lSrc = logSource[i-1]
            sumX  += i
            sumXX += i * i
            sumYX += i * lSrc
            sumY  +=     lSrc
        float slope     = nz((length * sumYX - sumX * sumY) / (length * sumXX - sumX * sumX))
        float average   = sumY / length
        float intercept = average - (slope * sumX / length) + slope
        float sumDev = 0.0
        float sumDxx = 0.0
        float sumDyy = 0.0
        float sumDyx = 0.0
        float regres = intercept + slope * period_1 * 0.5
        float sumSlp = intercept
        for int i=0 to period_1
            float lSrc = logSource[i]
            float dxt  =   lSrc - average
            float dyt  = sumSlp - regres
            lSrc   -= sumSlp
            sumSlp += slope
            sumDxx +=  dxt * dxt
            sumDyy +=  dyt * dyt
            sumDyx +=  dxt * dyt
            sumDev += lSrc * lSrc
        float unStdDev = math.sqrt(sumDev / period_1) // Несмещенное
        float divisor  =    sumDxx * sumDyy
        float pearsonR = nz(sumDyx / math.sqrt(divisor))
        [unStdDev, pearsonR, slope, intercept]
    else
        [na, na, na, na]

string t1 = "В режиме долгосрочного канала, если канал не виден, прокрутите график для дополнительных исторических данных."
string t2 = "Коэффициент Пирсона R, статистический показатель в адаптивном поиске трендов, оценивает линейную зависимость между ценой и проекцией тренда. Значение, близкое к 1, указывает на сильную положительную корреляцию, укрепляя уверенность в направлении тренда на основе исторических движений цен."

sourceInput = input.source(close, title="Источник")

string group0 = "НАСТРОЙКИ КАНАЛА"
bool   periodMode       = input.bool  (         false, "Использовать долгосрочный канал", group=group0, tooltip=t1)
float  devMultiplier    = input.float (           2.0, "Множитель отклонения:", group=group0, step=0.1)
color  colorInput       = input.color (  color.gray,             "", group=group0, inline=group0)
string lineStyle1       = input.string(       "Сплошная",             "", group=group0, inline=group0, options=["Сплошная", "Пунктирная", "Штриховая"])
string extendStyle      = input.string("Не расширять",             "", group=group0, inline=group0, options=["Расширить справа", "Расширить обе", "Не расширять", "Расширить слева"])
int    fillTransparency = input.int   (            93, "Прозрачность заливки:", group=group0, inline="середина", minval=0, maxval=100, step=1)
int channelTransparency = input.int   (            40, "Прозрачность линии:", group=group0, inline="середина", minval=0, maxval=100, step=1)

string group1 = "НАСТРОЙКИ СРЕДНЕЙ ЛИНИИ"
int    transpInput  = input.int   (     100,      "Прозрачность:", group=group1, inline=group1, minval=0, maxval=100, step=10)
int    lineWidth    = input.int   (       1,  "Толщина линии:", group=group1, inline=group1)
string midLineStyle = input.string("Сплошная",              "", group=group1, inline=group1, options=["Пунктирная", "Сплошная", "Штриховая"])

string group2 = "НАСТРОЙКИ ТАБЛИЦЫ"
string tablePositionInput = input.string("Справа внизу", "Положение таблицы", options=["Справа внизу", "Слева внизу", "Справа вверху", "Слева вверху", "Вверху по центру", "Внизу по центру", "Правый центр", "Левый центр"], group=group2)
bool   showPearsonInput   = input.bool  (         false, "Показать коэффициент Пирсона R вместо Уровня Уверенности", group=group2, tooltip=t2)
string textSizeInput      = input.string(      "Обычный",      "Размер текста", options=["Обычный", "Большой"], group=group2)

var string EXTEND_STYLE = switch extendStyle
    "Расширить справа" => extend.right
    "Расширить обе"  => extend.both
    "Не расширять"  => extend.none
    =>                extend.left

// Длины периодов
var array<int> Periods = periodMode ? array.from(na,300,350,400,450,500,550,600,650,700,750,800,850,900,950,1000,1050,1100,1150,1200) : array.from(na,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200)

// Рассчитать отклонения, корреляцию, наклон и перехват для разных длин периодов
[stdDev01, pearsonR01, slope01, intercept01] = calcDev(sourceInput, Periods.get( 1))
[stdDev02, pearsonR02, slope02, intercept02] = calcDev(sourceInput, Periods.get( 2))
[stdDev03, pearsonR03, slope03, intercept03] = calcDev(sourceInput, Periods.get( 3))
[stdDev04, pearsonR04, slope04, intercept04] = calcDev(sourceInput, Periods.get( 4))
[stdDev05, pearsonR05, slope05, intercept05] = calcDev(sourceInput, Periods.get( 5))
[stdDev06, pearsonR06, slope06, intercept06] = calcDev(sourceInput, Periods.get( 6))
[stdDev07, pearsonR07, slope07, intercept07] = calcDev(sourceInput, Periods.get( 7))
[stdDev08, pearsonR08, slope08, intercept08] = calcDev(sourceInput, Periods.get( 8))
[stdDev09, pearsonR09, slope09, intercept09] = calcDev(sourceInput, Periods.get( 9))
[stdDev10, pearsonR10, slope10, intercept10] = calcDev(sourceInput, Periods.get(10))
[stdDev11, pearsonR11, slope11, intercept11] = calcDev(sourceInput, Periods.get(11))
[stdDev12, pearsonR12, slope12, intercept12] = calcDev(sourceInput, Periods.get(12))
[stdDev13, pearsonR13, slope13, intercept13] = calcDev(sourceInput, Periods.get(13))
[stdDev14, pearsonR14, slope14, intercept14] = calcDev(sourceInput, Periods.get(14))
[stdDev15, pearsonR15, slope15, intercept15] = calcDev(sourceInput, Periods.get(15))
[stdDev16, pearsonR16, slope16, intercept16] = calcDev(sourceInput, Periods.get(16))
[stdDev17, pearsonR17, slope17, intercept17] = calcDev(sourceInput, Periods.get(17))
[stdDev18, pearsonR18, slope18, intercept18] = calcDev(sourceInput, Periods.get(18))
[stdDev19, pearsonR19, slope19, intercept19] = calcDev(sourceInput, Periods.get(19))

if barstate.islast
    // Найти наибольший коэффициент Пирсона R
    float highestPearsonR = math.max(pearsonR01, pearsonR02, pearsonR03, pearsonR04, pearsonR05, pearsonR06, pearsonR07, pearsonR08, pearsonR09, pearsonR10, pearsonR11, pearsonR12, pearsonR13, pearsonR14, pearsonR15, pearsonR16, pearsonR17, pearsonR18, pearsonR19)

    // Определить выбранную длину, наклон и перехват
    int   detectedPeriod  = na
    float detectedSlope   = na
    float detectedIntrcpt = na
    float detectedStdDev  = na

    switch highestPearsonR
        pearsonR01 =>
            detectedPeriod  := Periods.get(1)
            detectedSlope   :=     slope01
            detectedIntrcpt := intercept01
            detectedStdDev  :=    stdDev01
        pearsonR02 =>
            detectedPeriod  := Periods.get(2)
            detectedSlope   :=     slope02
            detectedIntrcpt := intercept02
            detectedStdDev  :=    stdDev02
        pearsonR03 =>
            detectedPeriod  := Periods.get(3)
            detectedSlope   :=     slope03
            detectedIntrcpt := intercept03
            detectedStdDev  :=    stdDev03
        pearsonR04 =>
            detectedPeriod  := Periods.get(4)
            detectedSlope   :=     slope04
            detectedIntrcpt := intercept04
            detectedStdDev  :=    stdDev04
        pearsonR05 =>
            detectedPeriod  := Periods.get(5)
            detectedSlope   :=     slope05
            detectedIntrcpt := intercept05
            detectedStdDev  :=    stdDev05
        pearsonR06 =>
            detectedPeriod  := Periods.get(6)
            detectedSlope   :=     slope06
            detectedIntrcpt := intercept06
            detectedStdDev  :=    stdDev06
        pearsonR07 =>
            detectedPeriod  := Periods.get(7)
            detectedSlope   :=     slope07
            detectedIntrcpt := intercept07
            detectedStdDev  :=    stdDev07
        pearsonR08 =>
            detectedPeriod  := Periods.get(8)
            detectedSlope   :=     slope08
            detectedIntrcpt := intercept08
            detectedStdDev  :=    stdDev08
        pearsonR09 =>
            detectedPeriod  := Periods.get(9)
            detectedSlope   :=     slope09
            detectedIntrcpt := intercept09
            detectedStdDev  :=    stdDev09
        pearsonR10 => 
            detectedPeriod  := Periods.get(10)
            detectedSlope   :=     slope10
            detectedIntrcpt := intercept10
            detectedStdDev  :=    stdDev10
        pearsonR11 =>        
            detectedPeriod  := Periods.get(11)
            detectedSlope   :=     slope11
            detectedIntrcpt := intercept11
            detectedStdDev  :=    stdDev11
        pearsonR12 =>
            detectedPeriod  := Periods.get(12)
            detectedSlope   :=     slope12
            detectedIntrcpt := intercept12
            detectedStdDev  :=    stdDev12
        pearsonR13 =>
            detectedPeriod  := Periods.get(13)
            detectedSlope   :=     slope13
            detectedIntrcpt := intercept13
            detectedStdDev  :=    stdDev13
        pearsonR14 =>
            detectedPeriod  := Periods.get(14)
            detectedSlope   :=     slope14
            detectedIntrcpt := intercept14
            detectedStdDev  :=    stdDev14
        pearsonR15 =>
            detectedPeriod  := Periods.get(15)
            detectedSlope   :=     slope15
            detectedIntrcpt := intercept15
            detectedStdDev  :=    stdDev15
        pearsonR16 =>
            detectedPeriod  := Periods.get(16)
            detectedSlope   :=     slope16
            detectedIntrcpt := intercept16
            detectedStdDev  :=    stdDev16
        pearsonR17 =>
            detectedPeriod  := Periods.get(17)
            detectedSlope   :=     slope17
            detectedIntrcpt := intercept17
            detectedStdDev  :=    stdDev17
        pearsonR18 =>
            detectedPeriod  := Periods.get(18)
            detectedSlope   :=     slope18
            detectedIntrcpt := intercept18
            detectedStdDev  :=    stdDev18
        => // ПирсонR19
            detectedPeriod  := Periods.get(19)
            detectedSlope   :=     slope19
            detectedIntrcpt := intercept19
            detectedStdDev  :=    stdDev19

    var line upperLine = na,   var linefill upperFill = na
    var line  baseLine = na
    var line lowerLine = na,   var linefill lowerFill = na

    // Рассчитать начальную и конечную цену на основе обнаруженного наклона и точки пересечения
    float startPrice = math.exp(detectedIntrcpt + detectedSlope * (detectedPeriod - 1))
    float   endPrice = math.exp(detectedIntrcpt)
    
    int         startAtBar = bar_index - detectedPeriod + 1
    var color ChannelColor = color.new(colorInput, channelTransparency)

    if na(baseLine)
        baseLine := line.new(startAtBar, startPrice, bar_index, endPrice,
                             width=lineWidth, extend=EXTEND_STYLE,
                             color=color.new(colorInput, transpInput),
                             style=midLineStyle == "Пунктирный" ? line.style_dotted :
                                   midLineStyle == "Пунктирная" ? line.style_dashed : line.style_solid)
    else
        line.set_xy1(baseLine, startAtBar, startPrice)
        line.set_xy2(baseLine,  bar_index,   endPrice)

    float upperStartPrice = startPrice * math.exp(devMultiplier * detectedStdDev)
    float upperEndPrice   =   endPrice * math.exp(devMultiplier * detectedStdDev)
    if na(upperLine)
        upperLine := line.new(startAtBar, upperStartPrice, bar_index, upperEndPrice,
                             width=1, extend=EXTEND_STYLE,
                             color=ChannelColor,
                             style=lineStyle1 == "Пунктирный" ? line.style_dotted :
                                   lineStyle1 == "Пунктирная" ? line.style_dashed : line.style_solid)
    else
        line.set_xy1  (upperLine, startAtBar, upperStartPrice)
        line.set_xy2  (upperLine,  bar_index,   upperEndPrice)
        line.set_color(upperLine, colorInput)

    float lowerStartPrice = startPrice / math.exp(devMultiplier * detectedStdDev)
    float   lowerEndPrice =   endPrice / math.exp(devMultiplier * detectedStdDev)
    if na(lowerLine)
        lowerLine := line.new(startAtBar, lowerStartPrice, bar_index, lowerEndPrice,
                             width=1, extend=EXTEND_STYLE,
                             color=ChannelColor,
                             style=lineStyle1 == "Пунктирный" ? line.style_dotted :
                                   lineStyle1 == "Пунктирная" ? line.style_dashed : line.style_solid)
    else
        line.set_xy1  (lowerLine, startAtBar, lowerStartPrice)
        line.set_xy2  (lowerLine,  bar_index,   lowerEndPrice)
        line.set_color(lowerLine, colorInput)

    if na(upperFill)
        upperFill := linefill.new(upperLine, baseLine, color=color.new(colorInput, fillTransparency))
    if na(lowerFill)
        lowerFill := linefill.new(baseLine, lowerLine, color=color.new(colorInput, fillTransparency))

    var table t  = table.new(getTablePosition(tablePositionInput), 3, 2)
    string text1 = periodMode ? "Автоматически выбранный период (долгосрочный): " + str.tostring(detectedPeriod)
                              : "Автоматически выбранный период:"             + str.tostring(detectedPeriod)
    var colorInputLight = color.new(colorInput, 40)
    table.cell(t, 0, 0, text1, text_color=colorInputLight, text_size=textSizeInput == "Большой" ? size.large : size.normal)
    if showPearsonInput
        table.cell(t, 1, 0, "Пирсон's R: " + str.tostring(detectedSlope > 0.0 ? -highestPearsonR : highestPearsonR, "#.###"), text_color=colorInput, text_size=textSizeInput == "Большой" ? size.large : size.normal)
    else
        table.cell(t, 1, 0, "Сила тренда:" + confidence(highestPearsonR), text_color=colorInput, text_size=textSizeInput == "Большой" ? size.large : size.normal)

//================================================================================================================================================================//

// Входные данные для полос Боллинджера
bb_use_ema = input.bool(false, title="Использовать основу EMA?")
bb_length = input.int(20, title="Длина Боллинджера")
bb_source = input(close, title="Источник Боллинджера")
bb_mult = input.float(2.0, title="Базовый множитель", minval=0.001, maxval=50)
bb_mult_inc = input.float(0.5, title="Прирост множителя", minval=0.001, maxval=2)
// Входные данные для индикатора разрыва
break_mult = input.float(2.7, title="Множитель разрыва", minval=0.001, maxval=50)
breakhigh_source = input(high, title="Источник верхнего разрыва")
breaklow_source = input(low, title="Источник нижнего разрыва")

bb_basis = bb_use_ema ? ta.ema(bb_source, bb_length) : ta.sma(bb_source, bb_length)
// Стандартное отклонение
dev = ta.stdev(bb_source, bb_length)
bb_dev_inner = bb_mult * dev
bb_dev_mid = (bb_mult + bb_mult_inc) * dev
bb_dev_outer = (bb_mult + (bb_mult_inc * 2)) * dev
break_dev = break_mult * dev
// Верхние полосы
inner_high = bb_basis + bb_dev_inner
mid_high = bb_basis + bb_dev_mid
outer_high = bb_basis + bb_dev_outer
// Нижние полосы
inner_low = bb_basis - bb_dev_inner
mid_low = bb_basis - bb_dev_mid
outer_low = bb_basis - bb_dev_outer
// Полосы разрыва
break_high = bb_basis + break_dev
break_low = bb_basis - break_dev
// отрисовка и заливка верхних полос
ubi = plot(inner_high, title="Внутренняя верхняя полоса", color=color.new(color.red, 90))
ubm = plot(mid_high, title="Средняя верхняя полоса", color=color.new(color.red, 85))
ubo = plot(outer_high, title="Внешняя верхняя полоса", color=color.new(color.red, 0))
fill(ubi, ubm, title="Заливка верхних полос", color=color.new(color.red, 90))
fill(ubm, ubo, title="Заливка внешних верхних полос",color=color.new(color.red, 80))
// отрисовка и заливка нижних полос
lbi = plot(inner_low, title="Внутренняя нижняя полоса", color=color.new(color.green, 90))
lbm = plot(mid_low, title="Средняя нижняя полоса", color=color.new(color.green, 85))
lbo = plot(outer_low, title="Внешняя нижняя полоса", color=color.new(color.green, 0))
fill(lbi, lbm, title="Заливка внутренних нижних полос", color=color.new(color.green, 90))
fill(lbm, lbo, title="Заливка внешних нижних полос", color=color.new(color.green, 80))
// заливка центрального канала
fill(ubi, lbi, title="Заливка центрального канала", color=color.new(color.silver, 100))
// отрисовка разрывов
plotshape(breakhigh_source >= break_high, title="Верхний разрыв", style=shape.triangledown, location=location.abovebar, size=size.tiny, color=color.red)
plotshape(breaklow_source <= break_low, title="Нижний разрыв", style=shape.triangleup, location=location.belowbar, size=size.tiny, color=color.green)

//========================================================================================================================================================//

FPeriod = input(144, title='Фибо-период')
plotF1618 = input(title='Участок 1.618 Уровень?', defval=true)

Fhigh = ta.highest(FPeriod)
Flow = ta.lowest(FPeriod)
FH = ta.highestbars(high, FPeriod)
FL = ta.lowestbars(low, FPeriod)
downfibo = FH < FL

F0 = downfibo ? Flow : Fhigh
F236 = downfibo ? (Fhigh - Flow) * 0.236 + Flow : Fhigh - (Fhigh - Flow) * 0.236
F382 = downfibo ? (Fhigh - Flow) * 0.382 + Flow : Fhigh - (Fhigh - Flow) * 0.382
F500 = downfibo ? (Fhigh - Flow) * 0.500 + Flow : Fhigh - (Fhigh - Flow) * 0.500
F618 = downfibo ? (Fhigh - Flow) * 0.618 + Flow : Fhigh - (Fhigh - Flow) * 0.618
F786 = downfibo ? (Fhigh - Flow) * 0.786 + Flow : Fhigh - (Fhigh - Flow) * 0.786
F1000 = downfibo ? (Fhigh - Flow) * 1.000 + Flow : Fhigh - (Fhigh - Flow) * 1.000
F1618 = downfibo ? (Fhigh - Flow) * 1.618 + Flow : Fhigh - (Fhigh - Flow) * 1.618

Fcolor = downfibo ? #03ff033a : #970008
Foffset = downfibo ? FH : FL

plot(F0, color=Fcolor, linewidth=2, trackprice=true, show_last=1, title='0')
plot(F236, color=Fcolor, linewidth=1, trackprice=true, show_last=1, title='0.236')
plot(F382, color=Fcolor, linewidth=1, trackprice=true, show_last=1, title='0.382')
plot(F500, color=Fcolor, linewidth=2, trackprice=true, show_last=1, title='0.5')
plot(F618, color=Fcolor, linewidth=1, trackprice=true, show_last=1, title='0.618')
plot(F786, color=Fcolor, linewidth=1, trackprice=true, show_last=1, title='0.786')
plot(F1000, color=Fcolor, linewidth=2, trackprice=true, show_last=1, title='1')
plot(plotF1618 ? F1618 : na, color=Fcolor, linewidth=3, trackprice=true, show_last=1, title='1.618')

plotshape(F0, style=shape.labeldown, location=location.absolute, color=Fcolor, textcolor=#ffffff, show_last=1, text='%0', offset=15)
plotshape(F236, style=shape.labeldown, location=location.absolute, color=Fcolor, textcolor=#ffffff, show_last=1, text='%23.6', offset=15)
plotshape(F382, style=shape.labeldown, location=location.absolute, color=Fcolor, textcolor=#ffffff, show_last=1, text='%38.2', offset=15)
plotshape(F500, style=shape.labeldown, location=location.absolute, color=Fcolor, textcolor=#ffffff, show_last=1, text='%50', offset=15)
plotshape(F618, style=shape.labeldown, location=location.absolute, color=Fcolor, textcolor=#ffffff, show_last=1, text='%61.8', offset=15)
plotshape(F786, style=shape.labeldown, location=location.absolute, color=Fcolor, textcolor=#ffffff, show_last=1, text='%78.6', offset=15)
plotshape(F1000, style=shape.labeldown, location=location.absolute, color=Fcolor, textcolor=#ffffff, show_last=1, text='%100', offset=15)

//=====================================================================================================================//

f_filt9x(_a, _s, _i) =>
    int _m2 = 0
    int _m3 = 0
    int _m4 = 0
    int _m5 = 0
    int _m6 = 0
    int _m7 = 0
    int _m8 = 0
    int _m9 = 0
    float _f = .0
    _x = 1 - _a
    // 
    _m2 := _i == 9 ? 36 : _i == 8 ? 28 : _i == 7 ? 21 : _i == 6 ? 15 : _i == 5 ? 10 : _i == 4 ? 6 : _i == 3 ? 3 : _i == 2 ? 1 : 0
    _m3 := _i == 9 ? 84 : _i == 8 ? 56 : _i == 7 ? 35 : _i == 6 ? 20 : _i == 5 ? 10 : _i == 4 ? 4 : _i == 3 ? 1 : 0
    _m4 := _i == 9 ? 126 : _i == 8 ? 70 : _i == 7 ? 35 : _i == 6 ? 15 : _i == 5 ? 5 : _i == 4 ? 1 : 0
    _m5 := _i == 9 ? 126 : _i == 8 ? 56 : _i == 7 ? 21 : _i == 6 ? 6 : _i == 5 ? 1 : 0
    _m6 := _i == 9 ? 84 : _i == 8 ? 28 : _i == 7 ? 7 : _i == 6 ? 1 : 0
    _m7 := _i == 9 ? 36 : _i == 8 ? 8 : _i == 7 ? 1 : 0
    _m8 := _i == 9 ? 9 : _i == 8 ? 1 : 0
    _m9 := _i == 9 ? 1 : 0
    // 
    _f := math.pow(_a, _i) * nz(_s) + _i * _x * nz(_f[1]) - (_i >= 2 ? _m2 * math.pow(_x, 2) * nz(_f[2]) : 0) + (_i >= 3 ? _m3 * math.pow(_x, 3) * nz(_f[3]) : 0) - (_i >= 4 ? _m4 * math.pow(_x, 4) * nz(_f[4]) : 0) + (_i >= 5 ? _m5 * math.pow(_x, 5) * nz(_f[5]) : 0) - (_i >= 6 ? _m6 * math.pow(_x, 6) * nz(_f[6]) : 0) + (_i >= 7 ? _m7 * math.pow(_x, 7) * nz(_f[7]) : 0) - (_i >= 8 ? _m8 * math.pow(_x, 8) * nz(_f[8]) : 0) + (_i == 9 ? _m9 * math.pow(_x, 9) * nz(_f[9]) : 0)
    _f
//
f_pole(_a, _s, _i) =>
    _f1 = f_filt9x(_a, _s, 1)
    _f2 = _i >= 2 ? f_filt9x(_a, _s, 2) : 0
    _f3 = _i >= 3 ? f_filt9x(_a, _s, 3) : 0
    _f4 = _i >= 4 ? f_filt9x(_a, _s, 4) : 0
    _f5 = _i >= 5 ? f_filt9x(_a, _s, 5) : 0
    _f6 = _i >= 6 ? f_filt9x(_a, _s, 6) : 0
    _f7 = _i >= 2 ? f_filt9x(_a, _s, 7) : 0
    _f8 = _i >= 8 ? f_filt9x(_a, _s, 8) : 0
    _f9 = _i == 9 ? f_filt9x(_a, _s, 9) : 0
    _fn = _i == 1 ? _f1 : _i == 2 ? _f2 : _i == 3 ? _f3 : _i == 4 ? _f4 : _i == 5 ? _f5 : _i == 6 ? _f6 : _i == 7 ? _f7 : _i == 8 ? _f8 : _i == 9 ? _f9 : na
    [_fn, _f1]
//
src = input(defval=hlc3, title='Источник')
int N = input.int(defval=5, title='Полюс фильтр ', minval=1, maxval=9)
int per = input.int(defval=50, title='Период выборки', minval=2)
float mult = input.float(defval=1, title='Отфильтрованный множитель истинного диапазона', minval=0)
bool modeLag = input(defval=true, title='Режим уменьшенной задержки')
bool modeFast = input(defval=true, title='Режим быстрого ответа')
//
beta = (1 - math.cos(4 * math.asin(1) / per)) / (math.pow(1.414, 2 / N) - 1)
alpha = -beta + math.sqrt(math.pow(beta, 2) + 2 * beta)
//
lag = (per - 1) / (2 * N)
//
srcdata = modeLag ? src + src - src[lag] : src
trdata = modeLag ? ta.tr(true) + ta.tr(true) - ta.tr(true)[lag] : ta.tr(true)
//
[filtn, filt1] = f_pole(alpha, srcdata, N)
[filtntr, filt1tr] = f_pole(alpha, trdata, N)
//
filt = modeFast ? (filtn + filt1) / 2 : filtn
filttr = modeFast ? (filtntr + filt1tr) / 2 : filtntr
//
hband = filt + filttr * mult
lband = filt - filttr * mult
// 
color1 = color.new(#0aff68, 50) 
color2 = color.new(#00752d, 50) 
color3 = color.new(#ff0000, 50) 
color4 = color.new(#990032, 50) 

fcolor = filt > filt[1] ? color.new(#4caf50, 50) : filt < filt[1] ? color.new(#ff5252, 50) : #cccccc 
//
filtplot = plot(filt, title='Фильтр', color=fcolor, linewidth=3)
hbandplot = plot(hband, title='Отфильтрованный верхний диапазон истинного диапазона', color=fcolor)
lbandplot = plot(lband, title='Фильтрованный нижний диапазон истинного диапазона', color=fcolor)
fill(hbandplot, lbandplot, title='Заполнение канала', color=color.new(fcolor, 90)) 

//=========================================================================================================//

//[S/R Dynamic Level Zones]

show_current_sr = input.bool(true, title = "Показать текущий уровень поддержки/сопротивления TF", group = "Параметр")
swing_length = input.int(10, title = 'Длина поворота', group = 'Параметр', minval = 1, maxval = 50)
history_of_demand_to_keep = input.int(20, title = 'Входные параметры', minval = 5, maxval = 50, group = "Параметр")
box_width = input.float(5, title = 'S/R Диапазон ', group = 'Параметр', minval = 1, maxval = 10, step = 0.5)

string group3 = "TF Параметр"
enableHtf1 = input.bool(false, group = group3, inline = "htf1", title = "")
htf1 = input.timeframe("D", "TF1", group = group3, inline = "htf1")
enableHtf2 = input.bool(false, group = group3, inline = "htf2", title = "")
htf2 = input.timeframe("5", "TF2", group = group3, inline = "htf2")
enableHtf3 = input.bool(false, group = group3, inline = "htf3", title = "")
htf3 = input.timeframe("15", "TF3", group = group3, inline = "htf3")
enableHtf4 = input.bool(false, group = group3, inline = "htf4", title = "")
htf4 = input.timeframe("30", "TF4", group = group3, inline = "htf4")
enableHtf5 = input.bool(false, group = group3, inline = "htf5", title = "")
htf5 = input.timeframe("45", "TF5", group = group3, inline = "htf5")
enableHtf6 = input.bool(false, group = group3, inline = "htf6", title = "")
htf6 = input.timeframe("60", "TF6", group = group3, inline = "htf6")
enableHtf7 = input.bool(false, group = group3, inline = "htf7", title = "")
htf7 = input.timeframe("120", "TF7", group = group3, inline = "htf7")
enableHtf8 = input.bool(false, group = group3, inline = "htf8", title = "")
htf8 = input.timeframe("180", "TF8", group = group3, inline = "htf8")
enableHtf9 = input.bool(false, group = group3, inline = "htf9", title = "")
htf9 = input.timeframe("240", "TF9", group = group3, inline = "htf9")

supply_color = input.color(color.rgb(242, 54, 69, 0.9), title = 'Зона поддержки', group = 'Настройки цвета', inline = '3')
supply_outline_color = input.color(color.rgb(242, 54, 69, 0.9), title = 'BoS', group = 'Настройки цвета', inline = '3')

demand_color = input.color(color.rgb(41, 98, 255, 0.9), title = 'Зона сопротивления', group = 'Настройки цвета', inline = '4')
demand_outline_color = input.color(color.rgb(41, 98, 255, 0.9), title = 'BoR', group = 'Настройки цвета', inline = '4')

// bos_label_color = input.color(color.white, title = 'Fracture Zone', group = 'Color Settings', inline = '5')
poi_label_color = input.color(color.white, title = 'S/R Метка зоны', group = 'Настройки цвета', inline = '7')

type zone_with_strength
    box zone
    int count = 0
    string tf

//      FUNCTION TO ADD NEW AND REMOVE LAST IN ARRAY
array_add_pop(array, new_value_to_add) =>
    array.unshift(array, new_value_to_add)
    array.pop(array)

// FUNCTION MAKE SURE SUPPLY ISNT OVERLAPPING
check_overlapping(new_poi, box_array, atr) =>

    atr_threshold = atr * 2
    okay_to_draw = true
    
    for i = 0 to array.size(box_array) - 1
        zone_with_strength zws = array.get(box_array, i)
        if not na(zws)
            box b = zws.zone
            top = box.get_top(b)
            bottom = box.get_bottom(b)
            poi = (top + bottom) / 2

            upper_boundary = poi + atr_threshold
            lower_boundary = poi - atr_threshold

            if new_poi >= lower_boundary and new_poi <= upper_boundary
                okay_to_draw := false
                break
            else 
                okay_to_draw := true

    okay_to_draw

// FUNCTION TO DRAW SUPPLY OR DEMAND ZONE
support_resistance(value_array, bn_array, box_array, label_array, count_array, box_type, atr, tf_label, barindex) =>

    atr_buffer = atr * (box_width / 10)
    box_left = array.get(bn_array, 0)
    box_right = barindex

    var float box_top = 0.00
    var float box_bottom = 0.00
    var float poi = 0.00

    if box_type == 1
        box_top := array.get(value_array, 0)
        box_bottom := box_top - atr_buffer
        poi := (box_top + box_bottom) / 2
    else if box_type == -1
        box_bottom := array.get(value_array, 0)
        box_top := box_bottom + atr_buffer
        poi := (box_top + box_bottom) / 2

    okay_to_draw = check_overlapping(poi, box_array, atr)
    // okay_to_draw = true
    //delete oldest box, and then create a new box and add it to the array
    if box_type == 1 and okay_to_draw
        zone_with_strength last = array.get(box_array, array.size(box_array) - 1)
        if not na(last)
            box.delete(last.zone)
        box b = box.new( left = box_left, top = box_top, right = box_right, bottom = box_bottom, border_color = supply_outline_color,
             bgcolor = color.new(supply_color, 70), extend = extend.none, text = tf_label, text_halign = text.align_right, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small, xloc = xloc.bar_index)
        zone_with_strength zws = zone_with_strength.new(b, 0, tf_label)
        array_add_pop(box_array, zws)

    else if box_type == -1 and okay_to_draw
        zone_with_strength last = array.get(box_array, array.size(box_array) - 1)
        if not na(last)
            box.delete(last.zone)
        box b = box.new( left = box_left, top = box_top, right = box_right, bottom = box_bottom, border_color = demand_outline_color,
             bgcolor = color.new(demand_color, 70), extend = extend.none,  text = tf_label, text_halign = text.align_right, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small, xloc = xloc.bar_index)
        zone_with_strength zws = zone_with_strength.new(b, 0, tf_label)
        array_add_pop(box_array, zws)

//      FUNCTION TO CHANGE SUPPLY/DEMAND TO A BOS IF BROKEN
sd_to_bos(box_array, bos_array, count_array, label_array, zone_type, tfclose, tfbarindex) =>

    if zone_type == 1
        for i = 0 to array.size(box_array) - 1
            zone_with_strength zws = array.get(box_array, i)
            if not na(zws)
                box b = zws.zone
                level_to_break = box.get_top(b)
                // if ta.crossover(close, level_to_break)
                if tfclose >= level_to_break
                    copied_zone = zone_with_strength.copy(zws)
                    array_add_pop(bos_array, box.copy(copied_zone.zone))
                    mid = (box.get_top(b) + box.get_bottom(b)) / 2
                    box.set_top(array.get(bos_array,0), mid)
                    box.set_bottom(array.get(bos_array,0), mid)
                    box.set_extend( array.get(bos_array,0), extend.none)
                    box.set_right( array.get(bos_array,0), tfbarindex)
                    box.set_text( array.get(bos_array,0), '' )
                    // box.set_text_color( array.get(bos_array,0), bos_label_color)
                    box.set_text_size( array.get(bos_array,0), size.small)
                    box.set_text_halign( array.get(bos_array,0), text.align_center)
                    box.set_text_valign( array.get(bos_array,0), text.align_center)
                    box.delete(b)
                    array.set(box_array, i, na)
                    // array.remove(box_array, i)
                    // box.delete(array.get(label_array, i))

    if zone_type == -1
        for i = 0 to array.size(box_array) - 1
            zone_with_strength zws = array.get(box_array, i)
            if not na(zws)
                box b = zws.zone
                level_to_break = box.get_top(b)
                // if ta.crossunder(close, level_to_break)
                if tfclose <= level_to_break
                    copied_zone = zone_with_strength.copy(zws)
                    array_add_pop(bos_array, box.copy(copied_zone.zone))
                    mid = (box.get_top(b) + box.get_bottom(b)) / 2
                    box.set_top(array.get(bos_array,0), mid)
                    box.set_bottom(array.get(bos_array,0), mid)
                    box.set_extend( array.get(bos_array,0), extend.none)
                    box.set_right( array.get(bos_array,0), tfbarindex)
                    box.set_text( array.get(bos_array,0), '' )
                    // box.set_text_color( array.get(bos_array,0), bos_label_color)
                    box.set_text_size( array.get(bos_array,0), size.small)
                    box.set_text_halign( array.get(bos_array,0), text.align_center)
                    box.set_text_valign( array.get(bos_array,0), text.align_center)
                    box.delete(b)
                    array.set(box_array, i, na)
                    // array.remove(box_array, i)
                    // box.delete(array.get(label_array, i))

//      FUNCTION MANAGE CURRENT BOXES BY CHANGING ENDPOINT
extend_box_endpoint(box_array, count_array, tfbarindex, tfhigh, tflow) =>
    for i = 0 to array.size(box_array) - 1
        zone_with_strength zws = array.get(box_array, i)
        if not na(zws)
            box b = zws.zone
            top = box.get_top(b)
            bottom = box.get_bottom(b)
            count = zws.count
            if (tfhigh[swing_length - 1] >= bottom and tfhigh[swing_length - 1] <= top) or (tflow[swing_length - 1] >= bottom and tflow[swing_length - 1] <= top)
                count := count + 1
                zws.count := count
            // count := count + 1
            // zws.count := count
            box.set_right(b, tfbarindex + 40)
            box.set_text(b, str.format("{0} / {1}", count, zws.tf))
            zws.zone := b
            array.set(box_array, i, zws)

//
//END FUNCTIONS
//
// CALCULATIONS FOR SUPPORT AND RESISTANCE
calculateSR(swing_high_values, swing_low_values, swing_high_bns, swing_low_bns, supply_zone, demand_zone, current_supply_touch_count, current_demand_touch_count, current_supply_poi, current_demand_poi, supply_bos, demand_bos, series1, series2, tf_label, tfbarindex, tfclose, atr) =>
    //      CALCULATE SWING HIGHS & SWING LOWS
    swing_high = ta.pivothigh(high, swing_length, swing_length)
    swing_low = ta.pivotlow(low, swing_length, swing_length)

    //      NEW SWING HIGH
    if not na(swing_high)

        //MANAGE SWING HIGH VALUES
        array_add_pop(swing_high_values, swing_high)
        array_add_pop(swing_high_bns, bar_index[swing_length])

        support_resistance(swing_high_values, swing_high_bns, supply_zone, current_supply_poi, current_supply_touch_count, 1, atr, tf_label, tfbarindex)

    //      NEW SWING LOW
    else if not na(swing_low)

        //MANAGE SWING LOW VALUES
        array_add_pop(swing_low_values, swing_low)
        array_add_pop(swing_low_bns, bar_index[swing_length])
        
        support_resistance(swing_low_values, swing_low_bns, demand_zone, current_demand_poi, current_demand_touch_count, -1, atr, tf_label, tfbarindex)

    sd_to_bos(supply_zone, supply_bos, current_supply_touch_count, current_supply_poi, 1, tfclose, tfbarindex)
    sd_to_bos(demand_zone, demand_bos, current_demand_touch_count, current_demand_poi, -1, tfclose, tfbarindex)

    extend_box_endpoint(supply_zone, current_supply_touch_count, tfbarindex, series1, series2)
    extend_box_endpoint(demand_zone, current_demand_touch_count, tfbarindex, series1, series2)

    //ZIG ZAG
    h = ta.highest(high, swing_length * 2 + 1)
    l = ta.lowest(low, swing_length * 2 + 1)

// f_isMin(len) =>
//     l == low[len]
// f_isMax(len) =>
//     h == high[len]
var swing_high_values = array.new_float(5,0.00)
var swing_low_values = array.new_float(5,0.00)

var swing_high_bns = array.new_int(5,0)
var swing_low_bns = array.new_int(5,0)
//      ARRAYS FOR SUPPORT / RESISTANCE POI LABELS
var current_supply_poi = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi = array.new_box(history_of_demand_to_keep, na)

var supply_zones = array.new<zone_with_strength>(history_of_demand_to_keep, na)
var demand_zones = array.new<zone_with_strength>(history_of_demand_to_keep, na)

var touches_for_supply = array.new_int(history_of_demand_to_keep, 0)
var touches_for_demand = array.new_int(history_of_demand_to_keep, 0)
//      ARRAYS FOR BOS
var supply_bos = array.new_box(5, na)
var demand_bos = array.new_box(5, na)

var swing_high_values1 = array.new_float(5,0.00)
var swing_low_values1 = array.new_float(5,0.00)

var swing_high_bns1 = array.new_int(5,0)
var swing_low_bns1 = array.new_int(5,0)
//      ARRAYS FOR SUPPORT / RESISTANCE
var supply_zones1 = array.new<zone_with_strength>(history_of_demand_to_keep, na)
var demand_zones1 = array.new<zone_with_strength>(history_of_demand_to_keep, na)

var touches_for_supply1 = array.new_int(history_of_demand_to_keep, 0)
var touches_for_demand1 = array.new_int(history_of_demand_to_keep, 0)
//      ARRAYS FOR SUPPORT / RESISTANCE POI LABELS
var current_supply_poi1 = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi1 = array.new_box(history_of_demand_to_keep, na)
//      ARRAYS FOR BOS
var supply_bos1 = array.new_box(5, na)
var demand_bos1 = array.new_box(5, na)

var swing_high_values2 = array.new_float(5,0.00)
var swing_low_values2 = array.new_float(5,0.00)

var swing_high_bns2 = array.new_int(5,0)
var swing_low_bns2 = array.new_int(5,0)
//      ARRAYS FOR SUPPORT / RESISTANCE
var supply_zones2 = array.new<zone_with_strength>(history_of_demand_to_keep, na)
var demand_zones2 = array.new<zone_with_strength>(history_of_demand_to_keep, na)

var touches_for_supply2 = array.new_int(history_of_demand_to_keep, 0)
var touches_for_demand2 = array.new_int(history_of_demand_to_keep, 0)
//      ARRAYS FOR SUPPORT / RESISTANCE POI LABELS
var current_supply_poi2 = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi2 = array.new_box(history_of_demand_to_keep, na)
//      ARRAYS FOR BOS
var supply_bos2 = array.new_box(5, na)
var demand_bos2 = array.new_box(5, na)

var swing_high_values3 = array.new_float(5,0.00)
var swing_low_values3 = array.new_float(5,0.00)

var swing_high_bns3 = array.new_int(5,0)
var swing_low_bns3 = array.new_int(5,0)
//      ARRAYS FOR SUPPORT / RESISTANCE
var supply_zones3 = array.new<zone_with_strength>(history_of_demand_to_keep, na)
var demand_zones3 = array.new<zone_with_strength>(history_of_demand_to_keep, na)

var touches_for_supply3 = array.new_int(history_of_demand_to_keep, 0)
var touches_for_demand3 = array.new_int(history_of_demand_to_keep, 0)
//      ARRAYS FOR SUPPORT / RESISTANCE POI LABELS
var current_supply_poi3 = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi3 = array.new_box(history_of_demand_to_keep, na)
//      ARRAYS FOR BOS
var supply_bos3 = array.new_box(5, na)
var demand_bos3 = array.new_box(5, na)

var swing_high_values4 = array.new_float(5,0.00)
var swing_low_values4 = array.new_float(5,0.00)

var swing_high_bns4 = array.new_int(5,0)
var swing_low_bns4 = array.new_int(5,0)
//      ARRAYS FOR SUPPORT / RESISTANCE
var supply_zones4 = array.new<zone_with_strength>(history_of_demand_to_keep, na)
var demand_zones4 = array.new<zone_with_strength>(history_of_demand_to_keep, na)

var touches_for_supply4 = array.new_int(history_of_demand_to_keep, 0)
var touches_for_demand4 = array.new_int(history_of_demand_to_keep, 0)
//      ARRAYS FOR SUPPORT / RESISTANCE POI LABELS
var current_supply_poi4 = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi4 = array.new_box(history_of_demand_to_keep, na)
//      ARRAYS FOR BOS
var supply_bos4 = array.new_box(5, na)
var demand_bos4 = array.new_box(5, na)

var swing_high_values5 = array.new_float(5,0.00)
var swing_low_values5 = array.new_float(5,0.00)

var swing_high_bns5 = array.new_int(5,0)
var swing_low_bns5 = array.new_int(5,0)
//      ARRAYS FOR SUPPORT / RESISTANCE
var supply_zones5 = array.new<zone_with_strength>(history_of_demand_to_keep, na)
var demand_zones5 = array.new<zone_with_strength>(history_of_demand_to_keep, na)

var touches_for_supply5 = array.new_int(history_of_demand_to_keep, 0)
var touches_for_demand5 = array.new_int(history_of_demand_to_keep, 0)
//      ARRAYS FOR SUPPORT / RESISTANCE POI LABELS
var current_supply_poi5 = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi5 = array.new_box(history_of_demand_to_keep, na)
//      ARRAYS FOR BOS
var supply_bos5 = array.new_box(5, na)
var demand_bos5 = array.new_box(5, na)

var swing_high_values6 = array.new_float(5,0.00)
var swing_low_values6 = array.new_float(5,0.00)

var swing_high_bns6 = array.new_int(5,0)
var swing_low_bns6 = array.new_int(5,0)
//      ARRAYS FOR SUPPORT / RESISTANCE
var supply_zones6 = array.new<zone_with_strength>(history_of_demand_to_keep, na)
var demand_zones6 = array.new<zone_with_strength>(history_of_demand_to_keep, na)

var touches_for_supply6 = array.new_int(history_of_demand_to_keep, 0)
var touches_for_demand6 = array.new_int(history_of_demand_to_keep, 0)
//      ARRAYS FOR SUPPORT / RESISTANCE POI LABELS
var current_supply_poi6 = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi6 = array.new_box(history_of_demand_to_keep, na)
//      ARRAYS FOR BOS
var supply_bos6 = array.new_box(5, na)
var demand_bos6 = array.new_box(5, na)

var swing_high_values7 = array.new_float(5,0.00)
var swing_low_values7 = array.new_float(5,0.00)

var swing_high_bns7 = array.new_int(5,0)
var swing_low_bns7 = array.new_int(5,0)
//      ARRAYS FOR SUPPORT / RESISTANCE
var supply_zones7 = array.new<zone_with_strength>(history_of_demand_to_keep, na)
var demand_zones7 = array.new<zone_with_strength>(history_of_demand_to_keep, na)

var touches_for_supply7 = array.new_int(history_of_demand_to_keep, 0)
var touches_for_demand7 = array.new_int(history_of_demand_to_keep, 0)
//      ARRAYS FOR SUPPORT / RESISTANCE POI LABELS
var current_supply_poi7 = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi7 = array.new_box(history_of_demand_to_keep, na)
//      ARRAYS FOR BOS
var supply_bos7 = array.new_box(5, na)
var demand_bos7 = array.new_box(5, na)

var swing_high_values8 = array.new_float(5,0.00)
var swing_low_values8 = array.new_float(5,0.00)

var swing_high_bns8 = array.new_int(5,0)
var swing_low_bns8 = array.new_int(5,0)
//      ARRAYS FOR SUPPORT / RESISTANCE
var supply_zones8 = array.new<zone_with_strength>(history_of_demand_to_keep, na)
var demand_zones8 = array.new<zone_with_strength>(history_of_demand_to_keep, na)

var touches_for_supply8 = array.new_int(history_of_demand_to_keep, 0)
var touches_for_demand8 = array.new_int(history_of_demand_to_keep, 0)
//      ARRAYS FOR SUPPORT / RESISTANCE POI LABELS
var current_supply_poi8 = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi8 = array.new_box(history_of_demand_to_keep, na)
//      ARRAYS FOR BOS
var supply_bos8 = array.new_box(5, na)
var demand_bos8 = array.new_box(5, na)

var swing_high_values9 = array.new_float(5,0.00)
var swing_low_values9 = array.new_float(5,0.00)

var swing_high_bns9 = array.new_int(5,0)
var swing_low_bns9 = array.new_int(5,0)
//      ARRAYS FOR SUPPORT / RESISTANCE
var supply_zones9 = array.new<zone_with_strength>(history_of_demand_to_keep, na)
var demand_zones9 = array.new<zone_with_strength>(history_of_demand_to_keep, na)

var touches_for_supply9 = array.new_int(history_of_demand_to_keep, 0)
var touches_for_demand9 = array.new_int(history_of_demand_to_keep, 0)
//      ARRAYS FOR SUPPORT / RESISTANCE POI LABELS
var current_supply_poi9 = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi9 = array.new_box(history_of_demand_to_keep, na)
//      ARRAYS FOR BOS
var supply_bos9 = array.new_box(5, na)
var demand_bos9 = array.new_box(5, na)

if show_current_sr
    cur_tf_label = timeframe.isintraday ? str.tostring(timeframe.in_seconds() / 60, "#.## MIN") : timeframe.period
    calculateSR(swing_high_values, swing_low_values, swing_high_bns, swing_low_bns, supply_zones, demand_zones, touches_for_supply, touches_for_demand, current_supply_poi, current_demand_poi, supply_bos, demand_bos, high, low, cur_tf_label, bar_index, close, ta.atr(50))

// SUPPORT / RESISTANCE FOR HTF1
[high1, low1, close1, barindex1, atr1, timeframe1] = request.security(syminfo.tickerid, htf1, [high, low, close, bar_index, ta.atr(50), timeframe.isintraday ? str.tostring(timeframe.in_seconds() / 60, "#.## MIN") : timeframe.period])
// SUPPORT / RESISTANCE FOR HTF2
[high2, low2, close2, barindex2, atr2, timeframe2] = request.security(syminfo.tickerid, htf2, [high, low, close, bar_index, ta.atr(50), timeframe.isintraday ? str.tostring(timeframe.in_seconds() / 60, "#.## MIN") : timeframe.period])
// SUPPORT / RESISTANCE FOR HTF3
[high3, low3, close3, barindex3, atr3, timeframe3] = request.security(syminfo.tickerid, htf3, [high, low, close, bar_index, ta.atr(50), timeframe.isintraday ? str.tostring(timeframe.in_seconds() / 60, "#.## MIN") : timeframe.period])
// SUPPORT / RESISTANCE FOR HTF4
[high4, low4, close4, barindex4, atr4, timeframe4] = request.security(syminfo.tickerid, htf4, [high, low, close, bar_index, ta.atr(50), timeframe.isintraday ? str.tostring(timeframe.in_seconds() / 60, "#.## MIN") : timeframe.period])
// SUPPORT / RESISTANCE FOR HTF5
[high5, low5, close5, barindex5, atr5, timeframe5] = request.security(syminfo.tickerid, htf5, [high, low, close, bar_index, ta.atr(50), timeframe.isintraday ? str.tostring(timeframe.in_seconds() / 60, "#.## MIN") : timeframe.period])
// SUPPORT / RESISTANCE FOR HTF6
[high6, low6, close6, barindex6, atr6, timeframe6] = request.security(syminfo.tickerid, htf6, [high, low, close, bar_index, ta.atr(50), timeframe.isintraday ? str.tostring(timeframe.in_seconds() / 60, "#.## MIN") : timeframe.period])
// SUPPORT / RESISTANCE FOR HTF7
[high7, low7, close7, barindex7, atr7, timeframe7] = request.security(syminfo.tickerid, htf7, [high, low, close, bar_index, ta.atr(50), timeframe.isintraday ? str.tostring(timeframe.in_seconds() / 60, "#.## MIN") : timeframe.period])
// SUPPORT / RESISTANCE FOR HTF8
[high8, low8, close8, barindex8, atr8, timeframe8] = request.security(syminfo.tickerid, htf8, [high, low, close, bar_index, ta.atr(50), timeframe.isintraday ? str.tostring(timeframe.in_seconds() / 60, "#.## MIN") : timeframe.period])
// SUPPORT / RESISTANCE FOR HTF9
[high9, low9, close9, barindex9, atr9, timeframe9] = request.security(syminfo.tickerid, htf9, [high, low, close, bar_index, ta.atr(50), timeframe.isintraday ? str.tostring(timeframe.in_seconds() / 60, "#.## MIN") : timeframe.period])

if enableHtf1 and htf1 != ""
    calculateSR(swing_high_values1, swing_low_values1, swing_high_bns1, swing_low_bns1, supply_zones1, demand_zones1, touches_for_supply1, touches_for_demand1, current_supply_poi1, current_demand_poi1, supply_bos1, demand_bos1, high, low, timeframe1, bar_index, close1, atr1)

if enableHtf2 and htf2 != ""
    calculateSR(swing_high_values2, swing_low_values2, swing_high_bns2, swing_low_bns2, supply_zones2, demand_zones2, touches_for_supply2, touches_for_demand2, current_supply_poi2, current_demand_poi2, supply_bos, demand_bos2, high, low, timeframe2, bar_index, close2, atr2)

if enableHtf3 and htf3 != ""
    calculateSR(swing_high_values3, swing_low_values3, swing_high_bns3, swing_low_bns3, supply_zones3, demand_zones3, touches_for_supply3, touches_for_demand3, current_supply_poi3, current_demand_poi3, supply_bos3, demand_bos3, high, low, timeframe3, bar_index, close3, atr3)

if enableHtf4 and htf4 != ""
    calculateSR(swing_high_values4, swing_low_values4, swing_high_bns4, swing_low_bns4, supply_zones4, demand_zones4, touches_for_supply4, touches_for_demand4, current_supply_poi4, current_demand_poi4, supply_bos4, demand_bos4, high, low, timeframe4, bar_index, close4, atr4)

if enableHtf5 and htf5 != ""
    calculateSR(swing_high_values5, swing_low_values5, swing_high_bns5, swing_low_bns5, supply_zones5, demand_zones5, touches_for_supply5, touches_for_demand5, current_supply_poi5, current_demand_poi5, supply_bos5, demand_bos5, high, low, timeframe5, bar_index, close5, atr5)

if enableHtf6 and htf6 != ""
    calculateSR(swing_high_values6, swing_low_values6, swing_high_bns6, swing_low_bns6, supply_zones6, demand_zones6, touches_for_supply6, touches_for_demand6, current_supply_poi6, current_demand_poi6, supply_bos6, demand_bos6, high, low, timeframe6, bar_index, close6, atr6)

if enableHtf7 and htf7 != ""
    calculateSR(swing_high_values7, swing_low_values7, swing_high_bns7, swing_low_bns7, supply_zones7, demand_zones7, touches_for_supply7, touches_for_demand7, current_supply_poi7, current_demand_poi7, supply_bos7, demand_bos7, high, low, timeframe7, bar_index, close7, atr7)

if enableHtf8 and htf8 != ""
    calculateSR(swing_high_values8, swing_low_values8, swing_high_bns8, swing_low_bns8, supply_zones8, demand_zones8, touches_for_supply8, touches_for_demand8, current_supply_poi8, current_demand_poi8, supply_bos8, demand_bos8, high, low, timeframe8, bar_index, close8, atr8)

if enableHtf9 and htf9 != ""
    calculateSR(swing_high_values9, swing_low_values9, swing_high_bns9, swing_low_bns9, supply_zones9, demand_zones9, touches_for_supply9, touches_for_demand9, current_supply_poi9, current_demand_poi9, supply_bos9, demand_bos9, high, low, timeframe9, bar_index, close9, atr9)

var my_table_logo = table.new(position.top_right, 1, 1)
if barstate.islast
    table.cell(my_table_logo, 0, 0, 'DM', text_size=size.large, text_color=#00897b)