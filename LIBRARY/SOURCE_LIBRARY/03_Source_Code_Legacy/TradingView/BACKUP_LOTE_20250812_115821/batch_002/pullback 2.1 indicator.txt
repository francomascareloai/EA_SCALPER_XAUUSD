//Professorwiz Pullback Indicator
//@version=5
indicator("ProfessorWiz pullback 2.1",overlay=true,max_lines_count=500)

//ob
_v = input.string("1.0.2", title="Version", options=["1.0.2"], group="Sonarlab.io", tooltip="This is a free script based on our premium Smart Money Concepts (SMC) indicator. Get a free trial of our SMC indicator by visiting our website.\nhttps://www.sonarlab.io")
sens = input.int(28, minval=1, title='Sensitivity', group='Order Block', tooltip='Lower the sensitivity to show more order blocks. A higher sensitivity will show less order blocks.')
sens /= 100

// OB
OBMitigationType = input.string("Close", title="OB Mitigation Type", options=["Close", "Wick"], group="Order Block", tooltip="Choose how Order Blocks are mitigated")
OBBullMitigation = OBMitigationType=="Close" ? close[1] : low
OBBearMitigation = OBMitigationType=="Close" ? close[1] : high

//OB Colors
col_bullish = input.color(color.rgb(43, 253, 6, 48), title="Bullish OB Border", inline="a", group="Order Block")
col_bullish_ob = input.color(color.new(#0beb3f, 84), title="Background", inline="a", group="Order Block")

col_bearish = input.color(color.rgb(250, 2, 39, 54), title="Bearish OB Border", inline="b", group="Order Block")
col_bearish_ob = input.color(color.new(#d35050, 85), title="Background", inline="b", group="Order Block")

// Alerts
BUY_alert = input.bool(title='BUY Signal', defval=true, group='Alerts', tooltip='An alert will be sent when price goes below the top of a bullish order block.')
SELL_alert = input.bool(title='SELL Signal', defval=true, group='Alerts', tooltip='An alert will be sent when price goes above the bottom of a bearish order block.')

// Delacring Variables
bool ob_created = false
bool ob_created_bull = false
var int cross_index = na

// Declaring Box Arrays
var box drawlongBox = na
var longBoxes = array.new_box()
var box drawShortBox = na
var shortBoxes = array.new_box()

// Custom Rate of Change (ROC) calculation. This is to calculate high momentum moves in the market.
pc = (open - open[4]) / open[4] * 100

// If the ROC crossover our Sensitivty input - Then create an Order Block
// Sensitivty is negative as this is a Bearish OB
if ta.crossunder(pc, -sens)
    ob_created := true
    cross_index := bar_index
    cross_index

// If the ROC crossover our Sensitivty input - Then create an Order Block
if ta.crossover(pc, sens)
    ob_created_bull := true
    cross_index := bar_index
    cross_index

// -------------------------------
// Bearish OB Creation
// -------------------------------
// Check if we should create a OB, Also check if we haven't created an OB in the last 5 candles.
if ob_created and cross_index - cross_index[1] > 5
    float last_green = 0
    float highest = 0
    // Loop through the most recent candles and find the first GREEN (Bullish) candle. We will place our OB here.
    for i = 4 to 15 by 1
        if close[i] > open[i]
            last_green := i
            break
    // Draw our OB on that candle - then push the box into our box arrays.
    drawShortBox := box.new(left=bar_index[last_green], top=high[last_green], bottom=low[last_green], right=bar_index[last_green], bgcolor=col_bearish_ob, border_color=col_bearish, extend=extend.right)
    array.push(shortBoxes, drawShortBox)

// -------------------------------
// Bullish OB Creation
// -------------------------------
// Check if we should create a OB, Also check if we haven't created an OB in the last 5 candles.
if ob_created_bull and cross_index - cross_index[1] > 5
    float last_red = 0
    float highest = 0
    // Loop through the most recent candles and find the first RED (Bearish) candle. We will place our OB here.
    for i = 4 to 15 by 1
        if close[i] < open[i]
            last_red := i
            break
    // Draw our OB on that candle - then push the box into our box arrays.
    drawlongBox := box.new(left=bar_index[last_red], top=high[last_red], bottom=low[last_red], right=bar_index[last_red], bgcolor=col_bullish_ob, border_color=col_bullish, extend=extend.right)
    array.push(longBoxes, drawlongBox)

// ----------------- Bearish Order Block -------------------
// Clean up_1 OB boxes and place alerts
if array.size(shortBoxes) > 0
    for i = array.size(shortBoxes) - 1 to 0 by 1
        sbox = array.get(shortBoxes, i)
        top = box.get_top(sbox)
        bot = box.get_bottom(sbox)
        // If the two last closes are above the high of the bearish OB - Remove the OB
        if OBBearMitigation > top
            array.remove(shortBoxes, i)
            box.delete(sbox)
        // Alerts
        if high > bot and SELL_alert
            alert('Price inside Bearish OB', alert.freq_once_per_bar)

// ----------------- Bullish Clean Up_1 -------------------
// Clean up_1 OB boxes and place alerts
if array.size(longBoxes) > 0
    for i = array.size(longBoxes) - 1 to 0 by 1
        sbox = array.get(longBoxes, i)
        bot = box.get_bottom(sbox)
        top = box.get_top(sbox)
        // If the two last closes are below the low of the bullish OB - Remove the OB
        if OBBullMitigation < bot
            array.remove(longBoxes, i)
            box.delete(sbox)
        // Alerts
        if low < top and BUY_alert
            alert('Price inside Bullish OB', alert.freq_once_per_bar)
import loxx/loxxexpandedsourcetypes/4

greencolor = #2DD204
redcolor = #D2042D 

gkyzvol(int per)=>
    float gzkylog = math.log(open / nz(close[1]))
    float pklog = math.log(high / low)
    float gklog = math.log(close / open)
    float garmult = (2 * math.log(2) - 1)
    
    float gkyzsum = 1 / per * math.sum(math.pow(gzkylog, 2), per)
    float parkinsonsum = 1 / (2 * per) * math.sum(math.pow(pklog, 2), per)
    float garmansum = garmult / per * math.sum(math.pow(gklog, 2), per)
    
    float sum = gkyzsum + parkinsonsum - garmansum
    float devpercent = math.sqrt(sum)  
    devpercent

gkyzFilter(float src, int len, float filter)=>
    float price = src
    float filtdev = filter * gkyzvol(len) * src
    price := math.abs(price - nz(price[1])) < filtdev ? nz(price[1]) : price
    price

ema(float src, float alpha)=>
    float out = src
    out := nz(out[1]) + alpha * (src - nz(out[1]))
    out 

demaAlpha(float src, float alpha)=>
    float e1 = ema(src, alpha)
    float e2 = ema(e1, alpha)
    float out = 2 * e1 - e2
    out

smthtype = input.string("Kaufman", "Heikin-Ashi Better Caculation Type", options = ["AMA", "T3", "Kaufman"], group = "Source Settings")

//
// User inputs
showTomorrowCPR = input(title='Show tomorrow\'s CPR', defval=false)
showHistoricalCPR = input(title='Show historical CPR', defval=false)
showR3S3 = input(title='Show R3 & S3', defval=false)
showPDHL = input(title='Show previous day\'s High & Low', defval=true)
showPDC = input(title='Show previous day\'s Close', defval=false)

// Defaults
// CPR Colors
cprColor = color.purple
rColor = color.red
sColor = color.green
cColor = color.black

// Line style & Transparency
lStyle = plot.style_line
lTransp = 35

//Fill Transparency
fTransp = 95

// Global Variables & Flags
// TODO : Up_1date the No of Holidays
noOfHolidays = 12

// Global Functions
// TODO : Up_1date the list of Holiday here in format YYYY, MM, DD, 09, 15 
// **09, 15 are session start hour & minutes
IsHoliday(_date) =>
    iff_1 = _date == timestamp(2020, 12, 25, 09, 15) ? true : false
    iff_2 = _date == timestamp(2020, 11, 30, 09, 15) ? true : iff_1
    iff_3 = _date == timestamp(2020, 11, 16, 09, 15) ? true : iff_2
    iff_4 = _date == timestamp(2020, 10, 02, 09, 15) ? true : iff_3
    iff_5 = _date == timestamp(2020, 05, 25, 09, 15) ? true : iff_4
    iff_6 = _date == timestamp(2020, 05, 01, 09, 15) ? true : iff_5
    iff_7 = _date == timestamp(2020, 04, 14, 09, 15) ? true : iff_6
    iff_8 = _date == timestamp(2020, 04, 10, 09, 15) ? true : iff_7
    iff_9 = _date == timestamp(2020, 04, 06, 09, 15) ? true : iff_8
    iff_10 = _date == timestamp(2020, 04, 02, 09, 15) ? true : iff_9
    iff_11 = _date == timestamp(2020, 03, 10, 09, 15) ? true : iff_10
    _date == timestamp(2020, 02, 21, 09, 15) ? true : iff_11

// Note: Week of Sunday=1...Saturday=7
IsWeekend(_date) =>
    dayofweek(_date) == 7 or dayofweek(_date) == 1

// Skip Weekend
SkipWeekend(_date) =>
    _d = dayofweek(_date)
    _mul = _d == 6 ? 3 : _d == 7 ? 2 : 1

    _date + _mul * 86400000

// Get Next Working Day
GetNextWorkingDay(_date) =>
    _dt = SkipWeekend(_date)

    for i = 1 to noOfHolidays by 1
        if IsHoliday(_dt)
            _dt := SkipWeekend(_dt)
            continue
        else
            break

    _dt

// Today's Session Start timestamp
y = year(timenow)
m = month(timenow)
d = dayofmonth(timenow)

// Start & End time for Today's CPR
start = timestamp(y, m, d, 09, 15)
end = start + 86400000

// Plot Today's CPR
shouldPlotToday = timenow > start

tom_start = start
tom_end = end

// Start & End time for Tomorrow's CPR
if shouldPlotToday
    tom_start := GetNextWorkingDay(start)
    tom_end := tom_start + 86400000
    tom_end

// Get series
getSeries(e, timeFrame) =>
    request.security(syminfo.tickerid, 'D', e, lookahead=barmerge.lookahead_on)

// Calculate Today's CPR
//Get High, Low and Close
H = getSeries(high[1], 'D')
L = getSeries(low[1], 'D')
C = getSeries(close[1], 'D')

// Pivot Range
P = (H + L + C) / 3
TC = (H + L) / 2
BC = P - TC + P

// Resistance Levels
R3 = H + 2 * (P - L)
R2 = P + H - L
R1 = P * 2 - L

// Sup_1port Levels
S1 = P * 2 - H
S2 = P - (H - L)
S3 = L - 2 * (H - P)

// Plot Today's CPR
if not IsHoliday(start) and not IsWeekend(start) and shouldPlotToday
    if showR3S3
        _r3 = line.new(start, R3, end, R3, xloc.bar_time, color=color.new(rColor, lTransp))
        line.delete(_r3[1])
    _r2 = line.new(start, R2, end, R2, xloc.bar_time, color=color.new(rColor, lTransp))
    line.delete(_r2[1])
    _r1 = line.new(start, R1, end, R1, xloc.bar_time, color=color.new(rColor, lTransp))
    line.delete(_r1[1])

    _tc = line.new(start, TC, end, TC, xloc.bar_time, color=color.new(cprColor, lTransp))
    line.delete(_tc[1])
    _p = line.new(start, P, end, P, xloc.bar_time, color=color.new(cprColor, lTransp))
    line.delete(_p[1])
    _bc = line.new(start, BC, end, BC, xloc.bar_time, color=color.new(cprColor, lTransp))
    line.delete(_bc[1])

    _s1 = line.new(start, S1, end, S1, xloc.bar_time, color=color.new(sColor, lTransp))
    line.delete(_s1[1])
    _s2 = line.new(start, S2, end, S2, xloc.bar_time, color=color.new(sColor, lTransp))
    line.delete(_s2[1])
    if showR3S3
        _s3 = line.new(start, S3, end, S3, xloc.bar_time, color=color.new(sColor, lTransp))
        line.delete(_s3[1])
    if showPDHL
        _pdh = line.new(start, H, end, H, xloc.bar_time, color=color.new(rColor, lTransp), style=line.style_dotted, width=2)
        line.delete(_pdh[1])
        _pdl = line.new(start, L, end, L, xloc.bar_time, color=color.new(sColor, lTransp), style=line.style_dotted, width=2)
        line.delete(_pdl[1])
    if showPDC
        _pdc = line.new(start, C, end, C, xloc.bar_time, color=color.new(cColor, lTransp), style=line.style_dotted, width=2)
        line.delete(_pdc[1])

// Plot Today's Labels
if not IsHoliday(start) and not IsWeekend(start) and shouldPlotToday
    if showR3S3
        l_r3 = label.new(start, R3, text='R3', xloc=xloc.bar_time, textcolor=rColor, style=label.style_none)
        label.delete(l_r3[1])
    l_r2 = label.new(start, R2, text='R2', xloc=xloc.bar_time, textcolor=rColor, style=label.style_none)
    label.delete(l_r2[1])
    l_r1 = label.new(start, R1, text='R1', xloc=xloc.bar_time, textcolor=rColor, style=label.style_none)
    label.delete(l_r1[1])

    l_tc = label.new(start, TC, text='TC', xloc=xloc.bar_time, textcolor=cprColor, style=label.style_none)
    label.delete(l_tc[1])
    l_p = label.new(start, P, text='P', xloc=xloc.bar_time, textcolor=cprColor, style=label.style_none)
    label.delete(l_p[1])
    l_bc = label.new(start, BC, text='BC', xloc=xloc.bar_time, textcolor=cprColor, style=label.style_none)
    label.delete(l_bc[1])

    l_s1 = label.new(start, S1, text='S1', xloc=xloc.bar_time, textcolor=sColor, style=label.style_none)
    label.delete(l_s1[1])
    l_s2 = label.new(start, S2, text='S2', xloc=xloc.bar_time, textcolor=sColor, style=label.style_none)
    label.delete(l_s2[1])
    if showR3S3
        l_s3 = label.new(start, S3, text='S3', xloc=xloc.bar_time, textcolor=sColor, style=label.style_none)
        label.delete(l_s3[1])
    if showPDHL
        l_pdh = label.new(start, H, text='PD High', xloc=xloc.bar_time, textcolor=rColor, style=label.style_none)
        label.delete(l_pdh[1])
        l_pdl = label.new(start, L, text='PD Low', xloc=xloc.bar_time, textcolor=sColor, style=label.style_none)
        label.delete(l_pdl[1])
    if showPDC
        l_pdc = label.new(start, C, text='PD Close', xloc=xloc.bar_time, textcolor=cColor, style=label.style_none)
        label.delete(l_pdc[1])

// Calculate Tomorrow's CPR
// Get High, Low and Close
tH = getSeries(high, 'D')
tL = getSeries(low, 'D')
tC = getSeries(close, 'D')

// Pivot Range
tP = (tH + tL + tC) / 3
tTC = (tH + tL) / 2
tBC = tP - tTC + tP

// Resistance Levels
tR3 = tH + 2 * (tP - tL)
tR2 = tP + tH - tL
tR1 = tP * 2 - tL

// Sup_1port Levels
tS1 = tP * 2 - tH
tS2 = tP - (tH - tL)
tS3 = tL - 2 * (tH - tP)

// Plot Tomorrow's CPR
if showTomorrowCPR
    if showR3S3
        _t_r3 = line.new(tom_start, tR3, tom_end, tR3, xloc.bar_time, color=color.new(rColor, lTransp))
        line.delete(_t_r3[1])
    _t_r2 = line.new(tom_start, tR2, tom_end, tR2, xloc.bar_time, color=color.new(rColor, lTransp))
    line.delete(_t_r2[1])
    _t_r1 = line.new(tom_start, tR1, tom_end, tR1, xloc.bar_time, color=color.new(rColor, lTransp))
    line.delete(_t_r1[1])

    _t_tc = line.new(tom_start, tTC, tom_end, tTC, xloc.bar_time, color=color.new(cprColor, lTransp))
    line.delete(_t_tc[1])
    _t_p = line.new(tom_start, tP, tom_end, tP, xloc.bar_time, color=color.new(cprColor, lTransp))
    line.delete(_t_p[1])
    _t_bc = line.new(tom_start, tBC, tom_end, tBC, xloc.bar_time, color=color.new(cprColor, lTransp))
    line.delete(_t_bc[1])

    _t_s1 = line.new(tom_start, tS1, tom_end, tS1, xloc.bar_time, color=color.new(sColor, lTransp))
    line.delete(_t_s1[1])
    _t_s2 = line.new(tom_start, tS2, tom_end, tS2, xloc.bar_time, color=color.new(sColor, lTransp))
    line.delete(_t_s2[1])
    if showR3S3
        _t_s3 = line.new(tom_start, tS3, tom_end, tS3, xloc.bar_time, color=color.new(sColor, lTransp))
        line.delete(_t_s3[1])
    if showPDHL
        _pdth = line.new(tom_start, tH, tom_end, tH, xloc.bar_time, color=color.new(rColor, lTransp), style=line.style_dotted, width=2)
        line.delete(_pdth[1])
        _pdtl = line.new(tom_start, tL, tom_end, tL, xloc.bar_time, color=color.new(sColor, lTransp), style=line.style_dotted, width=2)
        line.delete(_pdtl[1])
    if showPDC
        _pdtc = line.new(tom_start, tC, tom_end, tC, xloc.bar_time, color=color.new(cColor, lTransp), style=line.style_dotted, width=2)
        line.delete(_pdtc[1])

// Plot Tomorrow's Labels
if showTomorrowCPR
    if showR3S3
        l_t_r3 = label.new(tom_start, tR3, text='R3', xloc=xloc.bar_time, textcolor=rColor, style=label.style_none)
        label.delete(l_t_r3[1])
    l_t_r2 = label.new(tom_start, tR2, text='R2', xloc=xloc.bar_time, textcolor=rColor, style=label.style_none)
    label.delete(l_t_r2[1])
    l_t_r1 = label.new(tom_start, tR1, text='R1', xloc=xloc.bar_time, textcolor=rColor, style=label.style_none)
    label.delete(l_t_r1[1])

    l_t_tc = label.new(tom_start, tTC, text='TC', xloc=xloc.bar_time, textcolor=cprColor, style=label.style_none)
    label.delete(l_t_tc[1])
    l_t_p = label.new(tom_start, tP, text='P', xloc=xloc.bar_time, textcolor=cprColor, style=label.style_none)
    label.delete(l_t_p[1])
    l_t_bc = label.new(tom_start, tBC, text='BC', xloc=xloc.bar_time, textcolor=cprColor, style=label.style_none)
    label.delete(l_t_bc[1])

    l_t_s1 = label.new(tom_start, tS1, text='S1', xloc=xloc.bar_time, textcolor=sColor, style=label.style_none)
    label.delete(l_t_s1[1])
    l_t_s2 = label.new(tom_start, tS2, text='S2', xloc=xloc.bar_time, textcolor=sColor, style=label.style_none)
    label.delete(l_t_s2[1])
    if showR3S3
        l_t_s3 = label.new(tom_start, tS3, text='S3', xloc=xloc.bar_time, textcolor=sColor, style=label.style_none)
        label.delete(l_t_s3[1])
    if showPDHL
        l_pdth = label.new(tom_start, tH, text='PD High', xloc=xloc.bar_time, textcolor=rColor, style=label.style_none)
        label.delete(l_pdth[1])
        l_pdtl = label.new(tom_start, tL, text='PD Low', xloc=xloc.bar_time, textcolor=sColor, style=label.style_none)
        label.delete(l_pdtl[1])
    if showPDC
        l_pdtc = label.new(tom_start, tC, text='PD Close', xloc=xloc.bar_time, textcolor=cColor, style=label.style_none)
        label.delete(l_pdtc[1])



//halftrend

amplitude = input(title='Amplitude', defval=1)
channelDeviation = input(title='Channel Deviation', defval=0)
showArrows = input(title='Show Arrows', defval=true)
showChannels = input(title='Show Channels', defval=true)

var int trend = 0
var int nextTrend = 0
var float maxLowPrice = nz(low[1], low)
var float minHighPrice = nz(high[1], high)

var float up_1 = 0.0
var float down = 0.0
float atrHigh = 0.0
float atrLow = 0.0
float arrowUp_1 = na
float arrowDown = na

atr_2 = ta.atr(100) / 2
dev = channelDeviation * atr_2

highPrice = high[math.abs(ta.highestbars(amplitude))]
lowPrice = low[math.abs(ta.lowestbars(amplitude))]
highma = ta.sma(high, amplitude)
lowma = ta.sma(low, amplitude)

if nextTrend == 1
    maxLowPrice := math.max(lowPrice, maxLowPrice)

    if highma < maxLowPrice and close < nz(low[1], low)
        trend := 1
        nextTrend := 0
        minHighPrice := highPrice
        minHighPrice
else
    minHighPrice := math.min(highPrice, minHighPrice)

    if lowma > minHighPrice and close > nz(high[1], high)
        trend := 0
        nextTrend := 1
        maxLowPrice := lowPrice
        maxLowPrice

if trend == 0
    if not na(trend[1]) and trend[1] != 0
        up_1 := na(down[1]) ? down : down[1]
        arrowUp_1 := up_1 - atr_2
        arrowUp_1
    else
        up_1 := na(up_1[1]) ? maxLowPrice : math.max(maxLowPrice, up_1[1])
        up_1
    atrHigh := up_1 + dev
    atrLow := up_1 - dev
    atrLow
else
    if not na(trend[1]) and trend[1] != 1
        down := na(up_1[1]) ? up_1 : up_1[1]
        arrowDown := down + atr_2
        arrowDown
    else
        down := na(down[1]) ? minHighPrice : math.min(minHighPrice, down[1])
        down
    atrHigh := down + dev
    atrLow := down - dev
    atrLow

ht = trend == 0 ? up_1 : down

var color BUYColor = color.blue
var color SELLColor = color.red

htColor = trend == 0 ? BUYColor : SELLColor
htPlot = plot(ht, title='HalfTrend', linewidth=2, color=htColor)



buy = not na(arrowUp_1) and trend == 0 and trend[1] == 1
sell = not na(arrowDown) and trend == 1 and trend[1] == 0





///
satting1 = input(defval=16)
src = input(close, title='Source')
setting2 = input.float(step=0.1, defval=2.0)
changeATR = input(title='Change ATR Calculation Method ?', defval=true)
showsignals = input(title='Show BUY/SELL Signals ?', defval=true)
highlighting = input(title='Highlighter On/Off ?', defval=true)
atr2 = ta.sma(ta.tr, satting1)
atr = changeATR ? ta.atr(satting1) : atr2
up = src - setting2 * atr
up1 = nz(up[1], up)
up := close[1] > up1 ? math.max(up, up1) : up
dn = src + setting2 * atr
dn1 = nz(dn[1], dn)
dn := close[1] < dn1 ? math.min(dn, dn1) : dn
trend44 = 1
trend44 := nz(trend44[1], trend44)
trend44 := trend44 == -1 and close > dn1 ? 1 : trend44 == 1 and close < up1 ? -1 : trend44

longCondition2 = trend44 == 1 and trend44[1] == -1

//


plotarrow(trend44 == 1 and trend44[1] == -1 ? trend44 : na, title='Up Entry Arrow', colorup=color.new(color.lime, 0), maxheight=60, minheight=50)
plotarrow(trend44 == -1 and trend44[1] == 1 ? trend44 : na, title='Down Entry Arrow', colordown=color.new(color.red, 0), maxheight=60, minheight=50)

//
plotshape(longCondition2 and showsignals ? up : na, title='BUY', text='BUY', location=location.belowbar, style=shape.labelup, size=size.tiny, color=color.new(color.lime, 0), textcolor=color.new(color.white, 0))
shortCondition2 = trend44 == -1 and trend44[1] == 1

plotshape(shortCondition2 and showsignals ? dn : na, title='SELL', text='SELL', location=location.abovebar, style=shape.labeldown, size=size.tiny, color=color.new(color.red, 0), textcolor=color.new(color.white, 0))
mPlot = plot(ohlc4, title='', style=plot.style_circles, linewidth=0)
///// -- Table Inputs
max    = input.int(120,'Maximum Length',minval=2)
min    = input.int(10 ,'Minimum Length',minval=2)


text_size = input.session('Tiny',"Dashboard Size"  ,options=["Tiny","Small","Normal","Large"]  ,group='Style Settings')

cell_up = input(#0df515,'Bullish Cell Color'  ,group='Style Settings')
cell_dn = input(#f51414,'Bearish Cell Color'  ,group='Style Settings')
cell_netural = input(color.rgb(134, 132, 120),'Bearish Cell Color'  ,group='Style Settings')
txt_col = input(color.rgb(180, 178, 175),'Text/Frame Color'  ,group='Style Settings')
cell_transp = input.int(50,'Cell Transparency'  ,minval=0  ,maxval=100  ,group='Style Settings')
  
//----



// lable 
//Lable on screen
var tLog = table.new(position = position.bottom_right, rows = 1, columns = 2, bgcolor = color.rgb(250, 209, 6, 60), border_width=1)
table.cell(tLog, row = 0, column = 0, text = "ProfessorWIZ", text_size = size.tiny ,text_color = color.rgb(0, 0, 0))
table.cell_set_text(tLog, row = 0, column = 0, text = "ProfessorWIZ")


//rsi++2
//

var bool bcn = false
var bool scn = false
var int hma1 = 10
var int hma2 = 20
var int hma3 = 100

t_type = input.string("Scalping","Trade Type",options = ["Scalping","Intraday"])

if t_type == "Scalping"
    hma1 := 10
    hma2 := 20
    hma3 := 100
if t_type == "Intraday"
    hma1 := 20
    hma2 := 50
    hma3 := 100

ma1 = ta.hma(close,hma1)
ma2 = ta.hma(close,hma2)
ma3 = ta.hma(close,hma3)
l_avg = math.avg(ma1,ma2,ma3)
l_col = color.gray


//---------------------------- Buy Condition ----------------------------//

if ma3 < ma2 and ma3 < ma1 and ma1 > ma2
    bcn := true
    l_col := color.rgb(7, 249, 15)
    

//---------------------------- Sell Condition ----------------------------//

if ma3 > ma2 and ma3 > ma1 and ma2 > ma1
    scn := true
    l_col :=color.rgb(247, 8, 8)
    


//
// Break Outs

longCond3= ma3 < ma2 and ma3 < ma1 and ma1 > ma2
shortCond3= ma3 > ma2 and ma3 > ma1 and ma2 > ma1

plotshape(longCond3, title='Buy Signal', text='', textcolor=color.new(color.white, 0), style=shape.labeldown, size=size.tiny, location=location.bottom, color=color.new(#04f60c, 0), series=ma3)
plotshape(shortCond3, title='Sell Signal', text='', textcolor=color.new(color.white, 0), style=shape.labeldown, size=size.tiny, location=location.bottom, color=color.new(#f44343, 0), series=ma3)

// Plot sideways signal when there is no buy and sell signal
plotshape(not (longCond3 or shortCond3), title='Sideways Signal', text='', textcolor=color.new(color.white, 0), style=shape.labeldown, size=size.tiny, location=location.bottom, color=color.new(#454c53, 0), series=ma3)
///// -- Table Inputs
 
//----


/// -------------- Table Start -------------------


  
var table_text_size = text_size == 'Tiny' ? size.tiny :
  text_size == 'Small' ? size.small :
  text_size == 'Normal' ? size.normal : size.large


ShowEma = input(false, "â”€â”€â”€â”€ Show EMA â”€â”€â”€â”€â”€")
LenEma = input.int(defval=20)
EMA = ta.ema(close, LenEma)
//rsi = rsi(close, 14)
LenEma5 = input.int(defval=5)
EMA5 = ta.ema(close, LenEma5)
//rsi = rsi(close, 14)

//study("Supertrend", overlay=true)
ShowSuperTrend = input(false, "â”€â”€â”€â”€ Show SuperTrend Indicator â”€â”€â”€â”€â”€")
highlighting21 = input.bool(title="Show HIghlights",  defval=false)
len = input.int( defval=10)
mult = input.int( defval=2)
[superTrend, dir] = ta.supertrend(mult, len)
colResistance = dir == 1 and dir == dir[1] ? color.new(#f50606, 0) : color.new(color.red, 100)
colSupport = dir == -1 and dir == dir[1] ? color.new(#07f80f, 0) : color.new(color.green, 100)

upPlot = plot(ShowSuperTrend?superTrend:na, color = colSupport, linewidth=1)
dnPlot = plot(ShowSuperTrend?superTrend:na , color = colResistance, linewidth=1)
hPlot = plot(ohlc4, title="", style=plot.style_circles, linewidth=0, editable = false)
longFill = highlighting21 ? (dir == -1 ? color.new(#05ff0d, 20) : na) : na
shortFill = highlighting21 ? (dir == 1 ? color.new(#f70909, 20) : na ) : na
fill(hPlot, upPlot, color=longFill)
fill(hPlot, dnPlot, color=shortFill)

//Plot Buy Signal
longCondition =  dir == -1 and dir[1] == 1

//Plot Sell Signal
shortCondition = dir == 1 and dir[1] == -1
//next3
// --- inputs
source = close
turnon2 = input(true, title='Turn on Alerts?')
colorbars  = input(true, title = "Color Bars?")
colorbars2 = input(true,title = "Color Bar when price closes under / above Ema 1 & 2?" , inline = "1")
barc1 = input (color.rgb(0, 38, 255), "", inline = "1")
barc2 = input(color.orange, "", inline ="1")
turnon = input(true, title='Turn on Ema 1 & 2?')
backgroundcolor = input(false, title='Enable Background Color?')

//Ema 1 & 2
len1 = input.int(10, minval=1, title='EMA1')
len2 = input.int(21, minval=1, title='EMA2')
ema1 = ta.ema(source, len1)
ema2 = ta.ema(source, len2)
//---

cond1 = ta.crossover(close,ema1) and ta.crossover(close,ema2)
cond2 = ta.crossunder(close,ema1) and ta.crossunder(close,ema2)

barcolor(cond1 ? color.rgb(0, 38, 255) : cond2 ? color.orange: na)
alertcondition(cond1, title = "Alert when price rises above  Ema1 and Ema 2?", message = "Price rose above Ema 1 & Ema 2")
alertcondition(cond2, title = "Alert when price drops below Ema1 and Ema 2?", message = "Price closed below Ema 1 & Ema 2")
//-- Candle Color
colbar = ema1 > ema2 ? color.rgb(15, 250, 23) :  color.rgb(255, 0, 0) 
barcolor(colorbars ? colbar :na)


// --- Ema Inputs
//Ema 3
turnon3 = input(false, title='Turn on EMA3?')
len3 = input.int(5, minval=1, title='EMA3')
ema3 = ta.ema(source, len3)
plot(turnon3 ? ema3 : na, 'Ema 3', style=plot.style_line, linewidth=2, color=color.new(color.blue, 0))

//Ema 4
turnon4 = input(false, title='Turn on EMA4')
len4 = input.int(8, minval=1, title='EMA4')
ema4 = ta.ema(source, len4)
plot(turnon4 ? ema4 : na, 'Ema 4', style=plot.style_line, linewidth=2, color=color.new(color.orange, 0))

//Ema 5
turnon5 = input(false, title='Turn on EMA5?')
len5 = input.int(34, minval=1, title='EMA5')
ema5 = ta.ema(source, len5)
plot(turnon5 ? ema5 : na, 'Ema 5', style=plot.style_line, linewidth=2, color=color.new(color.yellow, 0))

//Ema 6
turnon6 = input(false, title='Turn on EMA6?')
len6 = input.int(55, minval=1, title='EMA6')
ema6 = ta.ema(source, len6)
plot(turnon6 ? ema6 : na, 'Ema 6', style=plot.style_line, linewidth=2, color=color.new(color.purple, 0))

//Ema 7
turnon7 = input(false, title='Turn on EMA7?')
lenn7 = input.int(89, minval=1, title='EMA7')
ema7 = ta.ema(source, lenn7)
plot(turnon7 ? ema7 : na, 'Ema 7', style=plot.style_line, linewidth=2, color=color.new(color.fuchsia, 0))

//Ema 8
turnon8 = input(false, title='Turn on EMA8?')
lenn8 = input.int(144, minval=1, title='EMA8')
ema8 = ta.ema(source, lenn8)
plot(turnon8 ? ema8 : na, 'Ema 8', style=plot.style_line, linewidth=2, color=color.new(color.teal, 0))

// Ema 9
turnon9 = input(false, title='Turn on EMA9?')
len9 = input.int(200, minval=1, title='EMA9')
ema9 = ta.ema(source, len9)
plot(turnon9 ? ema9 : na, 'Ema 9', style=plot.style_line, linewidth=2, color=color.new(color.aqua, 0))

// Ema Cross 
mylong = ta.crossover(ema1, ema2)
myshort = ta.crossunder(ema1, ema2)

first = ta.ema(close, len1)
sec = ta.ema(close, len2)

// Calculations
last_long = float(na)
last_short = float(na)
last_long := mylong ? time : nz(last_long[1])
last_short := myshort ? time : nz(last_short[1])

in_long = last_long > last_short ? 2 : 0
in_short = last_short > last_long ? 2 : 0

condlongx = in_long
condlong = ta.crossover(condlongx, 1.9)
condlongclose = ta.crossunder(condlongx, 1.9)

condshortx = in_short
condshort = ta.crossover(condshortx, 1.9)
condshortclose = ta.crossover(condshortx, 1.9)

// Color Fill
fcolor = first > sec ? #0aff68 : first < sec ? #ff0a5a : #cccccc

// Ema Output
// Plots
plotshape(turnon2 ? condlong : na, title='Breakout', color=color.new(#112f16, 0), location=location.belowbar, style=shape.labelup, text='Up', textcolor=color.new(color.white, 0), size=size.small, offset=1)
plotshape(turnon2 ? condshort : na, title='Breakdown', color=color.new(#9d0d0d, 0), style=shape.labeldown, text='Down', textcolor=color.new(color.white, 0), size=size.small, offset=1)

// Alerts Ema 1 & 2 Crossover & Crossunder
alertcondition(condlong, 'Breakout')
alertcondition(condshort, 'Breakdown')
//---

// Background Color
bgcolor(backgroundcolor ? fcolor : na, transp=67)

// Dashboard 
showTable = input.bool(defval=true, title='Display Ema Dashboard', group='EMA DashboardðŸ¤–')
tablePosition = input.string(title='Dashboard Position?', defval=position.bottom_right, options=[position.bottom_left, position.top_left, position.bottom_right, position.top_right], group='Trend DashboardðŸ¤–', tooltip = "Allows you to change the position of the dashboard on the chart.")
tableTextSize = input.string(title='Dashboard Size?', defval=size.small, options=[size.auto, size.tiny, size.small, size.normal, size.large, size.huge], group='Trend DashboardðŸ¤–', tooltip = "Use Tiny if on Mobile, Use Small if on Web browser.")

// Start Ema Dashboard inputs
// Signal Crossover
Dema1 = ema1 > ema2 ? "Above" : "Below"
Dema11 = ema1 > ema2 ? color.rgb(47, 78, 48) : color.rgb(255, 0, 0)

// Start Emas
// len1
Dema2 = close > ema1 ? "Above" : "Below"
Dema22 = close > ema1  ? color.rgb(47, 78, 48) : color.rgb(255, 0, 0)
//
// len2 
Dema3 = close > ema2 ? "Above" : "Below"
Dema33 = close > ema2  ? color.rgb(47, 78, 48) : color.rgb(255, 0, 0)
//
Dema4 = close > ema3 ? "Above" : "Below"
Dema44 = close > ema3  ? color.rgb(47, 78, 48) : color.rgb(255, 0,0)
//
Dema5 = close > ema4 ? "Above" : "Below"
Dema55 = close > ema4  ? color.rgb(47, 78, 48) : color.rgb(255, 0, 0)
//
Dema6 = close > ema5 ? "Above" : "Below"
Dema66 = close > ema5  ? color.rgb(47, 78, 48) : color.rgb(255, 0,0)
//
Dema7 = close > ema6 ? "Above" : "Below"
Dema77 = close > ema6  ? color.rgb(47, 78, 48) : color.rgb(255, 0,0)
//
Dema8 = close > ema7 ? "Above" : "Below"
Dema88 = close > ema7  ? color.rgb(47, 78, 48) : color.rgb(255, 0,0)
//
Dema9 = close > ema8 ? "Above" : "Below"
Dema99 = close > ema8  ? color.rgb(47, 78, 48) : color.rgb(255, 0,0)
//
Dema10 = close > ema9 ? "Above" : "Below"
Dema101 = close > ema9  ? color.rgb(47, 78, 48) : color.rgb(255, 0,0)

var ssltable = table.new(tablePosition, 2, 21, border_width = 3,bgcolor = color.new(color.black,0), border_color=color.new(#333333,0))
if barstate.islast 
    if showTable
        table.cell(ssltable, 0, 0, text='EMA', text_color=color.new(color.white, 0), text_size=tableTextSize)
        table.cell(ssltable, 1, 0, text='Above / Below', text_color=color.new(color.white, 0), text_size=tableTextSize)
    if showTable   
        table.cell(ssltable, 0, 1, text='Ema Cross', text_color=color.new(color.white, 0), text_size=tableTextSize,bgcolor=color.new(color.gray,0))
        table.cell(ssltable, 1, 1, text= Dema1, text_color=color.new(color.white, 0), text_size=tableTextSize,bgcolor=Dema11) // Buy / Sell Signal
    if showTable 
        table.cell(ssltable, 0, 2, text='Ema - '+ str.tostring(math.round(len1, 0)), text_color=color.new(color.white, 0), text_size=tableTextSize,bgcolor=color.new(color.gray,0))
        table.cell(ssltable, 1, 2, text= Dema2, text_color=color.new(color.white, 0), text_size=tableTextSize,bgcolor=Dema22) // Buy / Sell Signal
    if showTable 
        table.cell(ssltable, 0, 3, text='Ema - ' + str.tostring(math.round(len2, 0)),text_color=color.new(color.white, 0), text_size=tableTextSize,bgcolor=color.new(color.gray,0))
        table.cell(ssltable, 1, 3, text=Dema3, text_color=color.new(color.white, 0), text_size=tableTextSize,bgcolor=Dema33) // Bull / Bear Line
    if showTable 
        table.cell(ssltable, 0, 4, text='Ema - ' + str.tostring(math.round(len3, 0)), text_color=color.new(color.white, 0), text_size=tableTextSize,bgcolor=color.new(color.gray,0))
        table.cell(ssltable, 1, 4, text=Dema4, text_color=color.new(color.white, 0), text_size=tableTextSize,bgcolor=Dema44) // Stoch Cross
    if showTable    
        table.cell(ssltable, 0, 5, text='Ema - ' + str.tostring(math.round(len4, 0)),text_color=color.new(color.white, 0), text_size=tableTextSize,bgcolor=color.new(color.gray,0))
        table.cell(ssltable, 1, 5, text=Dema5, text_color=color.new(color.white, 0), text_size=tableTextSize,bgcolor=Dema55) // Stoch in reversal Zone
    if showTable 
        table.cell(ssltable, 0, 6, text='Ema - ' + str.tostring(math.round(len5, 0)), text_color=color.new(color.white, 0), text_size=tableTextSize,bgcolor=color.new(color.gray,0))
        table.cell(ssltable, 1, 6, text=Dema6, text_color=color.new(color.white, 0), text_size=tableTextSize,bgcolor=Dema66)
    if showTable 
        table.cell(ssltable, 0, 7, text='Ema - ' + str.tostring(math.round(len6, 0)), text_color=color.new(color.white, 0), text_size=tableTextSize,bgcolor=color.new(color.gray,0))
        table.cell(ssltable, 1, 7, text=Dema7, text_color=color.new(color.white, 0), text_size=tableTextSize,bgcolor=Dema77)
    if showTable    
        table.cell(ssltable, 0, 8, text='Ema - ' + str.tostring(math.round(lenn7, 0)), text_color=color.new(color.white, 0), text_size=tableTextSize,bgcolor=color.new(color.gray,0))
        table.cell(ssltable, 1, 8, text= Dema8, text_color=color.new(color.white, 0), text_size=tableTextSize,bgcolor=Dema88)
    if showTable    
        table.cell(ssltable, 0, 9, text='Ema - ' + str.tostring(math.round(lenn8, 0)), text_color=color.new(color.white, 0), text_size=tableTextSize,bgcolor=color.new(color.gray,0))
        table.cell(ssltable, 1, 9, text= Dema9, text_color=color.new(color.white, 0), text_size=tableTextSize,bgcolor=Dema99)
    if showTable    
        table.cell(ssltable, 0, 10, text='Ema - ' + str.tostring(math.round(len9, 0)), text_color=color.new(color.white, 0), text_size=tableTextSize,bgcolor=color.new(color.gray,0))
        table.cell(ssltable, 1, 10, text= Dema10, text_color=color.new(color.white, 0), text_size=tableTextSize,bgcolor=Dema101)

//scanner

macdcrossscreener=input.bool(true, title="MACD Screener", group="MACD")
EMandSTscanner=input.bool(true, title="EMA200 & Supertrend Cross", group="EMA200 + Supertrend")
Halftrend = input.bool(true, title="Half Trend", group="HalfTrend")

///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
//Screener function to calculate Bull and Bear status of teh signal equalent to Buy and Sell Signal
screener() =>
//Buy/Sell signal calculation if scaning for EMA200 cross over and Supertrend and close crossover
    if(EMandSTscanner==true and macdcrossscreener==false)
       
        [supertrend,direction] = ta.supertrend(2.5,10)

        buy    =ta.crossover(close, supertrend) and ta.crossover(open, supertrend)
        sell   =ta.crossunder(close, supertrend) and ta.crossunder(open, supertrend)
   
        bull=   buy
        bear= sell
        [bull, bear]
    //Buy/Sell signal calculation if scaning for only MACD Crossover based buy/Sell signal
    if(macdcrossscreener==true and EMandSTscanner==false)

        [macdline, sigline, histline] =  ta.macd(close, 12, 26, 9)
        buy    =ta.crossover(macdline, sigline) 
        sell   =ta.crossunder(macdline, sigline) 
        bull= buy
        bear=sell
        [bull, bear]
     //Buy/Sell signal calculation if scaning for  MACD Crossover based buy/Sell signal and EMA200 cross over and Supertrend and close crossover
    if(macdcrossscreener==true and EMandSTscanner==true)
        [supertrend,direction] = ta.supertrend(2.5,10)
        [macdline, sigline, histline] =  ta.macd(close, 12, 26, 9)

        buy    =ta.crossover(close, supertrend)  and ta.crossover(macdline, sigline) and ta.crossover(close, ta.ema(close, 200))
        sell   =ta.crossunder(close, supertrend)  and ta.crossunder(macdline, sigline) and ta.crossunder(close, ta.ema(close, 200))
        bull= buy
        bear=sell
        [bull, bear]
    // Consider Half Trend based Buy/Sell signals in addition to EMA200 cross over and Supertrend and close crossover and MACD Crossover
    if(Halftrend==true)
    //Calculation of Half Trend Buy/Sell signals
        amplitude = input(title='Amplitude', defval=2)
        channelDeviation = input(title='Channel Deviation', defval=2)
        showArrows = input(title='Show Arrows', defval=true)
        showChannels = input(title='Show Channels', defval=true)

        var int trend = 0
        var int nextTrend = 0
        var float maxLowPrice = nz(low[1], low)
        var float minHighPrice = nz(high[1], high)

        var float up = 0.0
        var float down = 0.0
        float atrHigh = 0.0
        float atrLow = 0.0
        float arrowUp = na
        float arrowDown = na

        atr2 = ta.atr(100) / 2
        dev = channelDeviation * atr2

        highPrice = high[math.abs(ta.highestbars(amplitude))]
        lowPrice = low[math.abs(ta.lowestbars(amplitude))]
        highma = ta.sma(high, amplitude)
        lowma = ta.sma(low, amplitude)

        if nextTrend == 1
            maxLowPrice := math.max(lowPrice, maxLowPrice)

            if highma < maxLowPrice and close < nz(low[1], low)
                trend := 1
                nextTrend := 0
                minHighPrice := highPrice
                minHighPrice
        else
            minHighPrice := math.min(highPrice, minHighPrice)

            if lowma > minHighPrice and close > nz(high[1], high)
                trend := 0
                nextTrend := 1
                maxLowPrice := lowPrice
                maxLowPrice

        if trend == 0
            if not na(trend[1]) and trend[1] != 0
                up := na(down[1]) ? down : down[1]
                arrowUp := up - atr2
                arrowUp
            else
                up := na(up[1]) ? maxLowPrice : math.max(maxLowPrice, up[1])
                up
            atrHigh := up + dev
            atrLow := up - dev
            atrLow
        else
            if not na(trend[1]) and trend[1] != 1
                down := na(up[1]) ? up : up[1]
                arrowDown := down + atr2
                arrowDown
            else
                down := na(down[1]) ? minHighPrice : math.min(minHighPrice, down[1])
                down
            atrHigh := down + dev
            atrLow := down - dev
            atrLow

        ht = trend == 0 ? up : down

    
        buy = not na(arrowUp) and trend == 0 and trend[1] == 1
        sell = not na(arrowDown) and trend == 1 and trend[1] == 0

        bull=buy
        bear=sell
        [bull, bear]
    

////////////////////////////////////////////////
//////////////////////// Screener Section ////////////////////////////

var tableTheme = "========= Table Theme ========="
bgColor = input.color(#d1d4dc, "Background", group = tableTheme, inline = "table")
frameColor = input.color(color.white, "Frame", group = tableTheme, inline = "table")
textColor = input.color(color.rgb(0, 0, 0), "Text", group = tableTheme, inline = "table")

textSize = switch input.string("Auto", "Size", options = ['Auto', 'Tiny', 'Small', 'Normal', 'Large', 'Huge'], group = tableTheme)
    "Auto" => size.auto
    "Tiny" => size.tiny
    "Small" => size.small
    "Normal" => size.normal
    "Large" => size.large
    "Huge" => size.huge

location = switch input.string("Top Center", "Table Location", 
 options = ['Top Right', 'Top Center', 'Top Left', 'Middle Right', 'Middle Center', 'Middle Left', 'Bottom Right', 'Bottom Center', 'Bottom Left'], group = tableTheme)
    "Top Right" => position.top_right
    "Top Center" => position.top_center
    "Top Left" => position.top_left
    "Middle Right" => position.middle_right
    "Middle Center" => position.middle_center
    "Middle Left" => position.middle_left
    "Bottom Right" => position.bottom_right
    "Bottom Center" => position.bottom_center
    "Bottom Left" => position.bottom_left

/////////////////// Screener ////////////////////////
getSignal(symbol, longArray, shortArray)=>
    [long, short] = request.security(symbol, "", [longCondition, shortCondition])

    if long
        longArray.push(symbol)

    if short
        shortArray.push(symbol)

gticker = '=============== Watchlist ==============='
symbol81 = input.symbol(defval = "NSE:HINDPETRO", title="symbol81", group=gticker)
symbol82 = input.symbol(defval = "NSE:HINDUNILVR", title="symbol82", group=gticker)
symbol83 = input.symbol(defval = "NSE:IBULHSGFIN", title="symbol83", group=gticker)
symbol84 = input.symbol(defval = "NSE:ICICIBANK", title="symbol84", group=gticker)
symbol85 = input.symbol(defval = "NSE:ICICIGI", title="symbol85", group=gticker)
symbol86 = input.symbol(defval = "NSE:ICICIPRULI", title="symbol86", group=gticker)
symbol87 = input.symbol(defval = "NSE:IDEA", title="symbol87", group=gticker)
symbol88 = input.symbol(defval = "NSE:IDFC", title="symbol88", group=gticker)
symbol89 = input.symbol(defval = "NSE:IDFCFIRSTB", title="symbol89", group=gticker)
symbol90 = input.symbol(defval = "NSE:IEX", title="symbol90", group=gticker)
symbol91 = input.symbol(defval = "NSE:IGL", title="symbol91", group=gticker)
symbol92 = input.symbol(defval = "NSE:INDHOTEL", title="symbol92", group=gticker)
symbol93 = input.symbol(defval = "NSE:INDIACEM", title="symbol93", group=gticker)
symbol94 = input.symbol(defval = "NSE:INDIAMART", title="symbol94", group=gticker)
symbol95 = input.symbol(defval = "NSE:INDIGO", title="symbol95", group=gticker)
symbol96 = input.symbol(defval = "NSE:INDUSINDBK", title="symbol96", group=gticker)
symbol97 = input.symbol(defval = "NSE:INDUSTOWER", title="symbol97", group=gticker)
symbol98 = input.symbol(defval = "NSE:INFY", title="symbol98", group=gticker)
symbol99 = input.symbol(defval = "NSE:IOC", title="symbol99", group=gticker)
symbol100 = input.symbol(defval = "NSE:IPCALAB", title="symbol100", group=gticker)
symbol101 = input.symbol(defval = "NSE:IRCTC", title="symbol101", group=gticker)
symbol102 = input.symbol(defval = "NSE:ITC", title="symbol102", group=gticker)
symbol103 = input.symbol(defval = "NSE:JINDALSTEL", title="symbol103", group=gticker)
symbol104 = input.symbol(defval = "NSE:JKCEMENT", title="symbol104", group=gticker)
symbol105 = input.symbol(defval = "NSE:JSWSTEEL", title="symbol105", group=gticker)
symbol106 = input.symbol(defval = "NSE:JUBLFOOD", title="symbol106", group=gticker)
symbol107 = input.symbol(defval = "NSE:KOTAKBANK", title="symbol107", group=gticker)
symbol108 = input.symbol(defval = "NSE:L_TFH", title="symbol108", group=gticker)
symbol109 = input.symbol(defval = "NSE:LALPATHLAB", title="symbol109", group=gticker)
symbol110 = input.symbol(defval = "NSE:LAURUSLABS", title="symbol110", group=gticker)
symbol111 = input.symbol(defval = "NSE:LICHSGFIN", title="symbol111", group=gticker)
symbol112 = input.symbol(defval = "NSE:LT", title="symbol112", group=gticker)



longArray = array.new_string(na)
shortArray = array.new_string(na)

getSignal(symbol81,longArray, shortArray)
getSignal(symbol82,longArray, shortArray)
getSignal(symbol83,longArray, shortArray)
getSignal(symbol84,longArray, shortArray)
getSignal(symbol85,longArray, shortArray)
getSignal(symbol86,longArray, shortArray)
getSignal(symbol87,longArray, shortArray)
getSignal(symbol88,longArray, shortArray)
getSignal(symbol89,longArray, shortArray)
getSignal(symbol90,longArray, shortArray)
getSignal(symbol91,longArray, shortArray)
getSignal(symbol92,longArray, shortArray)
getSignal(symbol93,longArray, shortArray)
getSignal(symbol94,longArray, shortArray)
getSignal(symbol95,longArray, shortArray)
getSignal(symbol96,longArray, shortArray)
getSignal(symbol97,longArray, shortArray)
getSignal(symbol98,longArray, shortArray)
getSignal(symbol99,longArray, shortArray)
getSignal(symbol100,longArray, shortArray)
getSignal(symbol101,longArray, shortArray)
getSignal(symbol102,longArray, shortArray)
getSignal(symbol103,longArray, shortArray)
getSignal(symbol104,longArray, shortArray)
getSignal(symbol105,longArray, shortArray)
getSignal(symbol106,longArray, shortArray)
getSignal(symbol107,longArray, shortArray)
getSignal(symbol108,longArray, shortArray)
getSignal(symbol109,longArray, shortArray)
getSignal(symbol110,longArray, shortArray)
getSignal(symbol111,longArray, shortArray)
getSignal(symbol112,longArray, shortArray)
getSym(sym)=>
    str.tostring(array.get(str.split(sym, ":"), 1))
    
if barstate.islast
    rowSize = math.max(longArray.size(), shortArray.size())
    dashboard = table.new(location, 2, rowSize + 3, border_color = frameColor, border_width = 1)
    dashboard.cell(0, 0, text = "Screener", bgcolor = bgColor, text_size = textSize, text_color = textColor)
    dashboard.merge_cells(0, 0, 1, 0)

    dashboard.cell(0, 1, text = "Long Signal", bgcolor = color.lime, text_size = textSize, text_color = color.black)
    dashboard.cell(1, 1, text = "Short Signal", bgcolor = color.red, text_size = textSize, text_color = color.white)

    if longArray.size() > 0
        for i = 0 to longArray.size() - 1
            dashboard.cell(0, i + 2, getSym(longArray.get(i)), text_color = textColor, bgcolor = color.lime, text_size = textSize)
    else
        dashboard.cell(0, 2, text = "No Signal", bgcolor = color.yellow, text_size = textSize, text_color = color.black)

    if shortArray.size() > 0
        for i = 0 to shortArray.size() - 1
            dashboard.cell(1, i + 2, getSym(shortArray.get(i)), text_color = textColor, bgcolor = color.red, text_size = textSize)
    else
        dashboard.cell(1, 2, text = "No Signal", bgcolor = color.yellow, text_size = textSize, text_color = color.black)


len66=input.int(10, "Length")  

o=ta.ema(open,len66)   
c=ta.ema(close,len66)  
h=ta.ema(high,len66)  
l=ta.ema(low,len66)   

var float haopen = na   
var float hahigh = na
var float halow = na  

haclose = (o+h+l+c)/4 
haopen := na(haopen[1]) ? (o + c)/2 : (haopen[1] + haclose[1]) / 2   
hahigh := math.max(h, math.max(haopen,haclose)) 
halow := math.min(l, math.min(haopen,haclose)) 

len36 = len66 * 5 
o3=ta.ema(haopen, len36)   
c3=ta.ema(haclose, len36) 
h3=ta.ema(hahigh, len36)  
l3=ta.ema(halow, len36)  

color3 = o3 > c3 ? color.red : color.green 

plotcandle(open, high, low, close, color=color3, wickcolor=color3, bordercolor=na)   
plotcandle(o3, h3, l3, c3, color=color3, wickcolor=na, bordercolor=na)   

indicatorColor3 = o3 > c3 ? color.red : color.green
plot(o3, color=indicatorColor3, linewidth=2)  
plot(c3, color=indicatorColor3, linewidth=2)

var pcolor3 = color3
colorChange3 = color3 != pcolor3[1]
plotshape(series=colorChange3 and color3 == color.green ? high : na, location=location.belowbar, color=color3, style=shape.triangleup, size=size.small)
plotshape(series=colorChange3 and color3 == color.red ? low : na, location=location.abovebar, color=color3, style=shape.triangledown, size=size.small)
pcolor3 := color3

smaPrice = ta.sma(close, 10)
smaPrice1D = request.security(syminfo.tickerid, "D", smaPrice)

close_1D = request.security(syminfo.tickerid, "D", close)
ema20 = request.security(syminfo.tickerid, "D", ta.ema(close, 20))
t = table.new(position = position.top_right, columns = 1, rows = 1)
last_close_1D = request.security(syminfo.tickerid, "D", close)

if (last_close_1D > ema20)
    table.cell(t, row = 0, column = 0, text = "             Trend Up             ", bgcolor = color.green)
else
    table.cell(t, row = 0, column = 0, text = "             Downtrend             ", bgcolor = color.red)

plot(ema20, color = color.new(#ff5252, 100))



