//@version=5
indicator('!<*Профиль объема/фиксированный диапазон(P&S)*>!', overlay=true, max_boxes_count=200, max_bars_back=501)
bbars = input.int(title='Количество баров', defval=20, minval=1, maxval=500)
cnum = input.int(title='Размер строки', defval=24, minval=5, maxval=100)
percent = input.float(70., title='Объем области значений %', minval=0, maxval=100)
poc_color = input.color(defval=#ff0000, title='POC Цвет', inline='poc')
poc_width = input.int(defval=1, title='Ширина', minval=1, maxval=5, inline='poc')
vup_color = input(defval=#0466fe, title='Область значений вверх')
vdown_color = input(defval=#ff9800b3, title='Область значений вниз')
up_color = input(defval=#2196f340, title='Повышение объёма')
down_color = input(defval=#ff980040, title='Понижение объема')
show_poc = input.bool(defval = false, title = "Показать Лейбл POC")

top = ta.highest(bbars)
bot = ta.lowest(bbars)
dist = (top - bot) / 500
step = (top - bot) / cnum

// рассчитываем/сохраняем уровни канала
levels = array.new_float(cnum + 1)
for x = 0 to cnum by 1
    array.set(levels, x, bot + step * x)

// получаем объем, если есть пересечение
get_vol(y11, y12, y21, y22, height, vol) =>
    nz(math.max(math.min(math.max(y11, y12), math.max(y21, y22)) - math.max(math.min(y11, y12), math.min(y21, y22)), 0) * vol / height)

if barstate.islast
    // рассчитываем/получаем объем для каждого канала и свечи
    volumes = array.new_float(cnum * 2, 0.)
    for bars = 0 to bbars - 1 by 1
        body_top = math.max(close[bars], open[bars])
        body_bot = math.min(close[bars], open[bars])
        itsgreen = close[bars] >= open[bars]

        topwick = high[bars] - body_top
        bottomwick = body_bot - low[bars]
        body = body_top - body_bot

        bodyvol = body * volume[bars] / (2 * topwick + 2 * bottomwick + body)
        topwickvol = 2 * topwick * volume[bars] / (2 * topwick + 2 * bottomwick + body)
        bottomwickvol = 2 * bottomwick * volume[bars] / (2 * topwick + 2 * bottomwick + body)
        for x = 0 to cnum - 1 by 1
            array.set(volumes, x, array.get(volumes, x) + (itsgreen ? get_vol(array.get(levels, x), array.get(levels, x + 1), body_bot, body_top, body, bodyvol) : 0) + get_vol(array.get(levels, x), array.get(levels, x + 1), body_top, high[bars], topwick, topwickvol) / 2 + get_vol(array.get(levels, x), array.get(levels, x + 1), body_bot, low[bars], bottomwick, bottomwickvol) / 2)
            array.set(volumes, x + cnum, array.get(volumes, x + cnum) + (itsgreen ? 0 : get_vol(array.get(levels, x), array.get(levels, x + 1), body_bot, body_top, body, bodyvol)) + get_vol(array.get(levels, x), array.get(levels, x + 1), body_top, high[bars], topwick, topwickvol) / 2 + get_vol(array.get(levels, x), array.get(levels, x + 1), body_bot, low[bars], bottomwick, bottomwickvol) / 2)

    totalvols = array.new_float(cnum, 0.)
    for x = 0 to cnum - 1 by 1
        array.set(totalvols, x, array.get(volumes, x) + array.get(volumes, x + cnum))

    int poc = array.indexof(totalvols, array.max(totalvols))

   // вычисляем область значений
    totalmax = array.sum(totalvols) * percent / 100.
    va_total = array.get(totalvols, poc)
    int up = poc
    int down = poc
    for x = 0 to cnum - 1 by 1
        if va_total >= totalmax
            break
        uppervol = up < cnum - 1 ? array.get(totalvols, up + 1) : 0.
        lowervol = down > 0 ? array.get(totalvols, down - 1) : 0.
        if uppervol == 0 and lowervol == 0
            break
        if uppervol >= lowervol
            va_total += uppervol
            up += 1
            up
        else
            va_total += lowervol
            down -= 1
            down

    maxvol = array.max(totalvols)
    for x = 0 to cnum * 2 - 1 by 1
        array.set(volumes, x, array.get(volumes, x) * bbars / (3 * maxvol))

    // Рисуем строки VP
    var vol_bars = array.new_box(cnum * 2, na)
    for x = 0 to cnum - 1 by 1
        box.delete(array.get(vol_bars, x))
        box.delete(array.get(vol_bars, x + cnum))
        array.set(vol_bars, x, box.new(bar_index - bbars + 1, 
                                       array.get(levels, x + 1) - dist, 
                                       bar_index - bbars + 1 + math.round(array.get(volumes, x)), 
                                       array.get(levels, x) + dist, 
                                       border_width=0, 
                                       bgcolor=x >= down and x <= up ? vup_color : up_color))
        array.set(vol_bars, x + cnum, box.new(bar_index - bbars + 1 + math.round(array.get(volumes, x)), 
                                              array.get(levels, x + 1) - dist, 
                                              bar_index - bbars + 1 + math.round(array.get(volumes, x)) + math.round(array.get(volumes, x + cnum)), 
                                              array.get(levels, x) + dist, 
                                              border_width=0, 
                                              bgcolor=x >= down and x <= up ? vdown_color : down_color))

    // Рисуем линию POC и метку
    poc_level = (array.get(levels, poc) + array.get(levels, poc + 1)) / 2
    var line poc_line = na
    line.delete(poc_line)
    poc_line := line.new(bar_index - bbars + 1, poc_level, bar_index - bbars + 2, poc_level, extend=extend.right, color=poc_color, width=poc_width)
    
    if show_poc
        var label poc_label = na
        label.delete(poc_label)
        poc_label := label.new(bar_index + 15, poc_level, 
                               text = "POC: " + str.tostring(math.round_to_mintick(poc_level)),
                               style = close >= poc_level ? label.style_label_up : label.style_label_down)

// пользовательский ввод
lookback = input.int(title="Период возврата", defval=20, maxval=500, group="Основные настройки", tooltip="Количество баров для поиска самого высокого и самого низкого для создания диапазона цен")
segs = input.int(title="Количество уровней", defval=20, maxval=100, group="Основные настройки", tooltip="Количество сеток/узлов для профиля объема")
n_skew = input.int(title="Длина профиля", defval=9, minval=1, maxval=1000, group="Основные настройки", tooltip="Длина профиля объема. Больше = Шире, Меньше = Узкий")
n_shift = input.int(title="Смещение профиля", defval=10, group="Основные настройки", tooltip="Сместить весь профиль объема влево или вправо. Больше = Вправо, Меньше = Влево")
high_volume_color = input.color(#fcad02, "Высокий объем", inline = "Цвета", group = "Косметические настройки")
low_volume_color = input.color(#0466fe, "Низкий объем", inline = "Цвета", group = "Косметические настройки")
activity_bull_color = input.color(#ff9800e6, "Выше точки интереса", inline = "Точка интереса", group = "Косметические настройки")
activity_bear_color = input.color(#ff9800e6, "Ниже точки интереса", inline = "Точка интереса", group = "Косметические настройки")

// данные
highest_high = ta.highest(high, lookback)
lowest_low = ta.lowest(low, lookback)

// извлечение данных на младшем таймфрейме
tf = timeframe.isintraday ? 1 : 5  // Для M1 и M5 соответственно
req_tf = str.tostring(timeframe.multiplier)
[h, l, v] = request.security_lower_tf(syminfo.tickerid, req_tf, [high, low, volume])

// массивы
var borders = array.new_float()
var boxes = array.new_box()
var box_vols = array.new_float()

var line activity_line = na

// инициализируем массивы блоков на первом баре
if barstate.isfirst
    for i = 0 to segs - 1
        array.push(boxes, box.new(na, na, na, na, xloc = xloc.bar_time, border_color = na))
        array.push(box_vols, 0)

        activity_line := line.new(na, na, na, na, style = line.style_dashed, width = 2)

if barstate.islast
    //определяем диапазон и создаем сетку
    inc = (highest_high - lowest_low) / segs
    for i = 0 to segs
        if i == 0
            array.clear(borders)
        array.push(borders, highest_high - (inc * i))

    //анализируем все бары младших таймфреймов и приписываем объем каждой сетке
    for b = 0 to array.size(boxes) > 0 ? array.size(boxes) - 1 : na
        box_ = array.get(boxes, b)
        box_vol = 0.0
        t_border = array.get(borders, b)
        b_border = array.get(borders, b + 1)

        for q = 0 to lookback - 1
            for e = 0 to array.size(h[q]) > 0 ? array.size(h[q]) - 1 : na
                ltf_high = array.get(h[q], e)
                ltf_low = array.get(l[q], e)
                ltf_vol = array.get(v[q], e)

                ltf_diff = ltf_high - ltf_low

                if ltf_low <= t_border and ltf_high >= b_border
                    top_register = math.min(ltf_high, t_border)
                    bot_register = math.max(ltf_low, b_border)

                    register_diff = top_register - bot_register
                    register_vol = register_diff / ltf_diff
                    box_vol += nz(register_vol * ltf_vol)
        array.set(box_vols, b, box_vol)

    //обновляем объекты-коробки, придавая им правильный объем, цвет и положение
    max_vol = array.max(box_vols)
    min_vol = array.min(box_vols)
    shift = (time - time[n_shift])
    skew = (time - time[n_skew]) / max_vol
    for b = 0 to array.size(boxes) > 0 ? array.size(boxes) - 1 : na
        box_ = array.get(boxes, b)
        box_vol = array.get(box_vols, b)
        t_border = array.get(borders, b)
        b_border = array.get(borders, b + 1)

        box.set_lefttop(box_, (time + shift) - int(box_vol * skew), t_border)
        box.set_rightbottom(box_, time + shift, b_border)
        array.set(box_vols, b, box_vol)

        box.set_bgcolor(box_, color.from_gradient(box_vol, min_vol, max_vol, low_volume_color, high_volume_color))

        if box_vol == max_vol
            mid = (t_border + b_border) / 2
            line.set_xloc(activity_line, time, (time + shift) - int(box_vol * skew), xloc.bar_time)
            line.set_y1(activity_line, mid)
            line.set_y2(activity_line, mid)
            line.set_color(activity_line, close > mid ? activity_bull_color : activity_bear_color) 

//
isMode = input.string('Вверх/Вниз/Нейтрально', 'Режим', options=['Вверх/Вниз/Нейтрально', 'Вверх/Вниз'])
isDisplayMarketDelta = input(false, 'Показать Чистая дельта объема')
colorDeltaVolUpVal = input.color(#03fc0c, 'Чистая дельта +', inline='Дельта Число Цвет')
colorDeltaVolDnVal = input.color(#fa0505, 'Чистая дельта -', inline='Дельта Число Цвет')
colorDeltaVolNtVal = input.color(#787b86, 'Чистая дельта 0', inline='Дельта Число Цвет')
scaleDownFactor = input.int(1, 'Коэффициент Масштабирования', options=[1, 10, 100, 1000, 10000], tooltip='Отображение значения Чистая дельта масштабированного для лучшей читаемости')

UPDOWNNEUTRAL_MODE = 1
UPDOWN_MODE = 2

iMode = isMode == 'Вверх/Вниз/Нейтрально' ? UPDOWNNEUTRAL_MODE : UPDOWN_MODE

f_upDnNtVolume(_mode) =>
    varip float _prevClose = open
    varip float _prevVolume = 0.
    varip float _newVolume = 0.
    varip float _volUp = 0.
    varip float _volDn = 0.
    varip float _volNt = 0.
    varip int _prevPolarity = 0

    if barstate.isnew
        _volUp := 0.
        _volDn := 0.
        _volNt := 0.
        _prevClose := nz(close[1])
        _prevVolume := 0.
        _prevPolarity := nz(_prevPolarity[1])

    _newVolume := volume - _prevVolume

    if close > _prevClose
        _prevPolarity := 1
        _volUp += _newVolume
    else if close < _prevClose
        _prevPolarity := -1
        _volDn += _newVolume
    else
        if _mode == UPDOWN_MODE
            if _prevPolarity == 1
                _volUp += _newVolume
            else if _prevPolarity == -1
                _volDn += _newVolume
            else
                _volNt += _newVolume
        else
            _volNt += _newVolume

    _prevClose := close
    _prevVolume := volume
    [_volUp, _volDn, _volNt]

var bool isbarConsidered = false
[volUp, volDn, volNt] = f_upDnNtVolume(iMode)

isbarConsidered := barstate.isrealtime ? true : isbarConsidered

if isbarConsidered
    if isDisplayMarketDelta
        text_color = volUp - volDn > 0 ? colorDeltaVolUpVal : volUp - volDn < 0 ? colorDeltaVolDnVal : colorDeltaVolNtVal
        label.new(x=bar_index, y=volUp - volDn, yloc=yloc.abovebar, textcolor=color.new(text_color, 0), style=label.style_none, text=str.tostring(int((volUp - volDn) / scaleDownFactor)))

///Ключевые уровни P&S//
green = input(#00ffbb, title="Цвет восходящих уровней")
red = input(#ff1100, title="Цвет нисходящих уровней")

candledir = close > open ? 1 : -1
candlelen = math.abs(close-open)

valleyform = candlelen > candlelen[1] and candledir * candledir[1] == -1 and candledir == 1 and volume < volume[1]
peakform = candlelen > candlelen[1] and candledir * candledir[1] == -1 and candledir == -1 and volume < volume[1]

bullishrej(level) =>
    low < level and close > level

bearishrej(level) =>
    high > level and close < level

max_levels = input(500, title="Максимальное количество уровней")
max_bars = input(500, title="Максимальное количество баров")
show_up_levels = input(true, title="Показывать восходящие уровни")
show_down_levels = input(true, title="Показывать нисходящие уровни")
show_dashed_lines = input(true, title="Показывать пунктирные линии")

type bar
    float h = high
    float l = low
    float v = volume
    int   i = bar_index

bar b = bar.new()

var x = 1
var hh = 0.0
var ll = 0.0
var aR = array.new_line()
var aS = array.new_line()
var aRb = array.new_line()
var aSb = array.new_line()

if peakform and show_up_levels
    aR.push(line.new(bar_index, open[1], bar_index+1, open[1], color = red))

if valleyform and show_down_levels
    aS.push(line.new(bar_index, open[1], bar_index+1, open[1], color = green))

if aR.size() > 0
    qt = aR.size()

    for ln = qt - 1 to 0
        if ln < aR.size()
            cL = aR.get(ln)
            yL = cL.get_y1()

            if close > yL
                aR.remove(ln)
                aRb.push(line.new(bar_index, yL, bar_index+1, yL, color = red, style = show_dashed_lines ? line.style_dashed : na))

            else
                cL.set_x2(b.i + 1)

    if aR.size() > max_levels
        aR.shift().delete()

if aRb.size() > 0
    qt = aRb.size()

    for ln = qt - 1 to 0
        if ln < aRb.size()
            cL = aRb.get(ln)
            yL = cL.get_y1()

            if close < yL
                aRb.remove(ln)

            else
                cL.set_x2(b.i + 1)

    if aRb.size() > max_levels
        aRb.shift().delete()

if aS.size() > 0
    qt = aS.size()

    for ln = qt - 1 to 0
        if ln < aS.size()
            cL = aS.get(ln)
            yL = cL.get_y1()

            if close < yL
                aS.remove(ln)
                aSb.push(line.new(bar_index, yL, bar_index+1, yL, color = green, style = show_dashed_lines ? line.style_dashed : na))

            else
                cL.set_x2(b.i + 1)

    if aS.size() > max_levels
        aS.shift().delete()

if aSb.size() > 0
    qt = aSb.size()

    for ln = qt - 1 to 0
        if ln < aSb.size()
            cL = aSb.get(ln)
            yL = cL.get_y1()

            if close > yL
                aSb.remove(ln)

            else
                cL.set_x2(b.i + 1)

    if aSb.size() > max_levels
        aSb.shift().delete()

var table logo = table.new(position.bottom_right, 1, 1)
if barstate.islast
    table.cell(logo, 0, 0, 'DM', text_size=size.normal, text_color=#00897b)   
 
