# Nema MACD - indicator for MetaTrader 5

Source: https://www.mql5.com/en/code/17144

* [![](https://c.mql5.com/i/sidebar/mt.svg)MetaTrader 5](/en/code/mt5)
  + [![](https://c.mql5.com/i/sidebar/expert.svg)Experts](/en/code/mt5/experts)
  + [![](https://c.mql5.com/i/sidebar/indicator.svg)Indicators](/en/code/mt5/indicators)
  + [![](https://c.mql5.com/i/sidebar/scripts.svg)Scripts](/en/code/mt5/scripts)
  + [![](https://c.mql5.com/i/sidebar/library.svg)Libraries](/en/code/mt5/libraries)
* [![](https://c.mql5.com/i/sidebar/mt.svg)MetaTrader 4](/en/code/mt4)
  + [![](https://c.mql5.com/i/sidebar/expert.svg)Experts](/en/code/mt4/experts)
  + [![](https://c.mql5.com/i/sidebar/indicator.svg)Indicators](/en/code/mt4/indicators)
  + [![](https://c.mql5.com/i/sidebar/scripts.svg)Scripts](/en/code/mt4/scripts)
  + [![](https://c.mql5.com/i/sidebar/library.svg)Libraries](/en/code/mt4/libraries)

* [![](https://c.mql5.com/i/sidebar/storage.svg)Storage](/en/code/storage)

Watch [how to download](https://youtu.be/rloNyFVtHuA?list=PLltlMLQ7OLeKwyQwC8FhiKwjl9syKhOCK) trading robots for free

Find us on [Twitter](https://x.com/mql5com)!  
 Join our fan page

Interesting script?  
So post a [link](/en/code/17144) to it -  
let others appraise it

You liked the script? Try it in the [MetaTrader 5](https://download.mql5.com/cdn/web/metaquotes.ltd/mt5/mt5setup.exe?utm_source=www.mql5.com&utm_campaign=download) terminal

[to pocket](#pocket "Pocket allows you to insert a complete content description to the appropriate comment")

![Indicators](https://c.mql5.com/i/code/indicator.png)

# Nema MACD - indicator for MetaTrader 5

[Mladen Rakic](/en/users/mladen)  |
[English](javascript:void(false);)

[Русский](/ru/code/17144) [中文](/zh/code/17144) [Español](/es/code/17144) [Deutsch](/de/code/17144) [日本語](/ja/code/17144) [Português](/pt/code/17144)

Views:
:   8846

Rating:
:   (28)

Published:
:   12 December 2016, 08:19

Updated:
:   28 March 2017, 17:18
:   [Nema\_MACD.mq5](/en/code/download/17144/nema_macd.mq5 "Nema_MACD.mq5")
    (30.96 KB)
    [view](# "view")

    [Download as ZIP](/en/code/download/17144.zip "Download all attachments in the single ZIP archive") [How to download code from MetaEditor](https://www.metatrader5.com/en/metaeditor/help/workspace/toolbox#codebase)

    ![MQL5 - Language of trade strategies built-in the MetaTrader 5 client terminal](https://c.mql5.com/i/registerlandings/logo-2.png)

    You are missing trading opportunities:

    * Free trading apps
    * Over 8,000 signals for copying
    * Economic news for exploring financial markets

    Registration
    Log in

    latin characters without spaces

    a password will be sent to this email

    An error occurred

    * [Log in With Google](https://www.mql5.com/en/auth_oauth2?provider=Google&amp;return=popup&amp;reg=1)

    You agree to [website policy](/en/about/privacy) and [terms of use](/en/about/terms)

    If you do not have an account, please [register](https://www.mql5.com/en/auth_register)

    Allow the use of cookies to log in to the MQL5.com website.

    Please enable the necessary setting in your browser, otherwise you will not be able to log in.

     

    [Forgot your login/password?](https://www.mql5.com/en/auth_forgotten?return=popup)

    * [Log in With Google](https://www.mql5.com/en/auth_oauth2?provider=Google&amp;return=popup)
:   ![MQL5 Freelance](https://c.mql5.com/i/code/icon_freelance.svg)
    Need a robot or indicator based on this code? Order it on Freelance
    [Go to Freelance](/en/job/new "Go to Freelance")

Nema MACD indicator — that calculates MACD using the NEMA.

**Nema**
can calculate all the known variations (offspring) of EMA : EMA, DEMA,TEMA , ... DecEMA, ... and so on, up to "levels" or "depth" 50 (whatever
name it would be).

Some known depths :

* 1 -> EMA
* 2 -> DEMA
* 3 -> TEMA
* ....
* 10 -> DecEMA
* ....
* 50 -> the maximal depth calculated by this indicator

If
the depth is set to 1, NEMA is equal to EMA , for depth 2 it is equal to DEMA  , for depth 3 it is equal to TEMA and so on ..., up to depth 50. For depth 1 the calculated MACD is equal to the original Gerald Appel MACD, for any other depth(s) it becomes different. The same depth of NEMA calculation is applied to fast, slow and signal calculation.

Indicator is already coming with alerts and is multi time frame version.

![](https://c.mql5.com/18/56/nema_macd_cb.png)

**Last comments |
[Go to discussion](/en/forum/162966)**
(9)

![A. Forex](https://c.mql5.com/avatar/2016/9/57EB5D96-AAE8.jpg "A. Forex")

**[A. Forex](/en/users/andy.forex)**
|
28 Jul 2019 at 20:20

**Mladen Rakic:**  

Triangular MA is not an offspring of EMA - please read the first sentence too

Triangular MA is an entirely different type of calculation

Ok :)

What are the offsprings of EMA from depth 4 to 50 please??? (excluding depth 10)

![A. Forex](https://c.mql5.com/avatar/2016/9/57EB5D96-AAE8.jpg "A. Forex")

**[A. Forex](/en/users/andy.forex)**
|
8 Aug 2019 at 16:04

Don't understand why the author ignores the question. Perhaps clearer description has to be written?

Can someone post info about types of MA from depth 4 to 9, and 11 to 49?

Or they don't exist?

Thanks.

![xtemer](https://c.mql5.com/avatar/avatar_na2.png "xtemer")

**[xtemer](/en/users/xtemer)**
|
6 Apr 2021 at 08:06

**A. Forex:**  
 Don't understand why the author ignores the question. Perhaps clearer description has to be written?

Can someone post info about types of MA from depth 4 to 9, and 11 to 49?

Or they don't exist?

Thanks.

DEMA is Double EMA, TEMA is Triple EMA, the name is based on [tuple naming](https://en.wikipedia.org/wiki/Tuple#Names_for_tuples_of_specific_lengths "https://en.wikipedia.org/wiki/Tuple#Names_for_tuples_of_specific_lengths"), so the 4th EMA will be Quadruple EMA, 5th is Penta EMA, 6th is Hexa EMA, and so on.

![hxjsjzcn](https://c.mql5.com/avatar/avatar_na2.png "hxjsjzcn")

**[hxjsjzcn](/en/users/hxjsjzcn)**
|
23 Feb 2023 at 18:05

In the "Price" option, add the option to reference the closing price of the "range highest and lowest",However, the following warning appears, please do However, the following warning appears, please do not hesitate to ask for advice, thank you!

//------------------------------------------------------------------

#property copyright "© mladen, 2016, MetaQuotes Software Corp."

#property link " [www.forex-tsd.com,](https://www.mql5.com/en/forum "https://www.mql5.com/en/forum") [www.mql5.com"](https://www.mql5.com/ "https://www.mql5.com/")

//------------------------------------------------------------------

#property indicator\_separate\_window

//#property indicator\_buffers 6

**#property indicator\_buffers 9**

#property indicator\_plots 3

#property indicator\_label1 "OSMA filling"

#property indicator\_type1 DRAW\_FILLING

#property indicator\_colour1 clrLightBlue,clrPeachPuff

#property indicator\_label2 "MACD"

#property indicator\_type2 DRAW\_COLOR\_LINE

#property indicator\_colour2 clrSilver,clrDodgerBlue,clrSandyBrown

#property indicator\_style2 STYLE\_SOLID

#property indicator\_width2 3

#property indicator\_label3 "MACD signal"

#property indicator\_type3 DRAW\_LINE

#property indicator\_colour3 clrSalmon

#property indicator\_style3 STYLE\_DOT

//

//

clrSalmon #property indicator\_colour3 // //

//

//enum enPrices

enum enPrices

{

pr\_close, // Close

pr\_open, // Open

pr\_high, // High

pr\_low, // Low

pr\_median, // Median

pr\_typical, // Typical

pr\_weighted, // Weighted

pr\_average, // Average (high+low+open+close)/4

pr\_medianb, // Average median body (open+close)/2

pr\_tbiased, // Trend biased price

pr\_tbiased2, // Trend biased (extreme) price

pr\_haclose, // Heiken ashi close

pr\_haopen , // Heiken ashi open

pr\_hahigh, // Heiken ashi high

pr\_halow, // Heiken ashi low

pr\_hamedian, // Heiken ashi median

pr\_hatypical, // Heiken ashi typical

pr\_haweighted, // Heiken ashi weighted

pr\_haaverage, // Heiken ashi average

pr\_hamedianb, // Heiken ashi median body

pr\_hatbiased, // Heiken ashi trend biased price

pr\_hatbiased2, // Heiken ashi trend biased (extreme) price

**pr\_zoneclose, // Reference to the closing price of the high and low points of the range ((pr\_close-pr\_lowest)/(pr\_highest-pr\_lowest)\*100)**

**pr\_zonehigh, // Highest point of the interval (iHighest(NULL,0,MODE\_HIGH,9,0))**

**pr\_zonelow, // Lowest point in the range (iLowest(NULL,0,MODE\_LOW,9,0))**

};

input ENUM\_TIMEFRAMES TimeFrame = PERIOD\_CURRENT; // Time frame

input int MacdFast = 12; // Fast period Fast period

input int MacdSlow = 26; // Slow period Slow period

input int MacdSignal = 9; // Signal period // Signal period

input enPrices NemaPrice = pr\_close; // Price

input int NemaDepth = 1; & // NEMA depth nbsp;// NEMA depth

input bool AlertsOn = false; // Turn alerts on?

input bool AlertsOnCurrent = true; // Alert on current bar?

input bool AlertsMessage = true; // Display messageas on alerts?

input bool AlertsSound = false; // Play sound on alerts input bool AlertsSound = false; // Play sound on alerts?

input bool AlertsEmail = false; // Send email on alerts? input bool AlertsEmail = false; // Send email on alerts?

input bool AlertsNotify = false; // Send push notification on Play sound on alerts ?

input bool Interpolate = true; // Interpolate mtf data ?

// Input bool AlertsNotify = false; // Send push notification on alerts.

// Input bool Interpolate = true; // Interpolate mtf data ?

// // The mtf data will be used as the data source for the mtf data.

// //

// // // // // // // // // // // // // // // // // //

double macd[],macdc[],signal[],fillu[],filld[],count[];

int \_mtfHandle = INVALID\_HANDLE; ENUM\_TIMEFRAMES timeFrame.

#define \_mtfCall iCustom(\_Symbol,timeFrame,getIndicatorName(),PERIOD\_CURRENT,MacdFast,MacdSlow,MacdSignal,NemaPrice,NemaDepth. AlertsOn,AlertsOnCurrent,AlertsMessage,AlertsSound,AlertsEmail,AlertsNotify)

**double zonelow[],zonehigh[],zoneclose[];**

**int zonelow\_handle; //--- Customised "interval low price" handler**

**int zonehigh\_handle; //--- Customised "high interval" handler**

**int zoneclose\_handle; //--- Customised "Interval Closing Price" handler**

//------------------------------------------------------------------

// //--- Customised "Interval Closing Price" handler //

//------------------------------------------------------------------

//

//

//

//

//

int OnInit()

{

SetIndexBuffer(0,fillu ,INDICATOR\_DATA);

SetIndexBuffer(1,filld ,INDICATOR\_DATA);

SetIndexBuffer(1,filld ,INDICATOR\_DATA); SetIndexBuffer(2,macd ,INDICATOR\_DATA).

SetIndexBuffer(2,macdc ,INDICATOR\_DATA); SetIndexBuffer(3,macdc ,INDICATOR\_COLOR\_INDEX);

SetIndexBuffer(3,macdc ,INDICATOR\_COLOR\_INDEX); SetIndexBuffer(4,signal ,INDICATOR\_DATA);

SetIndexBuffer(4,signal ,INDICATOR\_DATA); SetIndexBuffer(5,count ,INDICATOR\_CALCULATIONS).

**SetIndexBuffer(5,count ,INDICATOR\_CALCULATIONS); SetIndexBuffer(6,zonelow ,INDICATOR\_DATA);**

**SetIndexBuffer(6,zonelow,INDICATOR\_DATA); SetIndexBuffer(7,zonehigh,INDICATOR\_DATA);**

**SetIndexBuffer(7,zonehigh,INDICATOR\_DATA); SetIndexBuffer(8,zoneclose,INDICATOR\_DATA); timeFrame = MathMax**

timeFrame = MathMax(\_Period,TimeFrame);

IndicatorSetString(INDICATOR\_SHORTNAME,timeFrameToString(timeFrame)+" nema macd ("+(string)MacdFast+ ", "+(string)MacdSlow+ ", "+(string)MacdSignal+", "+(string)NemaDepth+")");");

**zonelow\_handle = iLow(NULL,0,iLowest(NULL,0,MODE\_LOW,9,0));**

**zonehigh\_handle = iHigh(NULL,0,iHighest(NULL,0,MODE\_HIGH,9,0)); zoneclose\_handle = iHigh(NULL,0,iHighest(NULL,0,MODE\_HIGH,9,0))**

**zoneclose\_handle = ((pr\_close-zonelow\_handle)/(zonehigh\_handle-zonelow\_handle))\*100;**

return(0);

}

//------------------------------------------------------------------

//

//------------------------------------------------------------------

//

//

//

//

//

int OnCalculate(const int rates\_total,

const int prev\_calculated,

const datetime& time[],

const double& open[],

const double& high[],

const double& low[],

const double& close[], const long& tick\_volume[], const

const long& tick\_volume[],

const long& volume[],

const int& spread[])

{

**//---Copy the indicator custom "range" value to the indicator buffer**

**int COPY\_RATES\_LOW=CopyBuffer(zonelow\_handle,0,0,rates\_total,zonelow); int COPY\_RATES\_LOW=CopyBuffer(zonelow\_handle,0,0,rates\_total,zonelow)**

**int COPY\_RATES\_HIGH=CopyBuffer(zonehigh\_handle,0,0,rates\_total,zonehigh); int COPY\_RATES\_HIGH=CopyBuffer(zonehigh\_handle,0,0,rates\_total,zonehigh);**

**int COPY\_RATES\_CLOSE=CopyBuffer(zoneclose\_handle,0,0,rates\_total,zoneclose);**

if (Bars(\_Symbol,\_Period)<rates\_total) return(-1);

//

//

//

//

//

if (timeFrame!=\_Period)

{

double result[]; datetime currTime[],nextTime[];

if (!timeFrameCheck(timeFrame,time)) return(0);

if (\_mtfHandle==INVALID\_HANDLE) \_mtfHandle = \_mtfCall;

if (\_mtfHandle==INVALID\_HANDLE) return(0);

if (CopyBuffer(\_mtfHandle,5,0,1,result)==-1) return(0);

//

//

//

return(0); // //

//

#define \_mtfRatio PeriodSeconds(timeFrame)/PeriodSeconds(\_Period)

int i,k,n,limit = MathMin(MathMax(prev\_calculated-1,0),MathMax(rates\_total-(int) result[0]\*\_mtfRatio-1,0));

for (i=limit; i<rates\_total && ! \_StopFlag; i++ )

{

#define \_mtfCopy(\_buff,\_buffNo) if (CopyBuffer(\_mtfHandle,\_buffNo,time[i],1, result)==-1) break; \_buff[i] = result[0]

\_mtfCopy(fillu ,0); filld[i] = 0;

\_mtfCopy(macd ,2).

\_mtfCopy(macdc ,3).

\_mtfCopy(signal ,4).

**\_mtfCopy(signal,4); \_mtfCopy(zonelow,5).**

**\_mtfCopy(zonehigh,6).**

**\_mtfCopy(zoneclose,7).**

//

//

\_mtfCopy(zoneclose,7); // //

//

//

if (!Interpolate) continue; CopyTime(\_Symbol, timeFrame,time[i ],1,currTime).

if (i<(rates\_total-1)) { CopyTime(\_ Symbol,timeFrame,time[i+1],1,nextTime); if (currTime[0]==nextTime[0]) continue; }

for(n=1; (i-n)> 0 && time[i-n] &gt ;= currTime[0]; n++) continue;

for(k=1; (i-k)>=0 && k<n; k++)

{

#define \_mtfInterpolate(\_buff ) \_buff[i-k] = \_buff[i]+(\_buff[i-n]-\_buff[i])\*k/n

\_mtfInterpolate(fillu ).

\_mtfInterpolate(macd ).

\_mtfInterpolate(signal).

**\_mtfInterpolate(signal); \_mtfInterpolate(zoneclose).**

**\_mtfInterpolate(zonehigh); \_mtfInterpolate(signal); \_mtfInterpolate(zoneclose); \_mtfInterpolate(zonehigh)**

**\_mtfInterpolate(zoneclose); \_mtfInterpolate(zonehigh); \_mtfInterpolate(zoneelow);**

} & nbsp;

}

return(i);

}

//

//

//

//

//

int i=(int)MathMax(prev\_calculated-1,0); for (; i<rates\_total && ! \_StopFlag; i++)

{

double price = getPrice(NemaPrice,open,close,high,low,i,rates\_total);

macd[i] = iNema(price,MacdFast,NemaDepth,i,rates\_total,0)-iNema(price,MacdSlow ,NemaDepth,i,rates\_total,1);

signal[i] = iNema(macd[i],MacdSignal ,NemaDepth,i,rates\_total,2);

macdc[i] = (macd[i]>signal[i]) ? 1 : (macd[i]<signal[i]) ? 2 : (i>0) ? macdc[i-1] : 0;

fillu[i] = macd[i]-signal[i];

filld[i] = 0;

}

count[rates\_total-1] = MathMax(rates\_total-prev\_calculated+1,1);

manageAlerts(time,macdc,rates\_total); return(rates\_total); }

return(rates\_total);

}

//------------------------------------------------------------------

//

//------------------------------------------------------------------

//

//

//

//

//

#define \_nemaInstances 3

#define \_nemaInstancesSize 51

#define \_nemcInstancesSize 51

#define \_nema 50

double \_workNema[][\_nemaInstances\*\_nemaInstancesSize].

double \_workNemc[][ \_nemcInstancesSize].

double iNema(double value, double period, int depth, int i, int bars, int instanceNo=0)

{

depth = MathMax(MathMin(depth,\_nemcInstancesSize-1),1);

int cInstance = instanceNo; instanceNo \*= \_nemaInstancesSize;

if (ArrayRange(\_workNema,0) ! = bars) ArrayResize(\_workNema,bars); if (ArrayRange(\_workNema,0) !

if (ArrayRange(\_workNemc,0) < cInstance+1) { ArrayResize(\_workNemc,cInstance+1); \_workNemc[cInstance][0 ]=-1; }

if (\_workNemc[cInstance][0] ! = depth)

{\_workNemc[cInstance][0] = depth; for(int k=1; k<=depth; k++) \_workNemc[cInstance][k] = factorial(depth)/(factorial(depth-k)\*factorial(k)); }

//

//

//

//

//

\_workNema[i][instanceNo+\_nema] = value;

if (period>1)

{

double alpha = 2.0/(1.0+period), sign=1; \_workNema[i][instanceNo+\_nema] = 0;

for (int k=0; k<depth; k++, sign \*= -1)

{

\_workNema[i][instanceNo+k ] = (i>0) ? \_workNema[i-1][instanceNo+k]+alpha\*(value-\_workNema[i-1][instanceNo+k]) : value; value = \_workNema[i][instanceNo+k];

\_workNema[i][instanceNo+\_nema] += value\*sign\*\_workNemc[cInstance][k+1];

}

}

return(\_workNema[i][instanceNo+\_nema]);

}

double factorial(int n) { double a=1; for(int i=1; i<=n; i++) a\*=i; return(a); }

//------------------------------------------------------------------

//

//------------------------------------------------------------------

//

//

//

//

//

//

#define priceInstances 1

**double zoneLow = iLow(NULL,0,iLowest(NULL,0,MODE\_LOW,9,0)); double zoneHigh = iHigh(NULL,0,iHighest(NULL,0,MODE\_HIGH,9,0)); double zoneHigh = iHigh(NULL,0,MODE\_HIGH,9,0))**

**double zoneHigh = iHigh(NULL,0,iHighest(NULL,0,MODE\_HIGH,9,0)); & nbsp;**

**double zoneClose = ((pr\_close-zoneLow)/(zoneHigh-zoneLow))\*100;**

double workHa[][priceInstances\*4]; double getPrice(int t\_close-zoneLow)/(zoneHigh-zoneLow)\*100;

double getPrice(int tprice, const double& open[], const double& close[], const double& high[], const double& low[], int i,int \_bars , int instanceNo=0)

{

if (tprice>=pr\_haclose)

{

if (ArrayRange(workHa,0)! = \_bars) ArrayResize(workHa,\_bars); instanceNo\*=4;

//

//

//

//

//

double haOpen; if (i>0)

if (i>0)

haOpen = (workHa[i-1][instanceNo+2] + workHa[i-1][instanceNo+3])/2.0;

else haOpen = (open[i]+close[i])/2;

double haClose = (open[i] + high[i] + low[i] + close[i]) / 4.0;

double haHigh = MathMax(high[i], MathMax(haOpen,haClose));

double haLow = MathMin(low[i] , MathMin(haOpen,haClose)); double haLow = MathMin(low[i] , MathMin(haOpen,haClose))

if(haOpen < haClose) { workHa[i][instanceNo+0] = haLow; workHa[i][instanceNo+1] = haHigh; }& nbsp; else { workHa[i][instanceNo+1] = haHigh; }

else { workHa[i][instanceNo+0] = haHigh; workHa[i][ instanceNo+1] = haLow; }

workHa[i][instanceNo+2] = haOpen;

workHa[i][instanceNo+3] = haClose;

//

//

//

// //

//

switch (tprice)

{

case pr\_haclose: return(haClose);

case pr\_haclose: return(haClose); case pr\_haopen: return(haOpen); case pr\_hahigh: return(haHigh); case pr\_haclose: return(haHigh); return(haHigh)

case pr\_hahigh: return(haHigh); case pr\_halow: return(haLow); return(haLow); return(haHigh)

case pr\_halow: return(haLow); case pr\_hamedian: return(haHigh); case pr\_halow: return(haHigh)

case pr\_hamedian: return((haHigh+haLow)/2.0);

case pr\_hamedianb: return((haOpen+haClose)/2.0);

case pr\_hatypical: return((haHigh+haLow+haClose)/3.0);

case pr\_haweighted: return((haHigh+haLow+haClose+haClose)/4.0);

case pr\_haaverage: return((haHigh+haLow+haClose+haOpen)/4.0);

case pr\_hatbiased.

if (haClose>haOpen)

return((haHigh+haClose)/2.0); case pr\_hatbiased: if (haClose>haOpen)

else return((haLow+haClose)/2.0);

case pr\_hatbiased2.

if (haClose>haOpen) return(haHigh); case\_hatbiased2.

if (haClose<haOpen) return(haLow); return(haClose)

return(haLow); return(haClose).

**case pr\_zoneclose: return(zoneClose); case pr\_zonehigh: return(zoneClose); if (haClose<haOpen) return(haLow); return(haClose)**

**case pr\_zonehigh: return(zoneHigh); case pr\_zonelow: return(zoneHigh); return(zoneHigh); return(zoneHigh)**

**case pr\_zonelow: return(zoneLow); case pr\_zonelow: return(zoneLow)**

}

}

//

//

//

//

//

switch (tprice)

case pr\_close: return(close[i]); }

case pr\_close: return(close[i]); case pr\_open: return(open[i]); } }

case pr\_open: return(open[i]); case pr\_high: return(high[i]); // switch (tprice) { case pr\_close: return(close[i]); return(open[i])

case pr\_high: return(high[i]); case pr\_low: return(low[i]); case pr[i])

case pr\_low: return(low[i]); case pr\_median: return(low[i])

case pr\_median: return((high[i]+low[i])/2.0); case pr\_medianb: return(high[i]+low[i])/2.0)

case pr\_medianb: return((open[i]+close[i])/2.0);

case pr\_typical: return((high[i]+low[i]+close[i])/3.0); case pr\_weighted: return((high[i]+low[i]+close[i])/3.0)

case pr\_weighted: return((high[i]+low[i]+close[i]+close[i])/4.0);

case pr\_average: return((high[i]+low[i]+close[i]+open[i])/4.0);

case pr\_tbiased.

if (close[i]>open[i])

return((high[i]+close[i])/2.0); case pr\_tbiased.

else return((low[i]+close[i])/2.0); case pr\_tbiased2: if (low[i]+close[i])/2.0)

case pr\_tbiased2.

if (close[i]>open[i]) return(high[i]); case pr\_tbiased2.

if (close[i]<open[i]) return(low[i]);

return(low[i]); return(close[i]) return(close[i]); return(close[i]); return(close[i])

**case pr\_zoneclose: return(zoneclose[i]); return(low[i]); return(close[i]); return(close[i])**

**case pr\_zonehigh: return(zonehigh[i]); case pr\_zonelow: return(zonehigh[i]); return(zonehigh[i])**

**case pr\_zonelow: return(zonelow[i]);**

}

return(0); }

}

//------------------------------------------------------------------

//

//------------------------------------------------------------------

//

//

//

//

//

void manageAlerts(const datetime& atime[], double& atrend[], int bars)

{

if (!AlertsOn) return; return; int whichBar = bars-1; if (!AlertsOnCurrent)

int whichBar = bars-1; if (!AlertsOnCurrent) whichBar = bars-2; datetime time1 = atime[whichBar].

if (atrend[whichBar] ! = atrend[whichBar-1])

{

if (atrend[whichBar] == 1) doAlert(time1, "up"); if (atrend[whichBar] == 1)

if (atrend[whichBar] == 2) doAlert(time1, "down");

}

}

//

//

//

//

//

void doAlert(datetime forTime, string doWhat)

{

static string previousAlert="nothing"; static datetime previousTime; static datetime forTime, string doWhat {

static datetime previousTime; static string previousAlert="nothing"; static datetime previousTime

static string previousAlert="nothing"; static datetime previousTime; string message.

if (previousAlert ! = doWhat || previousTime ! = forTime)

previousAlert = doWhat; message; if (previousAlert !

previousAlert = doWhat; previousTime = forTime; forTime

previousTime = forTime.

//

//

//

previousAlert = doWhat; previousTime = forTime; // //

//

message = timeFrameToString(\_Period)+" "+\_Symbol+" at "+TimeToString(TimeLocal(),TIME\_SECONDS)+" nema macd state changed to "+doWhat;

if (AlertsMessage) Alert(message);

if (AlertsEmail) SendMail(\_Symbol+" nema macd",message); if (AlertsNotify)

if (AlertsNotify) SendNotification(message); if (AlertsSound)

if (AlertsSound) PlaySound("alert2.wav");

}

}

//-------------------------------------------------------------------

//

//-------------------------------------------------------------------

//

//

//

//

//

string getIndicatorName()

{

string path = MQL5InfoString(MQL5\_PROGRAM\_PATH); string data = TerminalInfoString(TERMINAL\_DATA\_PATH)+"\\\MQL5\\\Indicator

string data = TerminalInfoString(TERMINAL\_DATA\_PATH)+"\\\MQL5\\\Indicators\\";

string name = StringSubstr(path,StringLen(data));

return(name);

}

//

//

//

//

//

int \_tfsPer[]={PERIOD\_M1,PERIOD\_M2,PERIOD\_M3,PERIOD\_M4,PERIOD\_M5,PERIOD\_M6,PERIOD\_M10,PERIOD\_M12,PERIOD\_M15,PERIOD\_M20, PERIOD\_M30,PERIOD\_H1,PERIOD\_H2,PERIOD\_H3,PERIOD\_H4,PERIOD\_H6,PERIOD\_H8,PERIOD\_H12,PERIOD\_D1,PERIOD\_W1,PERIOD\_MN1}; string \_tfsStr[]\_tfsStr[]\_tfsStr[]\_tfsStr[]\_tfsString

string \_tfsStr[]={"1 minute", "2 minutes", "3 minutes", "4 minutes", "5 minutes", "6 minutes", "10 minutes", "12 minutes", "15 minutes", "20 minutes", "30 minutes", "1 hour", "2 hours", "3 hours", "4 hours", "6 hours", "8 hours", "12 hours", "daily", "weekly", "monthly"}; }

string timeFrameToString(int period)

{

if (period==PERIOD\_CURRENT)

period = \_Period.

int i; for(i=0;i<ArraySize(\_tfsPer);i++) if (period==\_tfsPer[i]) break;

return(\_tfsStr[i]);

}

//

//

//

//

//

bool timeFrameCheck(ENUM\_TIMEFRAMES \_timeFrame,const datetime& time[])

{

static bool warned=false;

if (time[0]<SeriesInfoInteger(\_Symbol,\_timeFrame,SERIES\_FIRSTDATE))

{

datetime startTime,testTime[];

if (SeriesInfoInteger(\_Symbol,PERIOD\_M1,SERIES\_TERMINAL\_FIRSTDATE,startTime))

if (startTime>0) { CopyTime( \_Symbol,\_timeFrame,time[0],1,testTime); SeriesInfoInteger(\_Symbol,\_timeFrame,SERIES\_FIRSTDATE,startTime); }

if (startTime<=0 || startTime>time[0]) { Comment(MQL5InfoString(MQL5\_PROGRAM\_NAME)+"\nMissing data for "+timeFrameToString(\_timeFrame)+" time frame\nRe-trying on next tick"); warned=true; return(false); }

}

if (warned) { Comment(""); warned=false; }

return(true); }

}

================================================================================================================================== ====================================

Description.

possible loss of data due to type conversion from 'double' to 'int'   Nema\_MACD.mq5   109   21

possible loss of data due to type conversion from 'double' to 'int'   Nema\_MACD.mq5   110   21

code generated

0 errors, 2 warnings, 212 msec elapsed   1   3

==================================================================================

95 int OnInit()

96 {

109 zonelow\_handle = iLow(NULL,0,iLowest(NULL,0,MODE\_LOW,9,0));

110 zonehigh\_handle = iHigh(NULL,0,iHighest(NULL,0,MODE\_HIGH,9,0));

111 zoneclose\_handle = ((pr\_close-zonelow\_handle)/(zonehigh\_handle-zonelow\_handle))\*100;

113  return(0);

114 }

![hxjsjzcn](https://c.mql5.com/avatar/avatar_na2.png "hxjsjzcn")

**[hxjsjzcn](/en/users/hxjsjzcn)**
|
23 Feb 2023 at 18:20

Price\_zoneClose

![Price_zoneClose](https://c.mql5.com/3/401/Price_zoneClose.JPG "Price_zoneClose")

![Adaptive Laguerre filter 2](https://c.mql5.com/i/code/indicator.png)
[Adaptive Laguerre filter 2](/en/code/17151)

The newest version of Adaptive Laguerre filter.

![Smoothed repulse](https://c.mql5.com/i/code/indicator.png)
[Smoothed repulse](/en/code/17158)

This version can use one of the 4 basic averages types for smoothing.

![Nema](https://c.mql5.com/i/code/indicator.png)
[Nema](/en/code/17140)

NEMA - arbitrary depth EMA, DEMA, TEMA... DecEMA ...

![Stochastic RSI (OMA)](https://c.mql5.com/i/code/indicator.png)
[Stochastic RSI (OMA)](/en/code/17167)

Stochastic of 7 possible types of RSI(oma).