# visitor - behavioral design pattern - library for MetaTrader 5

Source: https://www.mql5.com/en/code/32433

* [![](https://c.mql5.com/i/sidebar/mt.svg)MetaTrader 5](/en/code/mt5)
  + [![](https://c.mql5.com/i/sidebar/expert.svg)Experts](/en/code/mt5/experts)
  + [![](https://c.mql5.com/i/sidebar/indicator.svg)Indicators](/en/code/mt5/indicators)
  + [![](https://c.mql5.com/i/sidebar/scripts.svg)Scripts](/en/code/mt5/scripts)
  + [![](https://c.mql5.com/i/sidebar/library.svg)Libraries](/en/code/mt5/libraries)
* [![](https://c.mql5.com/i/sidebar/mt.svg)MetaTrader 4](/en/code/mt4)
  + [![](https://c.mql5.com/i/sidebar/expert.svg)Experts](/en/code/mt4/experts)
  + [![](https://c.mql5.com/i/sidebar/indicator.svg)Indicators](/en/code/mt4/indicators)
  + [![](https://c.mql5.com/i/sidebar/scripts.svg)Scripts](/en/code/mt4/scripts)
  + [![](https://c.mql5.com/i/sidebar/library.svg)Libraries](/en/code/mt4/libraries)

* [![](https://c.mql5.com/i/sidebar/storage.svg)Storage](/en/code/storage)

Watch [how to download](https://youtu.be/rloNyFVtHuA?list=PLltlMLQ7OLeKwyQwC8FhiKwjl9syKhOCK) trading robots for free

Find us on [Twitter](https://x.com/mql5com)!  
 Join our fan page

Interesting script?  
So post a [link](/en/code/32433) to it -  
let others appraise it

You liked the script? Try it in the [MetaTrader 5](https://download.mql5.com/cdn/web/metaquotes.ltd/mt5/mt5setup.exe?utm_source=www.mql5.com&utm_campaign=download) terminal

[to pocket](#pocket "Pocket allows you to insert a complete content description to the appropriate comment")

![Libraries](https://c.mql5.com/i/code/library.png)

# visitor - behavioral design pattern - library for MetaTrader 5

[DMITRII PECHERITSA](/en/users/dmipec)

Views:
:   4297

Rating:
:   (12)

Published:
:   16 December 2020, 08:36
:   [Visitor.mq5](/en/code/download/32433/visitor.mq5 "Visitor.mq5")
    (9.23 KB)
    [view](# "view")

    \MQL5\Include\Mqh\Patterns\Visitor\

    [Element.mqh](/en/code/download/32433/element.mqh "Element.mqh")
    (1.32 KB)
    [view](# "view")

    [ConcreteElementA.mqh](/en/code/download/32433/concreteelementa.mqh "ConcreteElementA.mqh")
    (1.29 KB)
    [view](# "view")

    [ConcreteElementB.mqh](/en/code/download/32433/concreteelementb.mqh "ConcreteElementB.mqh")
    (1.3 KB)
    [view](# "view")

    [Visitor.mqh](/en/code/download/32433/visitor.mqh "Visitor.mqh")
    (0.6 KB)
    [view](# "view")

    [ConcreteVisitor1.mqh](/en/code/download/32433/concretevisitor1.mqh "ConcreteVisitor1.mqh")
    (1.26 KB)
    [view](# "view")

    [ConcreteVisitor2.mqh](/en/code/download/32433/concretevisitor2.mqh "ConcreteVisitor2.mqh")
    (1.25 KB)
    [view](# "view")

    [ObjectStructure.mqh](/en/code/download/32433/objectstructure.mqh "ObjectStructure.mqh")
    (2.64 KB)
    [view](# "view")

    [Download as ZIP](/en/code/download/32433.zip "Download all attachments in the single ZIP archive") [How to download code from MetaEditor](https://www.metatrader5.com/en/metaeditor/help/workspace/toolbox#codebase)

    ![MQL5 - Language of trade strategies built-in the MetaTrader 5 client terminal](https://c.mql5.com/i/registerlandings/logo-2.png)

    You are missing trading opportunities:

    * Free trading apps
    * Over 8,000 signals for copying
    * Economic news for exploring financial markets

    Registration
    Log in

    latin characters without spaces

    a password will be sent to this email

    An error occurred

    * [Log in With Google](https://www.mql5.com/en/auth_oauth2?provider=Google&amp;return=popup&amp;reg=1)

    You agree to [website policy](/en/about/privacy) and [terms of use](/en/about/terms)

    If you do not have an account, please [register](https://www.mql5.com/en/auth_register)

    Allow the use of cookies to log in to the MQL5.com website.

    Please enable the necessary setting in your browser, otherwise you will not be able to log in.

     

    [Forgot your login/password?](https://www.mql5.com/en/auth_forgotten?return=popup)

    * [Log in With Google](https://www.mql5.com/en/auth_oauth2?provider=Google&amp;return=popup)
:   ![MQL5 Freelance](https://c.mql5.com/i/code/icon_freelance.svg)
    Need a robot or indicator based on this code? Order it on Freelance
    [Go to Freelance](/en/job/new "Go to Freelance")

```mql5
//+------------------------------------------------------------------+
//|                                                      Visitor.mq5 |
//|                                    2019-2020, dimitri pecheritsa |
//|                                                 792112@gmail.com |
//+------------------------------------------------------------------+
//
//   visitor - behavioral design pattern
//
//   from: design patterns: elements of reusable object-oriented software
//   by gof: erich gamma, richard helm, ralph johnson, john vlissides
//   published in 1994
//
//   intent
//   
//   represent an operation to be performed on the elements of an object 
//structure. visitor lets you define a new operation without changing 
//the classes of the elements on which it operates.
//
//   applicability
//
//   use the visitor pattern when
//      an object structure contains many classes of objects with differing 
//interfaces, and you want to perform operations on these objects that 
//depend on their concrete classes.
//      many distinct and unrelated operations need to be performed on 
//objects in an object structure, and you want to avoid "polluting" their 
//classes with these operations. visitor lets you keep related operations 
//together by defining them in one class. when the object structure is 
//shared by many applications, use visitor to put operations in just those 
//applications that need them.
//      the classes defining the object structure rarely change, but you 
//often want to define new operations over the structure. changing the 
//object structure classes requires redefining the interface to all visitors, 
//which is potentially costly. if the object structure classes change 
//often, then it's probably better to define the operations in those classes.
//
//   structure
//
//|Client|---------->|                Visitor                |
//   |               |---------------------------------------|
//   |               |VisitConcreteElementA(ConcreteElementA)|
//   |               |VisitConcreteElementB(ConcreteElementB)|
//   |                                  ^
//   |                                  |
//   |                  +---------------+---------------+
//   |                  |                               |
//   |       |   ConcreteVisitor1    |     |    ConcreteVisitor2   |
//   |       |---------------------- |     |-----------------------|
//   |       |VisitConcreteElementA( |     |VisitConcreteElementA( |
//   |       | ConcreteElementA)     |     | ConcreteElementA)     |
//   |       |VisitConcreteElementB( |     |VisitConcreteElementB( |
//   |       | ConcreteElementB)     |     | ConcreteElementB)     |
//   |
//   |
//   +--->|ObjectStructure|--->*|    Element    |
//                              |---------------|
//                              |Accept(Visitor)|
//                                      ^
//                                      |
//                   +------------------+------------------+
//                   |                                     |
//    |       ConcreteElementA       |     |       ConcreteElementB       |
//    |------------------------------|     |------------------------------|
//    |Accept(Visitor)               |     |Accept(Visitor)               |
//    | v.VisitConcreteElementA(this)|     | v.VisitConcreteElementB(this)|
//    |OperationA()                  |     |OperationB()                  |
//
//
//   participants
//
//   visitor 
//      declares a visit operation for each class of concrete element 
//in the object structure. the operation's name and signature identifies 
//the class that sends the visit request to the visitor. that lets the 
//visitor determine the concrete class of the element being visited. then 
//the visitor can access the element directly through its particular interface.
//   concrete visitor 
//      implements each operation declared by visitor. each operation 
//implements a fragment of the algorithm defined for the corresponding 
//class of object in the structure. concrete visitor provides the context 
//for the algorithm and stores its local state. this state often accumulates 
//results during the traversal of the structure.
//   element 
//      defines an accept operation that takes a visitor as an argument.
//   concrete element 
//      implements an accept operation that takes a visitor as an argument.
//   object structure 
//      can enumerate its elements.
//      may provide a high-level interface to allow the visitor to visit 
//its elements.
//      may either be a composite or a collection such as a list or a set.
//
//   collaborations
//
//   a client that uses the visitor pattern must create a concrete visitor 
//object and then traverse the object structure, visiting each element 
//with the visitor.
//   when an element is visited, it calls the visitor operation that corresponds 
//to its class. the element supplies itself as an argument to this operation 
//to let the visitor access its state, if necessary.
//   the following interaction diagram illustrates the collaborations 
//between an object structure, a visitor, and two elements:
//   
//   anObject        aConcreteElementA   aConcreteElementB      aConcreteVisitor
//   Structure              |                   |                      |
//      |                   |                   |                      |
//     | |Accept(aVisitor)  |                   |                      |
//     | |---------------->| |VisitConcreteElementA(aConcreteElementA) | 
//     | |                 | |------------------|-------------------->| |
//     | |                  |                   |                     | |
//     | |                 | |<-----------------|---------------------| |
//     | |Accept(aVisitor)  |                   |                      |
//     | |------------------|----------------->| |VisitConcrete        | 
//     | |                  |                  | | ElementB(aConcrete | |
//     | |                  |                  | | ElementB)          | |
//     | |                  |                  | |------------------->| |
//     | |                  |                   |                     | |
//     | |                  |                  | |<-------------------| |
//      |                   |                   |                      |
//
//+------------------------------------------------------------------+
//|                                              example of a client |
//+------------------------------------------------------------------+
#include <Mqh\Patterns\Visitor\ObjectStructure.mqh>
#include <Mqh\Patterns\Visitor\Element.mqh>
#include <Mqh\Patterns\Visitor\ConcreteElementA.mqh>
#include <Mqh\Patterns\Visitor\ConcreteElementB.mqh>
#include <Mqh\Patterns\Visitor\Visitor.mqh>
#include <Mqh\Patterns\Visitor\ConcreteVisitor1.mqh>
#include <Mqh\Patterns\Visitor\ConcreteVisitor2.mqh>
void OnStart()
  {
   ObjectStructure structure;
   structure.Add(new ConcreteElementA());
   structure.Add(new ConcreteElementB());
   structure.Accept(new ConcreteVisitor1());
   structure.Accept(new ConcreteVisitor2());
  }
//   output
//
//   element 2097152 added to the object structure
//   element 3145728 added to the object structure
//   
//   object structure has accepted new visitor 4194304
//   object structure has 2 elements
//   object structure is requesting each element to accept the visitor
//   element a has accepted the visitor
//   the element made operation a
//   element b has accepted the visitor
//   the element made operation b
//
//   object structure has accepted new visitor 5242880
//   object structure has 2 elements
//   object structure is requesting each element to accept the visitor
//   element a has accepted the visitor
//   the element made operation a
//   element b has accepted the visitor
//   the element made operation b
//   
//
//   consequences
//
//   some of the benefits and liabilities of the visitor pattern are as 
//follows:
//      visitor makes adding new operations easy
//      a visitor gathers related operations and separates unrelated ones
//      adding new concrete element classes is hard
//      visiting across class hierarchies
//      accumulating state
//      breaking encapsulation
//
//   implementation
//
//   each object structure will have an associated visitor class. this 
//abstract visitor class declares a visit concrete element operation for 
//each class of concrete element defining the object structure. each visit 
//operation on the visitor declares its argument to be a particular concrete 
//element, allowing the visitor to access the interface of the concrete 
//element directly. concrete visitor classes override each visit operation 
//to implement visitor-specific behavior for the corresponding concrete 
//element class.
//   here are two other implementation issues that arise when you apply 
//the visitor pattern:
//      double dispatch
//      who is responsible for traversing the object structure? 
//
//   related patterns
//
//   composite: visitors can be used to apply an operation over an object 
//structure defined by the composite pattern.
//   interpreter: visitor may be applied to do the interpretation.
//
//+------------------------------------------------------------------+
```

**[Go to discussion](/en/forum/358110)**

![template method - behavioral design pattern](https://c.mql5.com/i/code/library.png)
[template method - behavioral design pattern](/en/code/32381)

define the skeleton of an algorithm in an operation, deferring some steps to subclasses. template method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure

![Print Closed Position](https://c.mql5.com/i/code/script.png)
[Print Closed Position](/en/code/32330)

Print info about a closed position by its position ticket or identifier.

![Basic Martingale EA v3](https://c.mql5.com/i/code/expert.png)
[Basic Martingale EA v3](/en/code/32521)

A Sample of Averaging Up/Down Martingale EA.

![Classic Moving Averages with colors](https://c.mql5.com/i/code/indicator.png)
[Classic Moving Averages with colors](/en/code/32558)

The indicator displays a colored moving average.