// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © SAB

//@version=6
indicator("Ai Predictor [SAB]", shorttitle = "Ai Predictor [SAB]", overlay = true)

// Input Groups
group_calc = "Calculation Parameters"
group_appearance = "Appearance Settings"
group_alerts = "Alert Conditions"

// Inputs with Tooltips
n = input.int(12, title="Lookback Period", minval=1, group=group_calc, 
     tooltip="Number of historical price points to analyze for trend intensity. Higher values provide more comprehensive trend analysis.")

p = input.int(90, title="Range Tolerance", minval=0, maxval=100, group=group_calc, 
     tooltip="Percentage threshold for determining trend strength. Higher values require more consistent trend alignment.")

linreg_source = input.source(close, title="Linear Regression Source", group=group_calc, 
     tooltip="Price source used for calculating the linear regression trend.")

linreg_length = input.int(90, title="Linear Regression Length", minval=1, group=group_calc, 
     tooltip="Number of bars used to calculate the linear regression line. Longer lengths provide a more comprehensive trend view.")

green = input.color(color.rgb(25, 0, 255), title="Bullish Color", group=group_appearance, 
     tooltip="Color representing a strong bullish trend")

red = input.color(color.rgb(166, 255, 0), title="Bearish Color", group=group_appearance, 
     tooltip="Color representing a strong bearish trend")

// Linear Regression Calculation
vvv = ta.linreg(linreg_source, linreg_length, 0)

// Trend Calculation
trend777 = 0  

for i = 0 to n - 2 
    for j = i + 1 to n - 1
        if vvv[i] != vvv[j] 
            trend777 := trend777 + (vvv[i] > vvv[j] ? 1 : -1) 

totalcombos = (n*(n-1))/2

thresh = totalcombos*(p/100)

state = trend777 > thresh ? 1 : trend777 < -thresh ? -1 : 0

volatility777 = ta.atr(14)

// Dynamic Label with Intensity Visualization
//label.new(bar_index, close > v ? v - volatility : v + volatility, style = label.style_none, textcolor = color.from_gradient(math.abs(trend)/totalcombos, 0, 1, color.new(trend > 0 ? green : red, 90), color.new(trend > 0 ? green : red, 30)), text = math.abs(trend) == totalcombos ? str.tostring(math.abs(trend)/totalcombos, "#.000000") : str.tostring(math.abs(trend)/totalcombos, "#.######"), force_overlay = true)

// Bar Coloring
//barcolor(state == 0 ? color.gray : state == 1 ? green : red, title="Trend State Bar Color")
// Dynamic Line Plot with Color Change Based on Trend
line_color = state == 0 ? color.gray : state == 1 ? green : red
plot(vvv, color=line_color, linewidth=1, title="Linear Regression Line")

// === Parameters, variabels, constants and definitions
//@enum     Defines various dictionary input types
enum dict_input
    crange = "crange"
    body = "body"
    wick_low = "wick_low"
    wick_high = "wick_high"

//@enum     Defines various historical inputs
enum hist_input
    hhigh = "hhigh"
    hlow = "hlow"

//@enum     Defines kNN weighting
enum knn_weighting
    distance = "distance"
    average = "average"

src = input.source(close, "Primary prediction target", tooltip = 'Primary prediction target', group = 'General settings')
N   = input.int(20, "Pattern lenght", minval=4, step=1, tooltip = "How many bars of data to use to construct patterns", group = 'General Settings')
ND  = input.int(5, "Dictionary size", minval=1, step=1, tooltip = "How many patterns to store in the reference dictionary", group = 'General Settings')
NY  = input.int(2, "Prediction horizon", minval=1, maxval=100, step=1, tooltip = "The horizon (in bars) of the prediction", group = 'General Settings')
ema_n = input.int(14, "Smoothing lookback", minval=2, step=1, tooltip = "How many bars of data to use to smooth prediction target", group = 'General Settings')

n_neighbors = input.int(2, "# of neighbors", minval=1, maxval=32, step=1, tooltip = "How many nearest neighbors to consider", group = 'kNN')
atr_n    = 100// input.int(10, "ATR lookback", minval=1, step=1, tooltip = "Lookback for ATR bands, used to normalize patterns by volatility", group = 'kNN')
atr_mult = input.float(2.0, "ATR multiplier", minval=.1, step=.1, tooltip = "ATR bands multiplier", group = 'kNN')
selected_knn_weighting = knn_weighting.distance//input.enum(knn_weighting.distance, "kNN weighting function", tooltip = "Defines how nearest neighbor contribute to the prediction", group = 'kNN')
prediction_filter_n    = input.int(5, "EMA Prediction filter", minval=2, step=1, tooltip = "Lookback for smoothing of prediction, set to 0 to disable", group = 'kNN')
lookback_n = input.int(30, "Regime bands lookback", minval=5, step=1, tooltip = "How many bars of data to use to calculate regime bands", group = 'Additional Settings')

pos_col = input.color(color.rgb(175, 255, 105, 0), title="", group="Style", inline="Style")
neg_col = input.color(color.rgb(255, 71, 80, 0), title="",group="Style", inline="Style")

// Dictionaries
var Y = array.new<float>()
var D = matrix.new<float>()
var D2 = matrix.new<float>()
var D3 = matrix.new<float>()
var D4 = matrix.new<float>()
var H = matrix.new<float>()
var L = matrix.new<float>()

// Variables and constants
y_src = ta.ema(src, ema_n)
N_total = NY + N
atr_bands = ta.atr(atr_n)
var float conf = na
var float nearest_neighbor = na
var int  n_bars = 0
var int  n_up = int(na)
var int  n_dn = int(na)
var float l_min = float(na)
var float h_max = float(na)
var float m_mid = float(na)
var bool Y_hat_trend = false

// Lines
var float Y_hat = na
var float Y_hat_line = na
var float Y_hat_bands = na
var float Y_hat_smooth = na
var line reg_lu = line(na)
var line reg_ll = line(na) 
var line reg_lm = line(na)

// === Functions
update_dictionary(D, input_type) =>
    x = array.new<float>(N_total)

    for i = 0 to N_total-1
        if input_type == dict_input.body
            array.set(x, -(i+1), close[i]-open[i])
        else if input_type == dict_input.crange
            array.set(x, -(i+1), high[i]-low[i])
        else if input_type == dict_input.wick_low
            array.set(x, -(i+1), math.min(close[i], open[i])-low[i])
        else if input_type == dict_input.wick_high
            array.set(x, -(i+1), high[i]-math.max(close[i], open[i]))

    x_current = array.slice(x, N_total-N, N_total)
    x_prev = array.slice(x, 0, N)
    
    x_current_normed = matrix.new<float>(1, array.size(x_current), 0.0)
    for i = 0 to array.size(x_current)-1
        matrix.set(x_current_normed, 0, i, array.get(x_current, i)/atr_bands)

    x_prev_normed = array.new<float>(array.size(x_prev), 0.0)
    for i = 0 to array.size(x_prev)-1
        array.set(x_prev_normed, i, array.get(x_prev, i)/atr_bands)

    // add to dictionaries
    if D.rows() >= ND
        D.remove_row(0)
    
    D.add_row(D.rows(), x_prev_normed)
    x_current_normed

update_historical(D, input_type) =>
    x = array.new<float>(N_total)

    for i = 0 to N_total-1
        if input_type == hist_input.hhigh
            array.set(x, -(i+1), high[i])
        else
            array.set(x, -(i+1), low[i])

    x_seg = array.slice(x, 0, N)
    
    if D.rows() >= ND
        D.remove_row(0)
    
    D.add_row(D.rows(), x_seg)

run_query(x1, x2, x3, x4, D1, D2, D3, D4) =>
    dist = array.new<float>(D1.rows(), 0.0)
    for i = 0 to D1.rows()-1
        sum = 0.0
        diff1 = x1.diff(D1.submatrix(i, i+1)).row(0)
        diff2 = x2.diff(D2.submatrix(i, i+1)).row(0)
        diff3 = x3.diff(D3.submatrix(i, i+1)).row(0)
        diff4 = x4.diff(D4.submatrix(i, i+1)).row(0)
        for j = 0 to N-1
            sum += math.pow(diff1.get(j), 2) * .25 + math.pow(diff2.get(j), 2) * .25 + math.pow(diff3.get(j), 2) * .25 + math.pow(diff4.get(j), 2) * .25
        dist.set(i, math.sqrt(sum))
    dist

kNN(dist, n_neighbors, weighting_type) =>
    idx = dist.sort_indices()
    dist_sum = 0.0
    up_count = 0
    down_count = 0
    n = math.min(n_neighbors, idx.size())
    for i = 0 to n-1
        dist_sum += dist.get(idx.get(i))
        if Y.get(idx.get(i)) > 0
            up_count += 1
        else
            down_count += 1
    avg = 0.0
    if weighting_type == knn_weighting.distance
        for i = 0 to n-1
            avg += Y.get(idx.get(i))*(n > 1 ? (1-(dist.get(idx.get(i))/dist_sum)) : 1)
    else if weighting_type == knn_weighting.average
        for i = 0 to n-1
            avg += Y.get(idx.get(i))
        avg /= n
    [avg, math.max(up_count, down_count) / n, idx.get(0)]

if barstate.isconfirmed and bar_index > N_total
    y = math.log(y_src[0])-math.log(y_src[NY])

    // Update dictionaries
    x_body = update_dictionary(D, dict_input.body)
    x_range = update_dictionary(D2, dict_input.crange)
    x_wick_low = update_dictionary(D3, dict_input.wick_low)
    x_wick_high = update_dictionary(D4, dict_input.wick_high)

    // Update historical records
    update_historical(H, hist_input.hhigh)
    update_historical(L, hist_input.hlow)

    // Update labels
    if Y.size() >= ND
        Y.shift()
    
    Y.push(y)

    // run query
    dist = run_query(x_body, x_range, x_wick_low, x_wick_high, D, D2, D3, D4)

    // get knn prediction
    [avg, confidence, nearest] = kNN(dist, n_neighbors, selected_knn_weighting)

    Y_hat := avg
    conf := confidence
    nearest_neighbor := nearest
    Y_hat_line := y_src + (y_src*(math.exp(avg)-1))

if not na(Y_hat)
    Y_hat_smooth := prediction_filter_n > 0 ? ta.ema(Y_hat, prediction_filter_n) : Y_hat

// Band calculation
// === Setup band calculation
ref_high = Y_hat_line + atr_mult*atr_bands
ref_low = Y_hat_line - atr_mult*atr_bands

hh = ta.highest(ref_high, lookback_n)
ll = ta.lowest(ref_low, lookback_n)

if hh == ref_high
    Y_hat_trend := true

if ll == ref_low 
    Y_hat_trend := false

if Y_hat_trend
    n_bars += 1

if not Y_hat_trend
    n_bars += 1

if ta.change(Y_hat_trend)
    n_bars := 1
    n_up := 0
    n_dn := 0

h_max := ta.highest(ref_high, n_bars)
l_min := ta.lowest(ref_low, n_bars)
m_mid := math.avg(h_max, l_min)

if n_bars == 1 
    h_max := na
    l_min := na
    m_mid := na

if barstate.islast

    // delete all previous lines and boxes
    all_lines = line.all.copy()
    if all_lines.size() > 0
        for i = 0 to all_lines.size()-1
            line.delete(array.get(all_lines, i))

    all_boxes = box.all.copy()
    if all_boxes.size() > 0
        for i = 0 to all_boxes.size()-1
            box.delete(array.get(all_boxes, i))

    nearest_idx = int(math.min(nearest_neighbor + 5, ND - 5))
    pattern_high = H.row(nearest_idx)
    pattern_low = L.row(nearest_idx)

    // Arrays to store bar high and low points
    float[] bar_highs = array.new_float(0)
    float[] bar_lows = array.new_float(0)

    for i = 1 to pattern_high.size()-1
        float bar_high = (pattern_high.get(i)/pattern_high.get(0))*high
        float bar_low = (pattern_low.get(i)/pattern_low.get(0))*low

        // Store bar high and low points
        array.push(bar_highs, bar_high)
        array.push(bar_lows, bar_low)

    // Find the highest and lowest points
    float highest_point = array.max(bar_highs)
    float lowest_point = array.min(bar_lows)

    // Plot top, bottom, and middle sloped lines
    line.new(x1=bar_index, y1=highest_point, x2=bar_index + array.size(bar_highs) - 1, y2=highest_point, color=color.new(pos_col,0), style=line.style_solid, extend=extend.right, width = 1)
    line.new(x1=bar_index, y1=(highest_point + lowest_point) / 2, x2=bar_index + array.size(bar_lows) - 1, y2=(highest_point + lowest_point) / 2, color=color.new(chart.fg_color,30), style=line.style_solid, extend=extend.right, width = 1)
    line.new(x1=bar_index, y1=lowest_point, x2=bar_index + array.size(bar_lows) - 1, y2=lowest_point, color=color.new(neg_col,0), style=line.style_solid, extend=extend.right, width = 1)

    // Calculate and plot the slope line
    float first_high = array.get(bar_highs, 0)
    float first_low = array.get(bar_lows, 0)
    float last_high = array.get(bar_highs, array.size(bar_highs) - 1)
    float last_low = array.get(bar_lows, array.size(bar_lows) - 1)
    box_color = last_low < first_low ? color.new(neg_col,0) : color.new(pos_col,0)    

    if last_low < first_low
        line.new(x1=bar_index, y1=highest_point, x2=bar_index + array.size(bar_highs) - 1, y2=lowest_point, color=box_color, style=line.style_arrow_right, width = 2)
    else
        line.new(x1=bar_index, y1=first_low, x2=bar_index + array.size(bar_lows) - 1, y2=last_high, color=box_color, style=line.style_arrow_right, width = 2)

    for i = 1 to pattern_high.size()-1
        float bar_high = (pattern_high.get(i)/pattern_high.get(0))*high
        float bar_low = (pattern_low.get(i)/pattern_low.get(0))*low

        box.new(bar_index + (i-1), bar_high, bar_index + i, bar_low, border_style=line.style_dashed, bgcolor=na, border_color=box_color)

// === Plotting
min_transparency = 60
max_transparency = 80

plot_l = plot(l_min, color = neg_col, style = plot.style_linebr, title="Min")
plot_h = plot(h_max, color = pos_col, style = plot.style_linebr, title="Max")
plot_m = plot(m_mid, color = bar_index % 3 == 0 ? chart.fg_color : na , style = plot.style_linebr, title="Mid")

fill(plot_m, plot_h, h_max, m_mid, color.new(pos_col, 90), na)
fill(plot_m, plot_l, m_mid, l_min, na, color.new(neg_col, 90))

plot(Y_hat_line, title="Predicted value of the primary target", color=Y_hat_smooth >= 0?color.new(pos_col,20) : color.new(neg_col,20))

// Trend Labels
if (Y_hat_trend and not Y_hat_trend[1]) 
    label.new(bar_index, ref_low, "up", color = pos_col, style = label.style_triangleup)

if (Y_hat_trend[1] and not Y_hat_trend)
    label.new(bar_index, ref_high, "down", color = neg_col, style = label.style_triangledown)

priceSource = input.source(close, 'Price Source', group = 'Volatility Trend Bands [UAlgo] Settings')
atrLength = input.int(14, 'ATR Length', group = 'Volatility Trend Bands [UAlgo] Settings')
atrMultiplier = input.float(5, 'ATR Multiplier', step = 0.1, group = 'Volatility Trend Bands [UAlgo] Settings')
enableColorBars = input.bool(true, 'Enable Bar Colors', group = 'Volatility Trend Bands [UAlgo] Settings')
enableLabels = input.bool(false, 'Show Signals', group = 'Volatility Trend Bands [UAlgo] Settings')
bullishColor = input.color(#88e220, 'Bullish/Bearish Color', group = 'Volatility Trend Bands [UAlgo] Settings', inline = 'color')
bearishColor = input.color(#ff2e3f, ' ', group = 'Volatility Trend Bands [UAlgo] Settings', inline = 'color')
atrDelta = atrMultiplier * ta.atr(atrLength)

getVolatilityBands(float priceSource, float atrDelta) =>
    float upperBand = 0.0
    float lowerBand = 0.0

    upperBand := nz(upperBand[1])
    lowerBand := nz(lowerBand[1])

    if priceSource > nz(upperBand[1])
        upperBand := math.max(nz(upperBand[1]), math.max(priceSource, nz(priceSource[1])))
        lowerBand := upperBand - atrDelta
        if lowerBand < nz(lowerBand[1]) or lowerBand > nz(lowerBand[1]) and upperBand == nz(upperBand[1])
            lowerBand := nz(lowerBand[1])
            lowerBand
    else if priceSource < nz(lowerBand[1])
        lowerBand := math.min(nz(lowerBand[1]), math.min(priceSource, nz(priceSource[1])))
        upperBand := lowerBand + atrDelta
        if upperBand > nz(upperBand[1]) or upperBand < nz(upperBand[1]) and lowerBand == nz(lowerBand[1])
            upperBand := nz(upperBand[1])
            upperBand

    midBand = (lowerBand + upperBand) / 2
    [midBand, upperBand, lowerBand]

[midBand, upperBand, lowerBand] = getVolatilityBands(priceSource, atrDelta)

isTrendUp = midBand > nz(midBand[1])
isTrendDown = midBand < nz(midBand[1])

lastTrendState = 0
lastTrendState := nz(lastTrendState[1])
lastTrendState := isTrendUp ? 1 : isTrendDown ? -1 : nz(lastTrendState[1])

buySignal = isTrendUp and nz(lastTrendState[1]) == -1
sellSignal = isTrendDown and nz(lastTrendState[1]) == 1

var color trendColor = na
trendColor := midBand < nz(midBand[1]) ? bearishColor : midBand > nz(midBand[1]) ? bullishColor : nz(trendColor[1])

barcolor(enableColorBars ? trendColor : na)

plot(upperBand, 'Upper Band', color = trendColor, linewidth = 2)
plot(lowerBand, 'Lower Band', color = trendColor, linewidth = 2)

atrSignalOffset = ta.atr(10) * 0.5

if enableLabels and buySignal
    label.new(x = bar_index, y = low - atrSignalOffset, xloc = xloc.bar_index, text = '▲', style = label.style_label_up, color = bullishColor, size = size.normal, textcolor = color.white, textalign = text.align_center)
else if enableLabels and sellSignal
    label.new(x = bar_index, y = high + atrSignalOffset, xloc = xloc.bar_index, text = '▼', style = label.style_label_down, color = bearishColor, size = size.normal, textcolor = color.white, textalign = text.align_center)

alertcondition(buySignal, title = 'Buy Signal', message = 'Volatility Trend Bands [UAlgo]: Buy\nSymbol: {{ticker}}\nPrice: {{close}}')
alertcondition(sellSignal, title = 'Sell Signal', message = 'Volatility Trend Bands [UAlgo]: Sell\nSymbol: {{ticker}}\nPrice: {{close}}')
alertcondition(state == 1, title="Bullish Trend Confirmed", message="Strong Bullish Trend Detected")
alertcondition(state == -1, title="Bearish Trend Confirmed", message="Strong Bearish Trend Detected")
alertcondition(state == 0, title="Trend Neutrality", message="Trend Intensity Reached Neutral Zone")