//@version=5
VERSION  = ' V6_1_24'
strategy('<[ALGOX_HRSI V6_1_24]>', shorttitle = '🚀〄 ALGO EXTREMEP Profit Crypto HRSI 〄🚀'+ VERSION, overlay = true, explicit_plot_zorder = true, pyramiding = 0, default_qty_type = strategy.percent_of_equity, initial_capital = 1000, max_bars_back=1000, default_qty_value = 1, calc_on_every_tick = true, process_orders_on_close = true)

//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//$                                                                                 $
//$ Gratitude is appreciated!                                                       $
//$ You may donate via:                                                             $
//$                                                                                 $
//$ Crypto-multi-currency wallet                                                    $
//$ https://tinyurl.com/4f9dr9nw                                                    $
//$                                                                                 $
//$    - BTC: 1EpDN7pg1WqURcK7te5kQtgx3H17wuHiV7                                    $
//$                                                                                 $
//$    - LTC: MJyEtVt7EFmA18Bo1vjRMbguivHnVbbWvp                                    $
//$                                                                                 $
//$ - Tether TRC20 (USDT): TWQdh36osEJ3mDrG7kGEHgSVHQSgSR61ZY                       $
//$                                                                                 $
//$ Donate as much as you see fit.                                                  $
//$ Do it if you find the stuff useful!                                             $
//$ Disclaimer: I am not a financial advisor.                                       $
//$ For purpose educate only. Use at your own risk.                                 $
//$                                                                                 $
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

G_SCRIPT01   = '■ ' + 'SAIYAN OCC'
//#region ———— <↓↓↓ G_SCRIPT01 ↓↓↓> {

// === INPUTS ===
res                       = input.timeframe('15',  'TIMEFRAME', group ="NON REPAINT")
useRes                    = input(true,            'Use Alternate Signals')
intRes                    = input(10,               'Multiplier for Alernate Signals')
basisType                 = input.string('ALMA',   'MA Type: ', options=['TEMA', 'HullMA', 'ALMA'])
basisLen                  = input.int(50,           'MA Period', minval=1)
offsetSigma               = input.int(5,           'Offset for LSMA / Sigma for ALMA', minval=0)
offsetALMA                = input.float(2,      'Offset for ALMA', minval=0, step=0.01)
scolor                    = input(false,           'Show coloured Bars to indicate Trend?')
delayOffset               = input.int(0,           'Delay Open/Close MA', minval=0, step=1,
                  tooltip = 'Forces Non-Repainting')
tradeType                 = input.string('BOTH',   'What trades should be taken : ',
                  options = ['LONG', 'SHORT', 'BOTH', 'NONE'])
//=== /INPUTS ===
h                         = input(false,           'Signals for Heikin Ashi Candles')
//INDICATOR SETTINGS
swing_length              = input.int(10,          'Swing High/Low Length', group = 'Settings', minval = 1, maxval = 50)
history_of_demand_to_keep = input.int(20,          'History To Keep', minval = 5, maxval = 50)
box_width                 = input.float(2.5,       'Supply/Demand Box Width', group = 'Settings', minval = 1, maxval = 10, step = 0.5)

//INDICATOR VISUAL SETTINGS
show_zigzag               = input.bool(false,      'Show Zig Zag', group = 'Visual Settings', inline = '1')
show_price_action_labels  = input.bool(false,      'Show Price Action Labels', group = 'Visual Settings', inline = '2')

supply_color              = input.color(#00000000, 'Supply', group = 'Visual Settings', inline = '3')
supply_outline_color      = input.color(#00000000, 'Outline', group = 'Visual Settings', inline = '3')

demand_color              = input.color(#00000000, 'Demand', group = 'Visual Settings', inline = '4')
demand_outline_color      = input.color(#00000000, 'Outline', group = 'Visual Settings', inline = '4')

bos_label_color           = input.color(#00000000, 'BOS Label', group = 'Visual Settings', inline = '5')
poi_label_color           = input.color(#00000000, 'POI Label', group = 'Visual Settings', inline = '7')
poi_border_color          = input.color(#00000000, 'POI border', group = 'Visual Settings', inline = '7')
swing_type_color          = input.color(#00000000, 'Price Action Label', group = 'Visual Settings', inline = '8')
zigzag_color              = input.color(#00000000, 'Zig Zag', group = 'Visual Settings', inline = '9')

//END SETTINGS

//      FUNCTION TO ADD NEW AND REMOVE LAST IN ARRAY
f_array_add_pop(array, new_value_to_add) =>
    array.unshift(array, new_value_to_add)
    array.pop(array)

//      FUNCTION SWING H & L LABELS
f_sh_sl_labels(array, swing_type) =>

    var string label_text = na
    if swing_type == 1
        if array.get(array, 0) >= array.get(array, 1)
            label_text := 'HH'
        else
            label_text := 'LH'
        label.new(
          bar_index - swing_length,
          array.get(array,0),
          text = label_text,
          style = label.style_label_down,
          textcolor = swing_type_color,
          color = swing_type_color,
          size = size.tiny)
    
    else if swing_type == -1
        if array.get(array, 0) >= array.get(array, 1)
            label_text := 'HL'
        else
            label_text := 'LL'
        label.new(
          bar_index - swing_length,
          array.get(array,0),
          text = label_text,
          style = label.style_label_up,
          textcolor = swing_type_color,
          color = swing_type_color,
          size = size.tiny)

//      FUNCTION MAKE SURE SUPPLY ISNT OVERLAPPING
f_check_overlapping(new_poi, box_array, atrValue) =>

    atr_threshold = atrValue * 2
    okay_to_draw = true

    for i = 0 to array.size(box_array) - 1
        top = box.get_top(array.get(box_array, i))
        bottom = box.get_bottom(array.get(box_array, i))
        poi = (top + bottom) / 2

        upper_boundary = poi + atr_threshold
        lower_boundary = poi - atr_threshold

        if new_poi >= lower_boundary and new_poi <= upper_boundary
            okay_to_draw := false
            break
        else 
            okay_to_draw := true
    okay_to_draw

//      FUNCTION TO DRAW SUPPLY OR DEMAND ZONE
f_supply_demand(value_array, bn_array, box_array, label_array, box_type, atrValue) =>
    atr_buffer = atrValue * (box_width / 10)
    box_left   = array.get(bn_array, 0)
    box_right  = bar_index
    var float box_top = 0.00
    var float box_bottom = 0.00
    var float poi = 0.00
    if box_type == 1
        box_top := array.get(value_array, 0)
        box_bottom := box_top - atr_buffer
        poi := (box_top + box_bottom) / 2
    else if box_type == -1
        box_bottom := array.get(value_array, 0)
        box_top := box_bottom + atr_buffer
        poi := (box_top + box_bottom) / 2
    okay_to_draw = f_check_overlapping(poi, box_array, atrValue)
    // okay_to_draw = true
    //delete oldest box, and then create a new box and add it to the array
    if box_type == 1 and okay_to_draw
        box.delete( array.get(box_array, array.size(box_array) - 1) )
        f_array_add_pop(box_array, box.new( left = box_left, top = box_top, right = box_right, bottom = box_bottom, border_color = supply_outline_color,
             bgcolor = supply_color, extend = extend.right, text = 'SUPPLY', text_halign = text.align_center, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small, xloc = xloc.bar_index))
        
        box.delete( array.get(label_array, array.size(label_array) - 1) )
        f_array_add_pop(label_array, box.new( left = box_left, top = poi, right = box_right, bottom = poi, border_color = poi_border_color,
             bgcolor = poi_border_color, extend = extend.right, text = 'POI', text_halign = text.align_left, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small, xloc = xloc.bar_index))
    else if box_type == -1 and okay_to_draw
        box.delete( array.get(box_array, array.size(box_array) - 1) )
        f_array_add_pop(box_array, box.new( left = box_left, top = box_top, right = box_right, bottom = box_bottom, border_color = demand_outline_color,
             bgcolor = demand_color, extend = extend.right,  text = 'DEMAND', text_halign = text.align_center, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small, xloc = xloc.bar_index))
        
        box.delete( array.get(label_array, array.size(label_array) - 1) )
        f_array_add_pop(label_array, box.new( left = box_left, top = poi, right = box_right, bottom = poi, border_color = poi_border_color,
             bgcolor = poi_border_color, extend = extend.right,  text = 'POI', text_halign = text.align_left, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small, xloc = xloc.bar_index))

//      FUNCTION TO CHANGE SUPPLY/DEMAND TO A BOS IF BROKEN
f_sd_to_bos(box_array, bos_array, label_array, zone_type) =>

    if zone_type == 1
        for i = 0 to array.size(box_array) - 1
            level_to_break = box.get_top(array.get(box_array,i))
            // if ta.crossover(close, level_to_break)
            if close >= level_to_break
                copied_box = box.copy(array.get(box_array,i))
                f_array_add_pop(bos_array, copied_box)
                mid = (box.get_top(array.get(box_array,i)) + box.get_bottom(array.get(box_array,i))) / 2
                box.set_top(array.get(bos_array,0), mid)
                box.set_bottom(array.get(bos_array,0), mid)
                box.set_extend( array.get(bos_array,0), extend.none)
                box.set_right( array.get(bos_array,0), bar_index)
                box.set_text( array.get(bos_array,0), 'BOS' )
                box.set_text_color( array.get(bos_array,0), bos_label_color)
                box.set_text_size( array.get(bos_array,0), size.small)
                box.set_text_halign( array.get(bos_array,0), text.align_center)
                box.set_text_valign( array.get(bos_array,0), text.align_center)
                box.delete(array.get(box_array, i))
                box.delete(array.get(label_array, i))

    if zone_type == -1
        for i = 0 to array.size(box_array) - 1
            level_to_break = box.get_bottom(array.get(box_array,i))
            // if ta.crossunder(close, level_to_break)
            if close <= level_to_break
                copied_box = box.copy(array.get(box_array,i))
                f_array_add_pop(bos_array, copied_box)
                mid = (box.get_top(array.get(box_array,i)) + box.get_bottom(array.get(box_array,i))) / 2
                box.set_top(array.get(bos_array,0), mid)
                box.set_bottom(array.get(bos_array,0), mid)
                box.set_extend( array.get(bos_array,0), extend.none)
                box.set_right( array.get(bos_array,0), bar_index)
                box.set_text( array.get(bos_array,0), 'BOS' )
                box.set_text_color( array.get(bos_array,0), bos_label_color)
                box.set_text_size( array.get(bos_array,0), size.small)
                box.set_text_halign( array.get(bos_array,0), text.align_center)
                box.set_text_valign( array.get(bos_array,0), text.align_center)
                box.delete(array.get(box_array, i))
                box.delete(array.get(label_array, i))

//      FUNCTION MANAGE CURRENT BOXES BY CHANGING ENDPOINT
f_extend_box_endpoint(box_array) =>

    for i = 0 to array.size(box_array) - 1
        box.set_right(array.get(box_array, i), bar_index + 100)

//
stratRes = timeframe.ismonthly  ? str.tostring(timeframe.multiplier * intRes, '###M') :
           timeframe.isweekly   ? str.tostring(timeframe.multiplier * intRes, '###W') :
           timeframe.isdaily    ? str.tostring(timeframe.multiplier * intRes, '###D') :
           timeframe.isintraday ? str.tostring(timeframe.multiplier * intRes, '####') :
           '60'
src      = h ? request.security(ticker.heikinashi(syminfo.tickerid),
           timeframe.period, close, lookahead = barmerge.lookahead_off) : close

//      CALCULATE ATR 
atrValue = ta.atr(50)

//      CALCULATE SWING HIGHS & SWING LOWS
swing_high = ta.pivothigh(high, swing_length, swing_length)
swing_low  = ta.pivotlow(low,   swing_length, swing_length)

//      ARRAYS FOR SWING H/L & BN 
var swing_high_values  = array.new_float(5,0.00)
var swing_low_values   = array.new_float(5,0.00)

var swing_high_bns     = array.new_int(5,0)
var swing_low_bns      = array.new_int(5,0)

//      ARRAYS FOR SUPPLY / DEMAND
var current_supply_box = array.new_box(history_of_demand_to_keep, na)
var current_demand_box = array.new_box(history_of_demand_to_keep, na)

//      ARRAYS FOR SUPPLY / DEMAND POI LABELS
var current_supply_poi = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi = array.new_box(history_of_demand_to_keep, na)

//      ARRAYS FOR BOS
var supply_bos         = array.new_box(5, na)
var demand_bos         = array.new_box(5, na)

//END CALCULATIONS

//      NEW SWING HIGH
if not na(swing_high)

    //MANAGE SWING HIGH VALUES
    f_array_add_pop(swing_high_values, swing_high)
    f_array_add_pop(swing_high_bns, bar_index[swing_length])
    if show_price_action_labels
        f_sh_sl_labels(swing_high_values, 1)

    f_supply_demand(swing_high_values, swing_high_bns, current_supply_box, current_supply_poi, 1, atrValue)

//      NEW SWING LOW
else if not na(swing_low)

    //MANAGE SWING LOW VALUES
    f_array_add_pop(swing_low_values, swing_low)
    f_array_add_pop(swing_low_bns, bar_index[swing_length])
    if show_price_action_labels
        f_sh_sl_labels(swing_low_values, -1)
    
    f_supply_demand(swing_low_values, swing_low_bns, current_demand_box, current_demand_poi, -1, atrValue)

f_sd_to_bos(current_supply_box, supply_bos, current_supply_poi, 1)
f_sd_to_bos(current_demand_box, demand_bos, current_demand_poi, -1)

f_extend_box_endpoint(current_supply_box)
f_extend_box_endpoint(current_demand_box)

channelBal     = input.bool(false, "Channel Balance", group = "CHART")

lr_slope(_src, _len) =>
    x = 0.0, y = 0.0, x2 = 0.0, xy = 0.0
    for i = 0 to _len - 1
        val = _src[i]
        per = i + 1
        x += per
        y += val
        x2 += per * per
        xy += val * per
    _slp = (_len * xy - x * y) / (_len * x2 - x * x)
    _avg = y / _len
    _int = _avg - _slp * x / _len + _slp
    [_slp, _avg, _int]
lr_dev(_src, _len, _slp, _avg, _int) =>
    upDev = 0.0, dnDev = 0.0
    val = _int
    for j = 0 to _len - 1
        price = high[j] - val
        if price > upDev
            upDev := price
        price := val - low[j]
        if price > dnDev
            dnDev := price
        price := _src[j]
        val += _slp
    [upDev, dnDev]

// 
[_, upperKC1, lowerKC1] = ta.kc(close, 80, 10.5)
[_, upperKC2, lowerKC2] = ta.kc(close, 80, 9.5)
[_, upperKC3, lowerKC3] = ta.kc(close, 80, 8)
[_, upperKC4, lowerKC4] = ta.kc(close, 80, 3)

barsL          = 10
barsR          = 10
pivotHigh      = fixnan(ta.pivothigh(barsL, barsR)[1])
pivotLow       = fixnan(ta.pivotlow(barsL, barsR)[1])
source         = close, period = 150
[s, a, i]      = lr_slope(source, period)
[upDev, dnDev] = lr_dev(source, period, s, a, i)

y1 = low  - (ta.atr(30) * 2), y1B = low  - ta.atr(30)
y2 = high + (ta.atr(30) * 2), y2B = high + ta.atr(30)
x1 = bar_index - period + 1, _y1 = i + s * (period - 1), x2 = bar_index, _y2 = i

//Functions
//Line Style function
get_line_style(style) =>
    out = switch style
        '???'  => line.style_solid
        '----' => line.style_dashed
        '    ' => line.style_dotted

//Function to get order block coordinates
get_coordinates(condition, top, btm, ob_val)=>
    var ob_top  = array.new_float(0)
    var ob_btm  = array.new_float(0)
    var ob_avg  = array.new_float(0)
    var ob_left = array.new_int(0)

    float ob = na

    //Append coordinates to arrays
    if condition
        avg = math.avg(top, btm)
        
        array.unshift(ob_top, top)
        array.unshift(ob_btm, btm)
        array.unshift(ob_avg, avg)
    
        ob := ob_val
    
    [ob_top, ob_btm, ob_avg, ob_left, ob]

//Function to remove mitigated order blocks from coordinate arrays
remove_mitigated(ob_top, ob_btm, ob_left, ob_avg, target, bull)=>
    mitigated = false
    target_array = bull ? ob_btm : ob_top

    for element in target_array
        idx = array.indexof(target_array, element)

        if (bull ? target < element : target > element)
            mitigated := true

            array.remove(ob_top, idx)
            array.remove(ob_btm, idx)
            array.remove(ob_avg, idx)
            array.remove(ob_left, idx)
    
    mitigated

//Function to set order blocks
set_order_blocks(ob_top, ob_btm, ob_left, ob_avg, ext_last, bg_css, border_css, lvl_css)=>
    var ob_box = array.new_box(0)
    var ob_lvl = array.new_line(0)

//Global elements 
var os = 0
var target_bull = 0.
var target_bear = 0.

// Create non-repainting security function
rp_security(_symbol, _res, _src) =>
    request.security(_symbol, _res, _src[barstate.isrealtime ? 1 : 0])

htfHigh = rp_security(syminfo.tickerid, res, high)
htfLow  = rp_security(syminfo.tickerid, res, low)

// Main Indicator
// Functions
smoothrng(x, t, m) =>
    wper = t * 2 - 1
    avrng = ta.ema(math.abs(x - x[1]), t)
    smoothrng = ta.ema(avrng, wper) * m
rngfilt(x, r) =>
    rngfilt = x
    rngfilt := x > nz(rngfilt[1]) ? x - r < nz(rngfilt[1]) ? nz(rngfilt[1]) : x - r : x + r > nz(rngfilt[1]) ? nz(rngfilt[1]) : x + r
percWidth(len, perc) => (ta.highest(len) - ta.lowest(len)) * perc / 100
securityNoRep(sym, res, src) => request.security(sym, res, src, barmerge.gaps_off, barmerge.lookahead_on)
swingPoints(prd) =>
    pivHi = ta.pivothigh(prd, prd)
    pivLo = ta.pivotlow (prd, prd)
    last_pivHi = ta.valuewhen(pivHi, pivHi, 1)
    last_pivLo = ta.valuewhen(pivLo, pivLo, 1)
    hh = pivHi and pivHi > last_pivHi ? pivHi : na
    lh = pivHi and pivHi < last_pivHi ? pivHi : na
    hl = pivLo and pivLo > last_pivLo ? pivLo : na
    ll = pivLo and pivLo < last_pivLo ? pivLo : na
    [hh, lh, hl, ll]
f_chartTfInMinutes() =>
    float _resInMinutes = timeframe.multiplier * (
      timeframe.isseconds ? 1                   :
      timeframe.isminutes ? 1.                  :
      timeframe.isdaily   ? 60. * 24            :
      timeframe.isweekly  ? 60. * 24 * 7        :
      timeframe.ismonthly ? 60. * 24 * 30.4375  : na)
f_kc(src, len, sensitivity) =>
    basis = ta.sma(src, len)
    span  = ta.atr(len)
    [basis + span * sensitivity, basis - span * sensitivity]
wavetrend(src, chlLen, avgLen) =>
    esa = ta.ema(src, chlLen)
    d = ta.ema(math.abs(src - esa), chlLen)
    ci = (src - esa) / (0.015 * d)
    wt1 = ta.ema(ci, avgLen)
    wt2 = ta.sma(wt1, 3)
    [wt1, wt2]
f_top_fractal(_src) => _src[4] < _src[2] and _src[3] < _src[2] and _src[2] > _src[1] and _src[2] > _src[0]
f_bot_fractal(_src) => _src[4] > _src[2] and _src[3] > _src[2] and _src[2] < _src[1] and _src[2] < _src[0]
top_fractal    = f_top_fractal(src)
bot_fractal    = f_bot_fractal(src)
f_fractalize (_src) => top_fractal ? 1 : bot_fractal ? -1 : 0
f_findDivs(src, topLimit, botLimit) =>
    fractalTop = f_fractalize(src) > 0 and src[2] >= topLimit ? src[2] : na
    fractalBot = f_fractalize(src) < 0 and src[2] <= botLimit ? src[2] : na
    highPrev   = ta.valuewhen(fractalTop, src[2], 0)[2]
    highPrice  = ta.valuewhen(fractalTop, high[2], 0)[2]
    lowPrev    = ta.valuewhen(fractalBot, src[2], 0)[2]
    lowPrice   = ta.valuewhen(fractalBot, low[2], 0)[2]
    bearSignal = fractalTop and high[1] > highPrice and src[1] < highPrev
    bullSignal = fractalBot and low[1] < lowPrice and src[1] > lowPrev
    [bearSignal, bullSignal]
    // Get user input
enableSR   = input(false          , "SR On/Off", group="SR")
colorSup   = input(#00000000        , "Support Color", group="SR")
colorRes   = input(#00000000        , "Resistance Color", group="SR")
strengthSR = input.int(2          , "S/R Strength", 1, group="SR")
lineStyle  = input.string("Dotted", "Line Style", ["Solid", "Dotted", "Dashed"], group="SR")
lineWidth  = input.int(2          , "S/R Line Width", 1, group="SR")
useZones   = input(true           , "Zones On/Off", group="SR")
useHLZones = input(true           , "High Low Zones On/Off", group="SR")
zoneWidth  = input.int(2          , "Zone Width %", 0,
   tooltip = "it's calculated using % of the distance between highest/lowest in last 300 bars", group="SR")
expandSR   = input(true           , "Expand SR")
// Get components
rb         = 10
prd        = 284
ChannelW   = 10
label_loc  = 55
style      = lineStyle == "Solid"  ? line.style_solid  :
             lineStyle == "Dotted" ? line.style_dotted : line.style_dashed
ph         = ta.pivothigh(rb, rb)
pl         = ta.pivotlow (rb, rb)
sr_levels  = array.new_float(21, na)
prdhighest = ta.highest(prd)
prdlowest  = ta.lowest(prd)
cwidth     = percWidth(prd, ChannelW)
zonePerc   = percWidth(300, zoneWidth)
aas        = array.new_bool(41, true)
u1         = 0.0, u1 := nz(u1[1])
d1         = 0.0, d1 := nz(d1[1])
highestph  = 0.0, highestph := highestph[1]
lowestpl   = 0.0, lowestpl := lowestpl[1]

var sr_levs   = array.new_float(21, na)
label hlabel  = na, label.delete(hlabel[1])
label llabel  = na, label.delete(llabel[1])
var sr_lines  = array.new_line(21, na)
var sr_linesH = array.new_line(21, na)
var sr_linesL = array.new_line(21, na)
var sr_linesF = array.new_linefill(21, na)
var sr_labels = array.new_label(21, na)
if (not na(ph) or not na(pl))
    for x = 0 to array.size(sr_levels) - 1
        array.set(sr_levels, x, na)
    highestph := prdlowest
    lowestpl := prdhighest
    countpp = 0
    for x = 0 to prd
        if na(close[x])
            break
        if not na(ph[x]) or not na(pl[x])
            highestph := math.max(highestph, nz(ph[x], prdlowest), nz(pl[x], prdlowest))
            lowestpl := math.min(lowestpl, nz(ph[x], prdhighest), nz(pl[x], prdhighest))
            countpp += 1
            if countpp > 40
                break
            if array.get(aas, countpp)
                upl = (not na(ph[x]) and (ph[x] != 0) ? high[x + rb] : low[x + rb]) + cwidth
                dnl = (not na(ph[x]) and (ph[x] != 0) ? high[x + rb] : low[x + rb]) - cwidth
                u1 := countpp == 1 ? upl : u1
                d1 := countpp == 1 ? dnl : d1
                tmp = array.new_bool(41, true)
                cnt = 0
                tpoint = 0
                for xx = 0 to prd
                    if na(close[xx])
                        break
                    if not na(ph[xx]) or not na(pl[xx])
                        chg = false
                        cnt += 1
                        if cnt > 40
                            break
                        if array.get(aas, cnt)
                            if not na(ph[xx])
                                if high[xx + rb] <= upl and high[xx + rb] >= dnl
                                    tpoint += 1
                                    chg := true
                            if not na(pl[xx])
                                if low[xx + rb] <= upl and low[xx + rb] >= dnl
                                    tpoint += 1
                                    chg := true
                        if chg and cnt < 41
                            array.set(tmp, cnt, false)
                if tpoint >= strengthSR
                    for g = 0 to 40 by 1
                        if not array.get(tmp, g)
                            array.set(aas, g, false)
                    if (not na(ph[x]) and countpp < 21)
                        array.set(sr_levels, countpp, high[x + rb])
                    if (not na(pl[x]) and countpp < 21)
                        array.set(sr_levels, countpp, low[x + rb])
// Plot
var line highest_      = na, line.delete(highest_)
var line lowest_       = na, line.delete(lowest_)
var line highest_fill1 = na, line.delete(highest_fill1)
var line highest_fill2 = na, line.delete(highest_fill2)
var line lowest_fill1  = na, line.delete(lowest_fill1)
var line lowest_fill2  = na, line.delete(lowest_fill2)
hi_col = close >= highestph ? colorSup : colorRes
lo_col = close >= lowestpl  ? colorSup : colorRes
if enableSR
    highest_ := line.new(bar_index - 311, highestph, bar_index, highestph, xloc.bar_index, expandSR ? extend.both : extend.right, hi_col, style, lineWidth)
    lowest_  := line.new(bar_index - 311, lowestpl , bar_index, lowestpl , xloc.bar_index, expandSR ? extend.both : extend.right, lo_col, style, lineWidth)
    if useHLZones
        highest_fill1 := line.new(bar_index - 311, highestph + zonePerc, bar_index, highestph + zonePerc, xloc.bar_index, expandSR ? extend.both : extend.right, na)
        highest_fill2 := line.new(bar_index - 311, highestph - zonePerc, bar_index, highestph - zonePerc, xloc.bar_index, expandSR ? extend.both : extend.right, na)
        lowest_fill1  := line.new(bar_index - 311, lowestpl + zonePerc , bar_index, lowestpl + zonePerc , xloc.bar_index, expandSR ? extend.both : extend.right, na)
        lowest_fill2  := line.new(bar_index - 311, lowestpl - zonePerc , bar_index, lowestpl - zonePerc , xloc.bar_index, expandSR ? extend.both : extend.right, na)
        linefill.new(highest_fill1, highest_fill2, hi_col)
        linefill.new(lowest_fill1 , lowest_fill2 , lo_col)
if (not na(ph) or not na(pl))
    for x = 0 to array.size(sr_lines) - 1
        array.set(sr_levs, x, array.get(sr_levels, x))
for x = 0 to array.size(sr_lines) - 1
    line.delete(array.get(sr_lines, x))
    line.delete(array.get(sr_linesH, x))
    line.delete(array.get(sr_linesL, x))
    linefill.delete(array.get(sr_linesF, x))
    if (not na(array.get(sr_levs, x)) and enableSR)
        line_col = close >= array.get(sr_levs, x) ? colorSup : colorRes
        array.set(sr_lines, x, line.new(bar_index - 355, array.get(sr_levs, x), bar_index, array.get(sr_levs, x), xloc.bar_index, expandSR ? extend.both : extend.right, line_col, style, lineWidth))
        if useZones
            array.set(sr_linesH, x, line.new(bar_index - 355, array.get(sr_levs, x) + zonePerc, bar_index, array.get(sr_levs, x) + zonePerc, xloc.bar_index, expandSR ? extend.both : extend.right, na))
            array.set(sr_linesL, x, line.new(bar_index - 355, array.get(sr_levs, x) - zonePerc, bar_index, array.get(sr_levs, x) - zonePerc, xloc.bar_index, expandSR ? extend.both : extend.right, na))
            array.set(sr_linesF, x, linefill.new(array.get(sr_linesH, x), array.get(sr_linesL, x), line_col))
for x = 0 to array.size(sr_labels) - 1
    label.delete(array.get(sr_labels, x))
    if (not na(array.get(sr_levs, x)) and enableSR)
        lab_loc = close >= array.get(sr_levs, x) ? label.style_label_up : label.style_label_down
        lab_col = close >= array.get(sr_levs, x) ? colorSup             : colorRes
        array.set(sr_labels, x, label.new(bar_index + label_loc, array.get(sr_levs, x), str.tostring(math.round_to_mintick(array.get(sr_levs, x))), color=lab_col , textcolor=#000000, style=lab_loc))
hlabel := enableSR ? label.new(bar_index + label_loc + math.round(math.sign(label_loc)) * 20, highestph, "High Level : " + str.tostring(highestph), color=hi_col, textcolor=#000000, style=label.style_label_down) : na
llabel := enableSR ? label.new(bar_index + label_loc + math.round(math.sign(label_loc)) * 20, lowestpl , "Low  Level : " + str.tostring(lowestpl) , color=lo_col, textcolor=#000000, style=label.style_label_up  ) : na

// Get components
rsi       = ta.rsi(close, 28)
//rsiOb     = rsi > 78 and rsi > ta.ema(rsi, 10)
//rsiOs     = rsi < 27 and rsi < ta.ema(rsi, 10)
rsiOb     = rsi > 65 and rsi > ta.ema(rsi, 10)
rsiOs     = rsi < 35 and rsi < ta.ema(rsi, 10)
dHigh     = securityNoRep(syminfo.tickerid, "D", high [1])
dLow      = securityNoRep(syminfo.tickerid, "D", low  [1])
dClose    = securityNoRep(syminfo.tickerid, "D", close[1])
ema = ta.ema(close, 144)
emaBull = close > ema
equal_tf(res) => str.tonumber(res) == f_chartTfInMinutes() and not timeframe.isseconds
higher_tf(res) => str.tonumber(res) > f_chartTfInMinutes() or timeframe.isseconds
too_small_tf(res) => (timeframe.isweekly and res=="1") or (timeframe.ismonthly and str.tonumber(res) < 10)
securityNoRep1(sym, res, src) =>
    bool bull_ = na
    bull_ := equal_tf(res) ? src : bull_
    bull_ := higher_tf(res) ? request.security(sym, res, src, barmerge.gaps_off, barmerge.lookahead_on) : bull_
    bull_array = request.security_lower_tf(syminfo.tickerid, higher_tf(res) ? str.tostring(f_chartTfInMinutes()) + (timeframe.isseconds ? "S" : "") : too_small_tf(res) ? (timeframe.isweekly ? "3" : "10") : res, src)
    if array.size(bull_array) > 1 and not equal_tf(res) and not higher_tf(res)
        bull_ := array.pop(bull_array)
    array.clear(bull_array)
    bull_

// === BASE FUNCTIONS ===
// Returns MA input selection variant, default to SMA if blank or typo.
variant(type, src, len, offSig, offALMA) =>
    v1    = ta.sma(src, len)  // Simple
    v2    = ta.ema(src, len)  // Exponential
    v3    = 2 * v2 - ta.ema(v2, len)  // Double Exponential
    v4    = 3 * (v2 - ta.ema(v2, len)) + ta.ema(ta.ema(v2, len), len)  // Triple Exponential
    v5    = ta.wma(src, len)  // Weighted
    v6    = ta.vwma(src, len)  // Volume Weighted
    v7    = 0.0
    sma_1 = ta.sma(src, len)  // Smoothed
    v7   := na(v7[1]) ? sma_1 : (v7[1] * (len - 1) + src) / len
    v8    = ta.wma(2 * ta.wma(src, len / 2) - ta.wma(src, len), math.round(math.sqrt(len)))  // Hull
    v9    = ta.linreg(src, len, offSig)  // Least Squares
    v10   = ta.alma(src, len, offALMA, offSig)  // Arnaud Legoux
    v11   = ta.sma(v1, len)  // Triangular (extreme smooth)
    // SuperSmoother filter
    //   2013  John F. Ehlers
    a1    = math.exp(-1.414 * 3.14159 / len)
    b1    = 2 * a1 * math.cos(1.414 * 3.14159 / len)
    c2    = b1
    c3    = -a1 * a1
    c1    = 1 - c2 - c3
    v12   = 0.0
    v12  := c1 * (src + nz(src[1])) / 2 + c2 * nz(v12[1]) + c3 * nz(v12[2])
    type == 'EMA' ? v2 : type == 'DEMA' ? v3 : type == 'TEMA' ? v4 : type == 'WMA' ? v5 : type == 'VWMA' ? v6 : type == 'SMMA' ? v7 : type == 'HullMA' ? v8 : type == 'LSMA' ? v9 : type == 'ALMA' ? v10 : type == 'TMA' ? v11 : type == 'SSMA' ? v12 : v1

// security wrapper for repeat calls
reso(exp, use, res) =>
    security_1 = request.security(syminfo.tickerid, res, exp, gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)
    use ? security_1 : exp

// === /BASE FUNCTIONS ===
// === SERIES SETUP ===
closeSeries = variant(basisType, close[delayOffset], basisLen, offsetSigma, offsetALMA)
openSeries  = variant(basisType, open[delayOffset],  basisLen, offsetSigma, offsetALMA)
// === /SERIES ===

// Get Alternate resolution Series if selected.
closeSeriesAlt = reso(closeSeries, useRes, stratRes)
openSeriesAlt  = reso(openSeries, useRes, stratRes)

//<triggers>
lxTrigger    = false
sxTrigger    = false
leTrigger    = ta.crossover (closeSeriesAlt, openSeriesAlt)
seTrigger    = ta.crossunder(closeSeriesAlt, openSeriesAlt)

G_RISK       = '■ ' + 'Risk Management'
//#region ———— <↓↓↓ G_RISK ↓↓↓> {

// ——————————— <constant_declarations>
//Tooltip
T_LVL        = '(%) Exit Level'
T_QTY        = '(%) Adjust trade exit volume'
T_MSG        = 'Paste JSON message for your bot'
//Webhook Message
O_LEMSG      = 'Long Entry'
O_LXMSGSL    = 'Long SL'
O_LXMSGTP1   = 'Long TP1'
O_LXMSGTP2   = 'Long TP2'
O_LXMSGTP3   = 'Long TP3'
O_LXMSG      = 'Long Exit'
O_SEMSG      = 'Short Entry'
O_SXMSGSL    = 'Short SL'
O_SXMSGA     = 'Short TP1'
O_SXMSGB     = 'Short TP2'
O_SXMSGC     = 'Short TP3'
O_SXMSGX     = 'Short Exit'

// ——————————— <input>          |           |                               |                        Line length guide |
i_lxLvlTP1   = input.float      (0.2,         'Level TP1'                     , group = G_RISK,
     tooltip =                   T_LVL)
i_lxQtyTP1   = input.float      (80.0,        'Qty   TP1'                     , group = G_RISK,
     tooltip =                   T_QTY)
i_lxLvlTP2   = input.float      (0.5,       'Level TP2'                     , group = G_RISK,
     tooltip =                   T_LVL)
i_lxQtyTP2   = input.float      (10.0,        'Qty   TP2'                     , group = G_RISK,
     tooltip =                   T_QTY)
i_lxLvlTP3   = input.float      (7.0,         'Level TP3'                     , group = G_RISK,
     tooltip =                   T_LVL)
i_lxQtyTP3   = input.float      (2,        'Qty   TP3'                     , group = G_RISK,
     tooltip =                   T_QTY)
i_lxLvlSL    = input.float      (0.5,       'Stop Loss'                     , group = G_RISK,
     tooltip =                   T_LVL)
i_sxLvlTP1   = i_lxLvlTP1
i_sxQtyTP1   = i_lxQtyTP1
i_sxLvlTP2   = i_lxLvlTP2
i_sxQtyTP2   = i_lxQtyTP2
i_sxLvlTP3   = i_lxLvlTP3
i_sxQtyTP3   = i_lxQtyTP3
i_sxLvlSL    = i_lxLvlSL

G_MSG        = '■ ' + 'Webhook Message'
i_leMsg      = input.string     (O_LEMSG   ,'Long Entry'                   , group = G_MSG, tooltip = T_MSG)
i_lxMsgSL    = input.string     (O_LXMSGSL ,'Long SL'                      , group = G_MSG, tooltip = T_MSG)
i_lxMsgTP1   = input.string     (O_LXMSGTP1,'Long TP1'                     , group = G_MSG, tooltip = T_MSG)
i_lxMsgTP2   = input.string     (O_LXMSGTP2,'Long TP2'                     , group = G_MSG, tooltip = T_MSG)
i_lxMsgTP3   = input.string     (O_LXMSGTP3,'Long TP3'                     , group = G_MSG, tooltip = T_MSG)
i_lxMsg      = input.string     (O_LXMSG   ,'Long Exit'                    , group = G_MSG, tooltip = T_MSG)
i_seMsg      = input.string     (O_SEMSG   ,'Short Entry'                  , group = G_MSG, tooltip = T_MSG)
i_sxMsgSL    = input.string     (O_SXMSGSL ,'Short SL'                     , group = G_MSG, tooltip = T_MSG)
i_sxMsgTP1   = input.string     (O_SXMSGA  ,'Short TP1'                    , group = G_MSG, tooltip = T_MSG)
i_sxMsgTP2   = input.string     (O_SXMSGB  ,'Short TP2'                    , group = G_MSG, tooltip = T_MSG)
i_sxMsgTP3   = input.string     (O_SXMSGC  ,'Short TP3'                    , group = G_MSG, tooltip = T_MSG)
i_sxMsg      = input.string     (O_SXMSGX  ,'Short Exit'                   , group = G_MSG, tooltip = T_MSG)
i_src        = close

G_DISPLAY    = 'Display'
//<display>
i_alertOn    = input.bool       (true,      'Alert Labels On/Off'          , group = G_DISPLAY)
i_barColOn   = input.bool       (true,      'Bar Color On/Off'             , group = G_DISPLAY)

// ——————————— <function_declarations>
// @function        Calculate the Take Profit line, and the crossover or crossunder
f_tp(_condition, _conditionValue, _leTrigger, _seTrigger, _src, _lxLvlTP, _sxLvlTP)=>
    var float _tpLine = 0.0
    _topLvl     = _src + (_src * (_lxLvlTP / 100))
    _botLvl     = _src - (_src * (_sxLvlTP / 100))
    _tpLine    := _condition[1] !=  _conditionValue and _leTrigger ? _topLvl :
                  _condition[1] != -_conditionValue and _seTrigger ? _botLvl :
                  nz(_tpLine[1])
    [_tpLine]

// @function        Similar to "ta.crossover" or "ta.crossunder"
f_cross(_scr1, _scr2, _over)=>
    _cross   = _over ? _scr1 > _scr2 and _scr1[1] < _scr2[1] :
                       _scr1 < _scr2 and _scr1[1] > _scr2[1]

// ——————————— <calculations>
//<set initial values>
var float condition = 0.0
var float slLine    = 0.0
var float entryLine = 0.0

//<entry & exit orders>
entryLine   := leTrigger and condition[1] <=  0.0 ? close :
               seTrigger and condition[1] >=  0.0 ? close : nz(entryLine[1])
//<SL>
slTopLvl    = i_src + (i_src * (i_lxLvlSL / 100))
slBotLvl    = i_src - (i_src * (i_sxLvlSL / 100))
slLine     := condition[1] <=  0.0 and leTrigger ? slBotLvl :
              condition[1] >=  0.0 and seTrigger ? slTopLvl : nz(slLine[1])
slLong      = f_cross(low,  slLine, false)
slShort     = f_cross(high, slLine, true )
//<TP1, TP2 & TP3>
[tp3Line]    = f_tp(condition, 1.2,leTrigger, seTrigger, i_src, i_lxLvlTP3, i_sxLvlTP3)
[tp2Line]    = f_tp(condition, 1.1,leTrigger, seTrigger, i_src, i_lxLvlTP2, i_sxLvlTP2)
[tp1Line]    = f_tp(condition, 1.0,leTrigger, seTrigger, i_src, i_lxLvlTP1, i_sxLvlTP1)
tp3Long      = f_cross(high, tp3Line, true )
tp3Short     = f_cross(low,  tp3Line, false)
tp2Long      = f_cross(high, tp2Line, true )
tp2Short     = f_cross(low,  tp2Line, false)
tp1Long      = f_cross(high, tp1Line, true )
tp1Short     = f_cross(low,  tp1Line, false)

switch
    leTrigger and condition[1] <=  0.0 => condition :=  1.0
    seTrigger and condition[1] >=  0.0 => condition := -1.0
    tp3Long   and condition[1] ==  1.2 => condition :=  1.3
    tp3Short  and condition[1] == -1.2 => condition := -1.3
    tp2Long   and condition[1] ==  1.1 => condition :=  1.2
    tp2Short  and condition[1] == -1.1 => condition := -1.2
    tp1Long   and condition[1] ==  1.0 => condition :=  1.1
    tp1Short  and condition[1] == -1.0 => condition := -1.1
    slLong    and condition[1] >=  1.0 => condition :=  0.0
    slShort   and condition[1] <= -1.0 => condition :=  0.0
    lxTrigger and condition[1] >=  1.0 => condition :=  0.0
    sxTrigger and condition[1] <= -1.0 => condition :=  0.0

longE        = leTrigger and condition[1] <=  0.0 and condition ==  1.0
shortE       = seTrigger and condition[1] >=  0.0 and condition == -1.0
longX        = lxTrigger and condition[1] >=  1.0 and condition ==  0.0
shortX       = sxTrigger and condition[1] <= -1.0 and condition ==  0.0
longSL       = slLong    and condition[1] >=  1.0 and condition ==  0.0
shortSL      = slShort   and condition[1] <= -1.0 and condition ==  0.0
longTP3      = tp3Long   and condition[1] ==  1.2 and condition ==  1.3
shortTP3     = tp3Short  and condition[1] == -1.2 and condition == -1.3
longTP2      = tp2Long   and condition[1] ==  1.1 and condition ==  1.2
shortTP2     = tp2Short  and condition[1] == -1.1 and condition == -1.2
longTP1      = tp1Long   and condition[1] ==  1.0 and condition ==  1.1
shortTP1     = tp1Short  and condition[1] == -1.0 and condition == -1.1

// ——————————— <strategy_calls> {
//<long orders>
if strategy.position_size <= 0 and longE and barstate.isconfirmed
    strategy.entry(
      'Long',
      strategy.long,
      alert_message    = i_leMsg,
      comment          = 'LE')
if strategy.position_size > 0 and condition ==  1.0
    strategy.exit(
      id               = 'LXTP1',
      from_entry       = 'Long',
      qty_percent      = i_lxQtyTP1,
      limit            = tp1Line,
      stop             = slLine,
      comment_profit   = 'LXTP1',
      comment_loss     = 'SL',
      alert_profit     = i_lxMsgTP1,
      alert_loss       = i_lxMsgSL)
if strategy.position_size > 0 and condition ==  1.1
    strategy.exit(
      id               = 'LXTP2',
      from_entry       = 'Long',
      qty_percent      = i_lxQtyTP2,
      limit            = tp2Line,
      stop             = slLine,
      comment_profit   = 'LXTP2',
      comment_loss     = 'SL',
      alert_profit     = i_lxMsgTP2,
      alert_loss       = i_lxMsgSL)
if strategy.position_size > 0 and condition ==  1.2
    strategy.exit(
      id               = 'LXTP3',
      from_entry       = 'Long',
      qty_percent      = i_lxQtyTP3,
      limit            = tp3Line,
      stop             = slLine,
      comment_profit   = 'LXTP3',
      comment_loss     = 'SL',
      alert_profit     = i_lxMsgTP3,
      alert_loss       = i_lxMsgSL)
if longX
    strategy.close(
      'Long',
      alert_message    = i_lxMsg,
      comment          = 'LX')
//<short orders>
if strategy.position_size >= 0 and shortE and barstate.isconfirmed
    strategy.entry(
      'Short',
      strategy.short,
      alert_message    = i_leMsg,
      comment          = 'SE')
if strategy.position_size < 0 and condition == -1.0
    strategy.exit(
      id               = 'SXTP1',
      from_entry       = 'Short',
      qty_percent      = i_sxQtyTP1,
      limit            = tp1Line,
      stop             = slLine,
      comment_profit   = 'SXTP1',
      comment_loss     = 'SL',
      alert_profit     = i_sxMsgTP1,
      alert_loss       = i_sxMsgSL)
if strategy.position_size < 0 and condition == -1.1
    strategy.exit(
      id               = 'SXTP2',
      from_entry       = 'Short',
      qty_percent      = i_sxQtyTP2,
      limit            = tp2Line,
      stop             = slLine,
      comment_profit   = 'SXTP2',
      comment_loss     = 'SL',
      alert_profit     = i_sxMsgTP2,
      alert_loss       = i_sxMsgSL)
if strategy.position_size < 0 and condition == -1.2
    strategy.exit(
      id               = 'SXTP3',
      from_entry       = 'Short',
      qty_percent      = i_sxQtyTP3,
      limit            = tp3Line,
      stop             = slLine,
      comment_profit   = 'SXTP3',
      comment_loss     = 'SL',
      alert_profit     = i_sxMsgTP3,
      alert_loss       = i_sxMsgSL)
if shortX
    strategy.close(
      'Short',
      alert_message    = i_sxMsg,
      comment          = 'SX')

// ——————————— <visuals>
c_tp         = leTrigger or seTrigger ? na :
               condition == 0.0       ? na : color.green
c_entry      = leTrigger or seTrigger ? na :
               condition == 0.0       ? na : color.blue
c_sl         = leTrigger or seTrigger ? na :
               condition == 0.0       ? na : color.red
p_tp1Line    = plot (
  condition ==  1.0 or
  condition == -1.0 ? tp1Line : na,
  title      = "TP Line 1",
  color      = c_tp,
  linewidth  = 1,
  style      = plot.style_linebr)
p_tp2Line    = plot (
  condition ==  1.0 or
  condition == -1.0 or
  condition ==  1.1 or
  condition == -1.1 ? tp2Line : na,
  title      = "TP Line 2",
  color      = c_tp,
  linewidth  = 1,
  style      = plot.style_linebr)
p_tp3Line    = plot (
  condition ==  1.0 or
  condition == -1.0 or
  condition ==  1.1 or
  condition == -1.1 or
  condition ==  1.2 or
  condition == -1.2 ? tp3Line : na,
  title      = "TP Line 3",
  color      = c_tp,
  linewidth  = 1,
  style      = plot.style_linebr)
p_entryLine  = plot (
  condition >=  1.0 or
  condition <= -1.0 ? entryLine : na,
  title      = "Entry Line",
  color      = c_entry,
  linewidth  = 1,
  style      = plot.style_linebr)
p_slLine     = plot (
  condition ==  1.0 or
  condition == -1.0 or
  condition ==  1.1 or
  condition == -1.1 or
  condition ==  1.2 or
  condition == -1.2 ? slLine : na,
  title      = "SL Line",
  color      = c_sl,
  linewidth  = 1,
  style      = plot.style_linebr)
fill(
  p_tp3Line, p_entryLine,
  color      = leTrigger or seTrigger ? na :color.new(color.green, 90))
fill(
  p_entryLine, p_slLine,
  color      = leTrigger or seTrigger ? na :color.new(color.red, 90))

//<alerts labels>
plotshape(
  i_alertOn and longE,
  title      = 'Long',
  text       = 'Long',
  textcolor  = color.white,
  color      = color.green,
  style      = shape.labelup,
  size       = size.tiny,
  location   = location.belowbar)
plotshape(
  i_alertOn and shortE,
  title      = 'Short',
  text       = 'Short',
  textcolor  = color.white,
  color      = color.red,
  style      = shape.labeldown,
  size       = size.tiny,
  location   = location.abovebar)
plotshape(
  i_alertOn and (longX or shortX) ? close : na,
  title      = 'Close',
  text       = 'Close',
  textcolor  = color.white,
  color      = color.gray,
  style      = shape.labelup,
  size       = size.tiny,
  location   = location.absolute)
l_tp         = i_alertOn and (longTP1 or shortTP1) ? close : na
plotshape(
  l_tp,
  title      = "TP1 Cross",
  text       = "TP1",
  textcolor  = color.white,
  color      = color.olive,
  style      = shape.labelup,
  size       = size.tiny,
  location   = location.absolute)
plotshape(
  i_alertOn and (longTP2 or shortTP2) ? close : na,
  title      = "TP2 Cross",
  text       = "TP2",
  textcolor  = color.white,
  color      = color.olive,
  style      = shape.labelup,
  size       = size.tiny,
  location   = location.absolute)
plotshape(
  i_alertOn and (longTP3 or shortTP3) ? close : na,
  title      = "TP3 Cross",
  text       = "TP3",
  textcolor  = color.white,
  color      = color.olive,
  style      = shape.labelup,
  size       = size.tiny,
  location   = location.absolute)
plotshape(
  i_alertOn and (longSL or shortSL) ? close : na,
  title      = "SL Cross",
  text       = "SL",
  textcolor  = color.white,
  color      = color.maroon,
  style      = shape.labelup,
  size       = size.tiny,
  location   = location.absolute)

//<debug>
plot(
  na,
  title      = "─── <debug> ───",
  editable   = false,
  display    = display.data_window)
plot(
  condition,
  title      = "condition",
  editable   = false,
  display    = display.data_window)
plot(
  strategy.position_size * 100,
  title      = ".position_size",
  editable   = false,
  display    = display.data_window)
//#endregion }
// ——————————— <↑↑↑ G_RISK ↑↑↑>

//#region ———— <↓↓↓ G_SCRIPT02 ↓↓↓> {
// @function        Queues a new element in an array and de-queues its first element.
f_qDq(_array, _val) =>
    array.push(_array, _val)
    _return = array.shift(_array)
    _return

var line[]  a_slLine     = array.new_line(1)
var line[]  a_entryLine  = array.new_line(1)
var line[]  a_tp3Line    = array.new_line(1)
var line[]  a_tp2Line    = array.new_line(1)
var line[]  a_tp1Line    = array.new_line(1)
var label[] a_slLabel    = array.new_label(1)
var label[] a_tp3label   = array.new_label(1)
var label[] a_tp2label   = array.new_label(1)
var label[] a_tp1label   = array.new_label(1)
var label[] a_entryLabel = array.new_label(1)

newEntry     = longE or shortE
entryIndex   = 1
entryIndex  := newEntry ? bar_index : nz(entryIndex[1])
lasTrade     = bar_index >= entryIndex
l_right      = 10

line.delete(
  f_qDq(a_slLine,
  line.new(
   entryIndex,
   slLine,
   last_bar_index + l_right,
   slLine,
   style = line.style_solid,
   color = c_sl)))
line.delete(
  f_qDq(a_entryLine,
  line.new(
   entryIndex,
   entryLine,
   last_bar_index + l_right,
   entryLine,
   style = line.style_solid,
   color = color.blue)))
line.delete(
  f_qDq(a_tp3Line,
  line.new(
   entryIndex,
   tp3Line,
   last_bar_index + l_right,
   tp3Line,
   style = line.style_solid,
   color = c_tp)))
line.delete(
  f_qDq(a_tp2Line,
  line.new(
   entryIndex,
   tp2Line,
   last_bar_index + l_right,
   tp2Line,
   style = line.style_solid,
   color = c_tp)))
line.delete(
  f_qDq(a_tp1Line,
  line.new(
   entryIndex,
   tp1Line,
   last_bar_index + l_right,
   tp1Line,
   style = line.style_solid,
   color = c_tp)))

label.delete(
  f_qDq(a_slLabel,
  label.new(
   last_bar_index + l_right,
   slLine,
   'SL: ' + str.tostring(slLine, '##.###'),
   style = label.style_label_left,
   textcolor  = color.white,
   color = c_sl)))
label.delete(
  f_qDq(a_entryLabel,
  label.new(
   last_bar_index + l_right,
   entryLine,
   'Entry: ' + str.tostring(entryLine, '##.###'),
   style = label.style_label_left,
   textcolor  = color.white,
   color = color.blue)))
label.delete(
  f_qDq(a_tp3label,
  label.new(
   last_bar_index + l_right,
   tp3Line,
   'TP3: ' + str.tostring(tp3Line, '##.###'),
   style = label.style_label_left,
   textcolor  = color.white,
   color = c_tp)))
label.delete(
  f_qDq(a_tp2label,
  label.new(
   last_bar_index + l_right,
   tp2Line,
   'TP2: ' + str.tostring(tp2Line, '##.###'),
   style = label.style_label_left,
   textcolor  = color.white,
   color = c_tp)))
label.delete(
  f_qDq(a_tp1label,
  label.new(
   last_bar_index + l_right,
   tp1Line,
   'TP1: ' + str.tostring(tp1Line, '##.###'),
   style = label.style_label_left,
   textcolor  = color.white,
   color = c_tp)))

// ——————————— <alerts>
//<any_alert_function_call>
if longE or shortE or longX or shortX
    alert(message = 'Any Alert',   freq = alert.freq_once_per_bar_close)
if longE
    alert(message = 'Long Entry',  freq = alert.freq_once_per_bar_close)
if shortE
    alert(message = 'Short Entry', freq = alert.freq_once_per_bar_close)
if longX
    alert(message = 'Long Exit',   freq = alert.freq_once_per_bar_close)
if shortX
    alert(message = 'Short Exit',  freq = alert.freq_once_per_bar_close)
//#endregion }
// ——————————— <↑↑↑ G_SCRIPT03 ↑↑↑>

// Gradient Bull/Bear
brightgreen = #00ff0a
green = color.green
darkgreen = #1b5e20
brightred = #ff1100
red = color.red
darkred = #801922
// Other
yellow = #ffe500
fuchsia = #da00ff
blue = #0006ff
aqua = #00ffef
orange = color.orange
gray = color.gray
grayishgreen = #a5d6a7
grayishred = #faa1a4

// Groups
grrsi = '📈 Relative Strength Index 📈'
grmtfma = '⏰ MTF Moving Averages ⏰'
grppl = '🔖 Price Pivot Labels 🔖' 
grtl = "📐 Trend Lines 📐"
grhts = '🚦 Hayden Trend State 🚦'
grhaco = "🧨 Heiken Ashi Candle Overlay 🧨" 
grdv = '🔀 Divergences 🔀'
grfrt = '🧬 Fibonacci Retracements 🧬'
grwm = '✍ Watermark ✍ '
grtk = "🎰 Tickers 🎰"

// Default Variables
pi = 3.1415926535897932384626433832795028841971693993751058209749445923078164062
// ------------------------------------- RSI -------------------------------- //
rsisrc = input.source(close, "Source", group=grrsi)
prsilen = input.int(14, "RSI Length", group=grrsi, tooltip="For best results, these RSI settings should match the same settings used in Hayden's Advanced RSI oscillator.\nThis RSI length applies to all RSI functions in this chart indicator.")

//--------------------------------Moving Averages-----------------------------//
resCustom = input.timeframe(title='MTF MA\s Timeframe', defval='W', group=grmtfma)
showgaps = input(false, "Show MTF MA Gaps?", group=grmtfma, tooltip="Check this box for a smooth MTF MA line. The tradeoff is that it lags.")
// Fast MA
fastma = ta.sma(close, 9)
fastcol = fastma>fastma[1] ? green : fastma<fastma[1] ? red : gray
fastcolv = fastma>fastma[1] ? brightgreen : fastma<fastma[1] ? brightred : gray
// MTF Fast MA
fastma2 = request.security(syminfo.tickerid, resCustom, ta.sma(close,9), gaps=showgaps ? barmerge.gaps_on : barmerge.gaps_off)
fastcol2 = fastma2>fastma2[1] ? green : fastma2<fastma2[1] ? red : gray
// Slow 45 WMA/EMA
r45ma = input.string('WMA', title='45 WMA or EMA?', options=['WMA', 'EMA'], group=grmtfma, tooltip='There is some inconsistency in the book due to charts (Appendix C) citing use of a 45 EMA on RSI, and text (page 107 & 108) citing use of a 45 WMA on RSI. Take your pick.')
slowema = ta.ema(close, 45)
slowwma = ta.wma(close, 45)
slowmaout = r45ma == 'WMA' ? slowwma : slowema
slowcol = slowmaout>slowmaout[1] ? green : slowmaout<slowmaout[1] ? red : gray
slowcolv = slowmaout>slowmaout[1] ? brightgreen : slowmaout<slowmaout[1] ? brightred : gray
// MTF Slow 45 WMA/EMA
r45ma2 = input.string('WMA', title='MTF 45 WMA or EMA?', options=['WMA', 'EMA'], group=grmtfma, tooltip='There is some inconsistency in the book due to charts (Appendix C) citing use of a 45 EMA on RSI, and text (page 107 & 108) citing use of a 45 WMA on RSI. Take your pick.')
slowwma2 = request.security(syminfo.tickerid, resCustom, ta.wma(close,45), gaps=showgaps ? barmerge.gaps_on : barmerge.gaps_off)
slowema2 = request.security(syminfo.tickerid, resCustom, ta.ema(close,45), gaps=showgaps ? barmerge.gaps_on : barmerge.gaps_off)
slowmaout2 = r45ma2 == 'WMA' ? slowwma2 : slowema2
slowcol2 = slowmaout2>slowmaout2[1] ? green : slowmaout2<slowmaout2[1] ? red : gray
// River MA
riverlen = input(89, title="89 EMA Length", group=grmtfma, tooltip="Popular: 100, 144, 200, 233")
riverdisp = input.string("_____", title="89 EMA Display", options=["_____","-----","∙∙∙∙∙","None"], group=grmtfma)
riverglow = input.string("Normal", "89 EMA Color", options=["Normal", "Electric"], group=grmtfma, 
  tooltip="Normal is just a single aqua/orange line. Electric applies a thick & transparent blue/red line over the normal line to give the combination a glowing neon look.")
river = ta.ema(close, riverlen)
rivercol = river>river[1] ? aqua : river<river[1] ? orange : gray
rivercol2 = river>river[1] ? green : river<river[1] ? red : gray
// MTF River MA
riverlen2 = input(200, title="MTF 89 EMA Length", group=grmtfma)
river2 = request.security(syminfo.tickerid, resCustom, ta.ema(close, riverlen2), gaps=showgaps ? barmerge.gaps_on : barmerge.gaps_off)
fastfill = plot(fastma, '9 SMA', color=color.new(fastcol, 10))
slowfill = plot(slowmaout, '45 WMA', color=color.new(slowcol, 10))
fill(fastfill, slowfill, color=color.new(fastma>slowmaout ? green : red, 85))
plot(riverdisp=="_____"?river:na, '89 EMA', color=color.new(rivercol,10), linewidth=1, editable=false)
plot(riverdisp=="_____" and riverglow=="Electric"?river:na, '89 EMA Glow', color=color.new(rivercol2,60), linewidth=3, editable=false)
plotchar(riverdisp=="-----"?river:na, "Dashed 89 EMA", char="–", location=location.absolute, color=color.new(rivercol,10), editable=false)
plotchar(riverdisp=="∙∙∙∙∙"?river:na, "Dotted 89 EMA", char="∙", location=location.absolute, color=color.new(rivercol,10), editable=false)
fastfill2 = plot(fastma2, 'MTF 9 SMA', color=color.new(gray, 10), display=display.none, linewidth=1)
slowfill2 = plot(slowmaout2, 'MTF 45 WMA', color=color.new(gray, 10), display=display.none, linewidth=2) 
plot(river2, 'MTF 89 EMA', color=color.new(gray,10), display=display.none, linewidth=3)

//-------------------------------Pivots---------------------------------------//
showperc = input(defval=true, title='Show Price Pivot Labels?', group=grppl, tooltip="Hover over labels for additional info. \nThese labels might repaint up to a length of ZigZag Period or Bars to the Left # of bars. ")
upcolor = input(defval=green, title='Bullish Color', group=grppl)
downcolor = input(defval=red, title='Bearish Color', group=grppl)
// Pivot Lookback
leftbars = input.int(8, minval=1, title='Bars to the left', group=grppl)
rightbars = input.int(8, minval=1, title='Bars to the right', group=grppl)
// Pivot Prices
phigh = ta.pivothigh(high, leftbars, rightbars)
plow = ta.pivotlow(low, leftbars, rightbars)
//Pivot %
//Inputs
zigperiod = input(defval=13, title='ZigZag Period', group=grppl, tooltip="The higher the number, the fewer the labels")
pppsize = input.string(size.small, title="Price & Percent Change Pivots Label Size", options=[size.normal, size.small, size.tiny], group=grppl)
percentdecimals = input.int(defval=2, title='% Decimals', minval=0, maxval=10, group=grppl, tooltip="This % Decimals value also applies to the Ticker")
pricedecimals = input.int(defval=2, title='Price Decimals', minval=0, maxval=10, group=grppl, tooltip="This Price Decimals value also applies to the Ticker")
showline = false 
zigstyle = input.string(defval='-----', title='Zig Zag Line Style', options=['.....', '-----'], group=grppl)
zigwidth = 1 
elen = 5 
esrc = close 
out = ta.ema(esrc, elen)
prsi = ta.rsi(rsisrc,prsilen)
rsi_value = ta.rsi(rsisrc, prsilen)
//Float
float highs = ta.highestbars(close, zigperiod) == 0 ? close : na
float lows = ta.lowestbars(close, zigperiod) == 0 ? close : na
//Variables
var dir1 = 0
iff_1 = not na(lows) and na(highs) ? -1 : dir1
dir1 := not na(highs) and na(lows) ? 1 : iff_1

var max_array_size = 10
var ziggyzags = array.new_float(0)

add_to_zigzag(pointer, value, bindex) =>
    array.unshift(pointer, bindex)
    array.unshift(pointer, value)
    if array.size(pointer) > max_array_size
        array.pop(pointer)
        array.pop(pointer)

update_zigzag(pointer, value, bindex, dir) =>
    if array.size(pointer) == 0
        add_to_zigzag(pointer, value, bindex)
    else
        if dir == 1 and value > array.get(pointer, 0) or dir == -1 and value < array.get(pointer, 0)
            array.set(pointer, 0, value)
            array.set(pointer, 1, bindex)
        0.
        
// Number of Decimals for Labels
truncatepercent(number, percentdecimals) =>
    factor = math.pow(10, percentdecimals)
    int(number * factor) / factor

percenttruncate(number, percentdecimals) =>
    factor = math.pow(10, percentdecimals)
    int(number * factor) / factor
    
truncateprice(number, pricedecimals) =>
    factor = math.pow(10, pricedecimals)
    int(number * factor) / factor
    
percent(n1, n2) =>
    ((n1 - n2) / n2) * 100

dir1changed = ta.change(dir1) != 0
if not na(highs) or not na(lows)
    if dir1changed
        add_to_zigzag(ziggyzags, dir1 == 1 ? highs : lows, bar_index)
    else
        update_zigzag(ziggyzags, dir1 == 1 ? highs : lows, bar_index, dir1)
        
// Retrace Targets: (A-C)+B script, see book page 75: "We can also calculate the upside target by obtaining the difference between points "B" and "Ref'
rtt = (ta.valuewhen(not na(highs) or not na(lows), close, 2) - ta.valuewhen(not na(highs) or not na(lows), close, 0)) + ta.valuewhen(not na(highs) or not na(lows), close, 1)
// Stop Loss: Calculated as the high for the leftbars variable ('Bars to the left' setting)
lsl = ta.lowest(low,leftbars)
ssl = ta.highest(high,leftbars)

if array.size(ziggyzags) >= 6
    var line zzline1 = na
    var label zzlabel1 = na
    
    float val = array.get(ziggyzags, 0)
    int point = math.round(array.get(ziggyzags, 1))
    
    var float prevVal = na
    var int prevPoint = na

    bool hasValChanged = na(prevVal) or val != prevVal
    bool hasPointChanged = na(prevPoint) or point != prevPoint

    prevVal := val
    prevPoint := point

    if hasValChanged or hasPointChanged
        float val1 = array.get(ziggyzags, 2)
        int point1 = math.round(array.get(ziggyzags, 3))
        
        plabel = "∆y " + str.tostring(percenttruncate(val - val1, percentdecimals))
          + ", " + str.tostring(percenttruncate(percent(val, val1), percentdecimals)) + ' %'
          + "\n⏱ ∆x " + str.tostring(point - point1) + " bars"
          + "\n📍 RSI " + str.tostring(percenttruncate(prsi, percentdecimals))
          + "\n🎯 " + str.tostring(rtt) + ", " + str.tostring(percenttruncate(percent(rtt, ta.valuewhen(highs or lows != 0, close, 0)), percentdecimals)) + " %"
          + "\n🛑 " + str.tostring(highs ? ssl : lsl) + ", " + str.tostring(percenttruncate(percent(highs ? ssl : lsl, ta.valuewhen(highs or lows != 0, close, 0)), percentdecimals)) + " %"
        // 
        var float prevVal1 = na
        var int prevPoint1 = na

        bool hasVal1Changed = na(prevVal1) or val1 != prevVal1
        bool hasPoint1Changed = na(prevPoint1) or point1 != prevPoint1

        prevVal1 := val1
        prevPoint1 := point1

        if not hasVal1Changed and not hasPoint1Changed
            if not na(zzline1)
                line.delete(zzline1)
            if not na(zzlabel1)
                label.delete(zzlabel1)
        // 
        if showline
            zzline1 := line.new(x1=point, x2=point1, y1=val, y2=val1, color=dir1 == 1 ? upcolor : downcolor, width=zigwidth, style=zigstyle == '-----' ? line.style_dashed : line.style_dotted)
       //
        labelcol = dir1 == 1 ? array.get(ziggyzags, 0) > out ? upcolor : downcolor : array.get(ziggyzags, 0) < out ? downcolor : upcolor

        if showperc
            zzlabel1 := label.new(x=point, y=val, text=str.tostring(truncateprice(close, pricedecimals)), size=pppsize, color=color.new(labelcol, 100), textcolor=dir1 == 1 ? downcolor : upcolor, style=dir1 == 1 ? label.style_label_down : label.style_label_up, tooltip=plabel)

//-------------------------Heiken Ashi Candles--------------------------------//
hkClose         = (open + high + low + close) / 4
hkOpen          = float(na)
hkOpen          := na(hkOpen[1]) ? (open + close) / 2 : (nz(hkOpen[1]) + nz(hkClose[1])) / 2
hkHigh          = math.max(high, math.max(hkOpen, hkClose))
hkLow           = math.min(low,  math.min(hkOpen, hkClose))

candletype      = input.string  ("None",      
  "Candle Type",  
  options = ["Hollow", "Bars", "Candles", "None"],      
  group = grhaco, 
  tooltip = "User will have to 'Mute' the main series bar using the 👁 symbol when hovering over ticker id. The Complete RSI book pg 25: 'Build a chart using Japanese Candlesticks in whatever timeframe you prefer, print 30 pages of charts, identify the tops and bottoms, and begin looking for candlestick patterns.'")

BodyBull        = input.color   (brightgreen,       "Body",             inline="a",         group=grhaco)
BodyBear        = input.color   (brightred,       "Body",             inline="a",         group=grhaco)
BorderBull      = input.color   (color.new(brightgreen,100),       "Border",             inline="b",         group=grhaco)
BorderBear      = input.color   (color.new(brightred,100),       "Border",             inline="b",         group=grhaco)
WickBull        = input.color   (brightgreen,       "Wick",             inline="c",         group=grhaco)
WickBear        = input.color   (brightred,       "Wick",             inline="c",         group=grhaco)

hollow          = candletype == "Hollow" 
bars            = candletype == "Bars"
candle          = candletype == "Candles"

plotcandle(
  hkOpen, hkHigh, hkLow, hkClose, 
  "Hollow Candles",
  hollow ?      hkClose <   hkOpen  ?   BodyBear :  na :        candle ?        hkClose < hkOpen ?  BodyBear : BodyBull : na,
  hollow or     candle ?    hkClose <    hkOpen  ?  WickBear :  WickBull :      na,
  bordercolor = hollow or   candle ?    hkClose  <  hkOpen   ?  BorderBear :    BorderBull : na,
  editable=false)

plotbar(
  hkOpen, hkHigh, hkLow, hkClose,
  "Bars",
  bars ? hkClose < hkOpen ? BodyBear : BodyBull : na,
  editable=false)
  
//-------------------------------Trend Lines----------------------------------//
n = bar_index
src_new = close

showtl = input(false, "Show Trend Lines?", group=grtl) 
pivot_period = input.int(defval=8, title='Pivot Point Period', minval=5, maxval=50, group=grtl)
PPnum = input.int(defval=3, title='Number of Pivot Point to check', minval=2, maxval=3, group=grtl)
trendstyle = input.string(defval='.....', title='Trend Line Style', options=['.....', '-----'], group=grtl)

float ph_new = na
float pl_new = na
ph := ta.pivothigh(src, prd, prd)
pl := ta.pivotlow(src, prd, prd)

getloc(bar_i) =>
    _ret = bar_index + prd - bar_i
    _ret

// Вызов ta.valuewhen должен использовать булевое выражение, здесь ph и pl
t1pos = ta.valuewhen(not na(ph), bar_index, 0)
t1val = nz(src[getloc(t1pos)])
t2pos = ta.valuewhen(not na(ph), bar_index, 1)
t2val = nz(src[getloc(t2pos)])
t3pos = ta.valuewhen(not na(ph), bar_index, 2)
t3val = nz(src[getloc(t3pos)])

b1pos = ta.valuewhen(not na(pl), bar_index, 0)
b1val = nz(src[getloc(b1pos)])
b2pos = ta.valuewhen(not na(pl), bar_index, 1)
b2val = nz(src[getloc(b2pos)])
b3pos = ta.valuewhen(not na(pl), bar_index, 2)
b3val = nz(src[getloc(b3pos)])

getloval(l1, l2) =>
    _ret1 = l1 == 1 ? b1val : l1 == 2 ? b2val : l1 == 3 ? b3val : 0
    _ret2 = l2 == 1 ? b1val : l2 == 2 ? b2val : l2 == 3 ? b3val : 0
    [_ret1, _ret2]

getlopos(l1, l2) =>
    _ret1 = l1 == 1 ? b1pos : l1 == 2 ? b2pos : l1 == 3 ? b3pos : 0
    _ret2 = l2 == 1 ? b1pos : l2 == 2 ? b2pos : l2 == 3 ? b3pos : 0
    [_ret1, _ret2]

gethival(l1, l2) =>
    _ret1 = l1 == 1 ? t1val : l1 == 2 ? t2val : l1 == 3 ? t3val : 0
    _ret2 = l2 == 1 ? t1val : l2 == 2 ? t2val : l2 == 3 ? t3val : 0
    [_ret1, _ret2]

gethipos(l1, l2) =>
    _ret1 = l1 == 1 ? t1pos : l1 == 2 ? t2pos : l1 == 3 ? t3pos : 0
    _ret2 = l2 == 1 ? t1pos : l2 == 2 ? t2pos : l2 == 3 ? t3pos : 0
    [_ret1, _ret2]

var line l1 = na
var label l1a = na 
var line l2 = na
var label l2a = na
var line l3 = na
var label l3a = na
var line t1 = na
var label t1a = na
var line t2 = na
var label t2a = na
var line t3 = na
var label t3a = na

line.delete(l1)
label.delete(l1a[1]) 
line.delete(l2)
label.delete(l2a[1])
line.delete(l3)
label.delete(l3a[1])
line.delete(t1)
label.delete(t1a[1])
line.delete(t2)
label.delete(t2a[1])
line.delete(t3)
label.delete(t3a[1])

countlinelo = 0
countlinehi = 0
for p1 = 1 to PPnum - 1 by 1
    uv1 = 0.0
    uv2 = 0.0
    up1 = 0
    up2 = 0
    for p2 = PPnum to p1 + 1 by 1
        [val1, val2] = getloval(p1, p2)
        [pos1, pos2] = getlopos(p1, p2)
        if val1 > val2
            diff = (val1 - val2) / (pos1 - pos2)
            hline = val2 + diff
            lloc = bar_index
            lval = src
            valid = true
            for x = pos2 + 1 - prd to bar_index by 1
                if nz(src[getloc(x + prd)]) < hline
                    valid := false
                    valid
                lloc := x
                lval := hline
                hline += diff
                hline
            if valid
                uv1 := hline
                uv2 := val2
                up1 := lloc
                up2 := pos2
                break
    dv1 = 0.0
    dv2 = 0.0
    dp1 = 0
    dp2 = 0
    for p2 = PPnum to p1 + 1 by 1
        [val1, val2] = gethival(p1, p2)
        [pos1, pos2] = gethipos(p1, p2)
        if val1 < val2
            diff = (val2 - val1) / (pos1 - pos2)
            hline = val2 - diff
            lloc = bar_index
            lval = rsi
            valid = true
            for x = pos2 + 1 - prd to bar_index by 1
                if nz(src[getloc(x + prd)]) > hline
                    valid := false
                    break
                lloc := x
                lval := hline
                hline -= diff
                hline
            if valid
                dv1 := hline
                dv2 := val2
                dp1 := lloc
                dp2 := pos2
                break
    if up1 != 0 and up2 != 0 and showtl
        countlinelo += 1
        l1 := countlinelo == 1 ? line.new(up2 - prd, uv2, up1, uv1, color=green, style=trendstyle == '-----' ? line.style_dashed : line.style_dotted) : l1
        l2 := countlinelo == 2 ? line.new(up2 - prd, uv2, up1, uv1, color=green, style=trendstyle == '-----' ? line.style_dashed : line.style_dotted) : l2
        l3 := countlinelo == 3 ? line.new(up2 - prd, uv2, up1, uv1, color=green, style=trendstyle == '-----' ? line.style_dashed : line.style_dotted) : l3
        l3
        
    if dp1 != 0 and dp2 != 0 and showtl
        countlinehi += 1 // truncateprice(dp1-(dp2-prd),pricedecimals)
        t1 := countlinehi == 1 ? line.new(dp2 - prd, dv2, dp1, dv1, color=red, style=trendstyle == '-----' ? line.style_dashed : line.style_dotted) : t1
        t2 := countlinehi == 2 ? line.new(dp2 - prd, dv2, dp1, dv1, color=red, style=trendstyle == '-----' ? line.style_dashed : line.style_dotted) : t2
        t3 := countlinehi == 3 ? line.new(dp2 - prd, dv2, dp1, dv1, color=red, style=trendstyle == '-----' ? line.style_dashed : line.style_dotted) : t3
        t3

//------------------------------Fibonacci Retracements------------------------//
showfr = input(false, title='Show Fibonacci Retracements?', group=grfrt, tooltip="Hover over labels for additional info.\nPage 41: The level of the retracement is a strong indication of the trend strength.")
FP = input(21, title='Candles to Lookback', group=grfrt)
fibsize=input.string(size.tiny, title="Fibonacci Retracement Label Size", options=[size.normal, size.small, size.tiny], group=grfrt)
Reverse = input(false, title='Reverse Fibonacci Levels?', group=grfrt)
Mid_Color = input(#787b86, title='Lines & 50 Label Color', group=grfrt)
CurrentFib = input(false, 'Show Fib Level of Current Price', group=grfrt)
Current_Color = input(yellow, title='Current Fibonacci Level Label Color', group=grfrt)
LineStyle = input.string('-----', options=['.....', '-----'], title='Line Style', group=grfrt)
LineWidth = 1 // input.int(1, minval=1, maxval=3, title='Line Width', group=grfrt)
fiblinetransp = input.int(50, minval=1, maxval=100, title='Line Transparency', group=grfrt)
currentfiboffset = input.int(4, 'Current Fibonacci Level Horizontal Offset', group=grfrt, minval=-50, maxval=10)
Ext = false
FPeriod = FP

Fhigh = ta.highest(FPeriod) 
Flow = ta.lowest(FPeriod)
FH = ta.highestbars(high, FPeriod)
FL = ta.lowestbars(low, FPeriod)
revfibs = not Reverse ? FL > FH : FL < FH

Fib_x(n) =>
    revfibs ? (Fhigh - Flow) * n + Flow : Fhigh - (Fhigh - Flow) * n

Current = revfibs ? (close - Flow) / (Fhigh - Flow) : (Fhigh - close) / (Fhigh - Flow)

var label Current_Fib_Label = na
label.delete(Current_Fib_Label)

if CurrentFib and barstate.islast and showfr 
    Current_Fib_Label := label.new(bar_index + currentfiboffset, close, str.tostring(truncateprice(Current, pricedecimals)), 
      textcolor=Current_Color, color=color.new(#000000, 100), style=label.style_label_left, yloc=yloc.price, 
      size=fibsize, tooltip=str.tostring(truncateprice(close, pricedecimals)))
    Current_Fib_Label

EXTEND = Ext ? extend.left : extend.none
STYLE = LineStyle == '.....' ? line.style_dotted : line.style_dashed
WIDTH = LineWidth

BB = FL < FH ? bar_index[-FL] : bar_index[-FH] 

Fib_line(x) =>
    var line ln = na
    line.delete(ln)
    if showfr 
        ln := line.new(BB, x, bar_index, x, color=color.new(Mid_Color,fiblinetransp), extend=EXTEND, style=STYLE, width=WIDTH)
        ln
    
Fib0 = Fib_line(Fib_x(0))
Fib146 = Fib_line(Fib_x(0.146))
Fib236 = Fib_line(Fib_x(0.236))
Fib382 = Fib_line(Fib_x(0.382))
Fib500 = Fib_line(Fib_x(0.500))
Fib618 = Fib_line(Fib_x(0.618))
Fib786 = Fib_line(Fib_x(0.763))
Fib886 = Fib_line(Fib_x(0.854))
Fib1000 = Fib_line(Fib_x(1.000))

// Define labels 
Fib_label(x, _txt, lcol, tip) =>
    var label lbl = na
    label.delete(lbl)
    if showfr
        lbl := label.new(bar_index, x, _txt, textcolor=lcol, color=color.new(#000000,100), style=label.style_label_left, yloc=yloc.price, size=fibsize, tooltip="📍 " + str.tostring(truncateprice(x, pricedecimals)) + tip) 
        lbl

// Display labels with Hayden targets
LFib0 = Fib_label(Fib_x(0), '0.0', brightgreen, ' = 0 %' + '\n🤑 Strongest Trend \n'+'🎯 '+ str.tostring(truncateprice(FL>FH?(Fib_x(0)-(Fhigh - Flow)):(Fib_x(0)+(Fhigh - Flow)), pricedecimals)))
LFib146 = Fib_label(Fib_x(0.146), '0.146', brightgreen, ' = 14.6 %' + '\n🥳 Very Strong Trend \n'+'🎯 '+ str.tostring(truncateprice(FL>FH?(Fib_x(0.146)-(Fhigh - Flow)):(Fib_x(0.146)+(Fhigh - Flow)), pricedecimals)))
LFib236 = Fib_label(Fib_x(0.236), '0.236', brightgreen, ' = 23.6 %' + '\n🤩 Strong Trend \n'+'🎯 '+ str.tostring(truncateprice(FL>FH?(Fib_x(0.236)-(Fhigh - Flow)):(Fib_x(0.236)+(Fhigh - Flow)), pricedecimals)))
LFib382 = Fib_label(Fib_x(0.382), '0.382', brightgreen, ' = 38.2 %' + '\n😎 Medium Strong Trend \n'+'🎯 '+ str.tostring(truncateprice(FL>FH?(Fib_x(0.382)-(0.8*(Fhigh - Flow))):(Fib_x(0.382)+(0.8*(Fhigh - Flow))), pricedecimals)))
LFib500 = Fib_label(Fib_x(0.500), '0.5', Mid_Color, ' = 50 %' + '\n😐 Medium Trend \n'+'🎯 '+ str.tostring(truncateprice(FL>FH?(Fib_x(0.5)-(0.8*(Fhigh - Flow))):(Fib_x(0.5)+(0.8*(Fhigh - Flow))), pricedecimals)))
LFib618 = Fib_label(Fib_x(0.618), '0.618', brightred, ' = 61.8 %' + '\n😕Medium Weak Trend \n'+'🎯 '+ str.tostring(truncateprice(FL>FH?(Fib_x(0.618)-(0.8*(Fhigh - Flow))):(Fib_x(0.618)+(0.8*(Fhigh - Flow))), pricedecimals)))
LFib786 = Fib_label(Fib_x(0.763), '0.763', brightred, ' = 76.3 %' + '\n😬 Weak Trend \n'+'🎯 '+ str.tostring(truncateprice(FL>FH?(Fib_x(0.763)-(0.8*(Fhigh - Flow))):(Fib_x(0.763)+(0.8*(Fhigh - Flow))), pricedecimals)))
LFib886 = Fib_label(Fib_x(0.854), '0.854', brightred, ' = 85.4 %' + '\n😨 Very Weak Trend \n'+'🎯 '+ str.tostring(truncateprice(FL>FH?(Fib_x(0.854)-(0.8*(Fhigh - Flow))):(Fib_x(0.854)+(0.8*(Fhigh - Flow))), pricedecimals)))
LFib1000 = Fib_label(Fib_x(1.000), '1.0', brightred, ' = 100 %' + '\n😱 Invalidated Trend \n'+'🎯 '+ str.tostring(truncateprice(FL>FH?(Fib_x(1.0)-(0.8*(Fhigh - Flow))):(Fib_x(1.0)+(0.8*(Fhigh - Flow))), pricedecimals)))

// ------------------------- Trend State ------------------------------------ //
showtrend = input(false, title='Show Hayden triple trend state background?',group=grhts, 
  tooltip = "Check this box if you want to see the Bull, Bear, or Chop trend state background according to Hayden.\nFor best results, these settings should match the settings in Hayden's Advanced RSI oscillator.\n(Page 56) 10 Lies That Traders Believe = The RSI is unable to indicate trend direction, because it's only a momentum indicator.")
ts1 = input.float(defval=67, title="Precise Bullish RSI Crossover 66 to 68", minval=66, maxval=68, step=0.001, group=grhts, tooltip="End of chop. Popular: 66, 66.666, or 67")
ts2 = input.float(defval=33, title="Precise Bearish RSI Crossunder 32 to 34", minval=32, maxval=34, step=0.001, group=grhts, tooltip="End of chop. Popular: 34, 33.333, or 33")
ts1a = input.float(defval=61, title="Precise Bullish RSI Crossover 60 to 62", minval=60, maxval=62, step=0.001, group=grhts, tooltip="End of bearish trend. Popular: 61, 60.618, 60.5, or 60")
ts2a = input.float(defval=39, title="Precise Bearish RSI Crossunder 38 to 40", minval=38, maxval=40, step=0.001, group=grhts, tooltip="End of bullish trend. Popular: 39, 39.5, 39.618, or 40")
// Trend State
var state = 0
if ta.crossover(rsi, ts1)
    state := 1
    state
if ta.crossunder(rsi, ts2) 
    state := 2
    state
if state == 1 and ta.crossunder(rsi, ts2a)
    state := 3
    state
if state == 2 and ta.crossover(rsi, ts1a)
    state := 3
    state
state := state

bgcol=showtrend and state==1?green : showtrend and state==2?red : na
bgcolor(color.new(bgcol,80))

//-------------------------------Watermark------------------------------------//
// Watermark tooltips (hover)
q1 = "Look first / Then leap." 
q2 = "TradeStation™ Charting by Omega Research and Epsilon Charting"
q3 = "Made w/ ❤ by © 🦶 DM"
// Watermark Displays
str1 = "DM"
str2 = "TradeStation™" 
str3 = "🦶 DM"

// Need to toggle timeframe gaps if there are too many on MTF
showwatermark = input(true, 'Show Watermark?', group=grwm, tooltip="Hover over watermark for additional info.")
wmstring = input.string("TV", title="Watermark Display Text", options=["DM", "TradeStation", "TV", "Custom"], group=grwm)
name = input(defval='Your name', title="Custom Watermark Text", group=grwm, tooltip="Emojis allowed!")
watermarktransp = input.int(30, 'Watermark Transparency', minval=0, maxval=100, group=grwm)
watermarkxoffset = input.int(-10, 'Watermark Horizontal Offset', group=grwm , minval=-50, maxval=5)
watermarklocation = input.string(yloc.belowbar, options=[yloc.belowbar, yloc.abovebar], title='Watermark Location', group=grwm)
wmsize = input.string(size.normal, title="Watermark Size", options=[size.normal, size.small, size.tiny], group=grwm)

whichwm = wmstring == "DM" ? str3 :wmstring =="TradeStation"? str2 : wmstring == "TV" ? str1 : name
whichtt = wmstring == "TradeStation" ? q2 : wmstring == "TV"? q1 : q3

// Watermark Close
target_index = bar_index + watermarkxoffset
wmPrice = ta.valuewhen(bar_index == target_index, close, 0)

// Label
if showwatermark
    var label watermark = na
    watermark := label.new(bar_index + watermarkxoffset,  y=wmPrice, yloc=watermarklocation, size=wmsize, text=whichwm, style=label.style_none, textcolor=color.new(gray,watermarktransp),tooltip=whichtt)
    label.delete(watermark[1])
    
// ------------------------ Advanced Data Ticker ---------------------------- //
showticker = input(true, "Show Tickers?", group=grtk)
datatype = input.string('None', 
  title = 'Ticker 1 Data Source?', 
  options = ['RSI to Price', "MA Price", 'Trend End', 'Trend State', 'ADX & DI+/-', "Watermark", "Volatility", "None"], 
  group = grtk)
datatype2 = input.string('ADX & DI+/-', 
  title = 'Ticker 2 Data Source?', 
  options = ['RSI to Price', "MA Price", 'Trend End', 'Trend State', 'ADX & DI+/-', "Watermark", "Volatility", "None"],  
  group = grtk)

// Code Conversion
r45maout = slowmaout
rsma = fastma
rwmacolv = slowcolv
rsmacolv = fastcolv
len_rsi = prsilen
targetsrc = src

price_by_rsi(level) =>
    x1_local = (len_rsi - 1) * (ta.rma(math.max(nz(targetsrc[1], targetsrc) - targetsrc, 0), len_rsi) * level / (100 - level) - ta.rma(math.max(targetsrc - nz(targetsrc[1], targetsrc), 0), len_rsi))
    x1_local >= 0 ? targetsrc + x1_local : targetsrc + x1_local * (100 - level) / level

// RSI to Price Target Inputs
obLevel1 = input.float(80, title='RSI to Price Target 1', minval=1, maxval=99, group=grtk, 
  tooltip ="Table #8 Fibonacci Bullish RSI Levels: 61.8, 66.67, 76.30, 85.42, 90.98, 94.43\n(Page 56) 10 Lies That Traders Believe = The RSI will generally 'top out' somewhere around the 70 level.")
osLevel1 = input.float(20, title='RSI to Price Target 2', minval=1, maxval=99, group=grtk, 
  tooltip ="Table #8 Fibonacci Bearish RSI Levels: 38.2, 33.33, 23.61, 14.59, 9.02, 5.57\n(Page 56) 10 Lies That Traders Believe = The RSI will generally 'bottom out' somewhere around the 30 level.")
// Functional Math and RSI Targets
ep = 2 * 14 - 1
auc = ta.ema(math.max(src - src[1], 0), ep)
adc = ta.ema(math.max(src[1] - src, 0), ep)
x1_new = (14 - 1) * (adc * obLevel1 / (100 - obLevel1) - auc)
longrsitarget = x1 >= 0 ? src + x1 : src + x1 * (100 - obLevel1) / obLevel1
x2_new = (14 - 1) * (adc * osLevel1 / (100 - osLevel1) - auc)
shortrsitarget = x2 >= 0 ? src + x2 : src + x2 * (100 - osLevel1) / osLevel1
// Text
tickerstateob = (str.tostring(obLevel1) + " 🎯 = " + str.tostring(truncateprice(longrsitarget,pricedecimals)))
tickerstateos = (str.tostring(osLevel1) + " 🎯 = " + str.tostring(truncateprice(shortrsitarget,pricedecimals)))
// Plots
roblcol = input.color(aqua, title="RSI to Price Target 1 Color", group=grtk)
roslcol = input.color(fuchsia, title="RSI to Price Target 2 Color", group=grtk)
// Shape Plots
plotshape(datatype=="RSI to Price" or datatype2=="RSI to Price" ?price_by_rsi(obLevel1):na, title="User-defined RSI to Price Target 1", location=location.absolute, style=shape.cross, color=color.new(roblcol, 0), show_last=1)
plotshape(datatype=="RSI to Price" or datatype2=="RSI to Price" ?price_by_rsi(osLevel1):na, title="User-defined RSI to Price Target 2", location=location.absolute, style=shape.cross, color=color.new(roslcol, 0), show_last=1)

// MA Price Targets
// Emoji Rating
erating = (slowmaout>slowmaout[1] and slowmaout>slowmaout[1])?" 🚀 ":
 (slowmaout<slowmaout[1] and rsma<rsma[1])?" 💀 ":"  🪓 "
// Text
tickerstaterwma = ("45 "+ (r45ma == 'WMA' ? "WMA" : "EMA") + " = " + str.tostring(truncateprice(slowmaout, pricedecimals))) + "  " + erating
tickerstatersma = ("9 SMA = " + str.tostring(truncateprice(fastma, pricedecimals)))
// Text Color
rwmatcol2=rwmacolv
rsmatcol2=rsmacolv

// Trend Ends Text
// Fib variables
fr1 = 0
fr3 = 14.59
fr5 = 23.61
fr7 = ts2
fr9 = ts2a
fr11 = 50
fr13 = ts1a
fr16 = ts1
fr18 = 76.3
fr20 = 85.41
fr21 = 100
tickerstateendbull = ("🐮 Bullish above " + str.tostring(truncateprice(price_by_rsi(fr9),pricedecimals)))
tickerstateendbear = ("🐻 Bearish below " + str.tostring(truncateprice(price_by_rsi(fr13),pricedecimals)))
tickerstateendbullchop = ("Bullish above " + str.tostring(truncateprice(price_by_rsi(fr16),pricedecimals)))
tickerstateendbearchop = ("🪓 Bearish below " + str.tostring(truncateprice(price_by_rsi(fr7),pricedecimals)))

// Trend State Text
bulltrend = rsi>r45maout and rsi>rsma and state==1
tickerstatebulltrend = ("📈 Bullish " + (bulltrend?"Trend 🚀":"Chop 🪓"))
beartrend = rsi<r45maout and rsi<rsma and state==2
tickerstatebeartrend = ("📉 Bearish " + (beartrend?"Trend 💀":"Chop 🪓"))
chopbear = state==3 and rsi<r45maout
tickerstatechoptrend = ("🪓 Chop with " + (chopbear?"Bearish 💀":"Bullish 🚀") + " Sentiment")
trendstatedisplay = state==1?tickerstatebulltrend:state==2?tickerstatebeartrend:state==3?tickerstatechoptrend:na
// Trend State Text Color
tstextcol = state==1 and bulltrend ?brightgreen : 
  state==1 and not bulltrend?green : 
  state==2 and beartrend ? brightred : 
  state==2 and not beartrend ? red : 
  state==3 and chopbear ? red : 
  state==3 and not chopbear ? green : na

// ADX & DI Data
[_, _, adx1] = ta.dmi(17, 4)
adxlen = 14
dilen = 14
dirmov(len) =>
    up = ta.change(high)
    down = -ta.change(low)
    truerange = ta.rma(ta.tr, len)
    plus = fixnan(100 * ta.rma(up > down and up > 0 ? up : 0, len) / truerange)
    minus = fixnan(100 * ta.rma(down > up and down > 0 ? down : 0, len) / truerange)
    [plus, minus]
adx(dilen, adxlen) =>
    [plus, minus] = dirmov(dilen)
    sum = plus + minus
    adx = 100 * ta.rma(math.abs(plus - minus) / (sum == 0 ? 1 : sum), adxlen)
    adx
adxHigh(dilen, adxlen) =>
    [plus, minus] = dirmov(dilen)
    plus
adxLow(dilen, adxlen) =>
    [plus, minus] = dirmov(dilen)
    minus
sig = adx(dilen, adxlen)
sigHigh = adxHigh(dilen, adxlen)
sigLow = adxLow(dilen, adxlen)
sigTop = sigHigh>sigLow?sigHigh:sigLow
// Text
adxtext = 'ADX ' + str.tostring(truncatepercent(adx1, percentdecimals)) 
  + (adx1>adx1[1] ? ' & 📈' : ' & 📉') 
  + (adx1<25?' 💤':adx1>25 and adx1<50 ?' 💪':adx1>50 and adx1<75 ?' 🔥':adx1>75 and adx1<100 ?' 🚀':'')
ditext = 'DI ' + str.tostring(truncatepercent(sigTop, percentdecimals)) 
  + (sigTop>sigTop[1] and sigHigh>sigLow? ' & 📈 🐮' : sigTop<sigTop[1] and sigHigh>sigLow ? ' & 📉 🪓': sigTop>sigTop[1] and sigHigh<sigLow ? ' & 📈 🐻' : sigTop<sigTop[1] and sigHigh<sigLow ? ' & 📉 🪓':na) 
// Text Color
adxtextcol = color.new(
  sigHigh > sigLow and adx1 < 25 ? green: 
  sigHigh > sigLow and adx1 > 25 ? brightgreen: 
  sigHigh < sigLow and adx1 > 25 ? brightred: 
  sigHigh < sigLow and adx1 < 25 ? red: 
  gray, 0)
ditextcol = color.new(
  sigHigh > sigLow and sigTop<sigTop[1] ? green: 
  sigHigh > sigLow and sigTop>sigTop[1] ? brightgreen: 
  sigHigh < sigLow and sigTop>sigTop[1] ? brightred: 
  sigHigh < sigLow and sigTop<sigTop[1] ? red: 
  gray, 0)
  
// Volatility
lowvolcol = input.color(color.rgb(250,237,56,1), "Low Volatility Gradient Color", group=grtk)
highvolcol = input.color(color.rgb(255,37,174,1), "High Volatility Gradient Color", group=grtk)
f_volatility() =>
	atr = ta.atr(14)
	stdAtr = 2*ta.stdev(atr,20)
	smaAtr = ta.sma(atr,20)
	topAtrDev = smaAtr+stdAtr
	bottomAtrDev = smaAtr-stdAtr
	calcDev = (atr-bottomAtrDev)/(topAtrDev-bottomAtrDev)
	percentVol = (40*calcDev+30)
volatility = f_volatility()
volatilitydir = volatility>volatility[1]?" & 📈":" & 📉"
volemoji = volatility > 0 and volatility < 20 ? "😴" : volatility > 20 and volatility < 40 ? " 😐" : volatility > 40 and volatility < 60 ? " 😬" : volatility > 60 and volatility < 80 ? " 😮" : volatility > 80 and volatility < 100 ? " 😵" : " 🤯" 
voltxt = "Volatility = " + str.tostring(truncatepercent(volatility, percentdecimals)) + " %" + volemoji + volatilitydir 
volcol = color.from_gradient(volatility,25,75,lowvolcol,highvolcol)

// Dual Ticker Display
watermark = input("Your name", title="Custom Trader WaterMark Text", group=grtk, tooltip="Emojis allowed!")
WMtxtcol = input(gray, title="WaterMark Text Color", group=grtk)
Ttransp=input(20, title="Ticker Text Transparency", group=grtk)

position = input.string(position.top_center, "Ticker 1 Position", [position.top_center, position.top_right, position.middle_right, position.bottom_right, position.bottom_center, position.bottom_left, position.middle_left, position.top_left], group=grtk)
size = input.string(size.small, "Ticker 1 Size", [size.tiny, size.small, size.normal, size.large, size.huge], group=grtk)
var table Ticker = na
Ticker := table.new(position, 2, 1)
if barstate.islast and showticker
    table.cell(Ticker, 0, 0, 
      text = datatype=="RSI to Price"?tickerstateob:datatype=="MA Price"?tickerstaterwma:datatype=="Trend End" and state ==1?tickerstateendbull:datatype=="Trend End" and state ==3?tickerstateendbullchop:datatype=="ADX & DI+/-"?adxtext:datatype=="Watermark"?watermark:na, //datatype=="Trend State"?"Trend: ":
      text_size = size, 
      text_color = color.new(datatype=="RSI to Price"?roblcol:datatype=="MA Price"?rwmatcol2:datatype=="Trend End" and (state==3 or state==1)?green:datatype=="ADX & DI+/-"?adxtextcol:gray,Ttransp),
      tooltip=datatype=="Watermark"?q3:na)
    table.cell(Ticker, 1, 0, 
      text = datatype=="RSI to Price"?tickerstateos:datatype=="MA Price"?tickerstatersma:datatype=="Trend End" and state ==2?tickerstateendbear:datatype=="Trend End" and state ==3?tickerstateendbearchop:datatype=="ADX & DI+/-"?ditext:datatype=="Trend State"?trendstatedisplay:datatype=="Volatility"?voltxt:na, 
      text_size = size, 
      text_color = color.new(datatype=="RSI to Price"?roslcol:datatype=="MA Price"?rsmatcol2:datatype=="Trend End" and (state==3 or state==2)?red:datatype=="ADX & DI+/-"?ditextcol:datatype=="Trend State"?tstextcol:datatype=="Volatility" ? volcol :gray,Ttransp))
position2 = input.string(position.bottom_center, "Ticker 2 Position", [position.top_center, position.top_right, position.middle_right, position.bottom_right, position.bottom_center, position.bottom_left, position.middle_left, position.top_left], group=grtk)
size2 = input.string(size.small, "Ticker 2 Size", [size.tiny, size.small, size.normal, size.large, size.huge], group=grtk)
var table Ticker2 = na
Ticker2 := table.new(position2, 2, 1)
if barstate.islast and showticker
    table.cell(Ticker2, 0, 0,
      text = datatype2=="RSI to Price"?tickerstateob:datatype2=="MA Price"?tickerstaterwma:datatype2=="Trend End" and state ==1?tickerstateendbull:datatype2=="Trend End" and state ==3?tickerstateendbullchop:datatype2=="ADX & DI+/-"?adxtext:datatype2=="Watermark"?watermark:na, //datatype=="Trend State"?"Trend: ":
      text_size = size2, 
      text_color = color.new(datatype2=="RSI to Price"?roblcol:datatype2=="MA Price"?rwmatcol2:datatype2=="Trend End" and (state==3 or state==1)?green:datatype2=="ADX & DI+/-"?adxtextcol:gray,Ttransp),
      tooltip=datatype=="Watermark"?q3:na)
    table.cell(Ticker2, 1, 0, 
      text = datatype2=="RSI to Price"?tickerstateos:datatype2=="MA Price"?tickerstatersma:datatype2=="Trend End" and state ==2?tickerstateendbear:datatype2=="Trend End" and state ==3?tickerstateendbearchop:datatype2=="ADX & DI+/-"?ditext:datatype2=="Trend State"?trendstatedisplay:datatype2=="Volatility"?voltxt:na, 
      text_size = size2, 
      text_color = color.new(datatype2=="RSI to Price"?roslcol:datatype2=="MA Price"?rsmatcol2:datatype2=="Trend End" and (state==3 or state==2)?red:datatype2=="ADX & DI+/-"?ditextcol:datatype2=="Trend State"?tstextcol:datatype2=="Volatility" ? volcol :gray,Ttransp))

//------------------------------------------------------------------------------------------- END --------------------------------------------------------------------------------//