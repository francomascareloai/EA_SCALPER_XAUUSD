//@version=5

//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//$                                                                                 $
//$ Благодарность приветствуется!                                                   $
//$ Gratitude is appreciated!                                                       $
//$                                                                                 $
//$ Вы можете сделать пожертвование через:                                          $
//$ You may donate via:                                                             $
//$                                                                                 $
//$ Крипто-мультивалютный кошелек                                                   $
//$ Crypto-multi-currency wallet                                                    $
//$ https://tinyurl.com/4f9dr9nw                                                    $
//$                                                                                 $
//$    - BTC: 1EpDN7pg1WqURcK7te5kQtgx3H17wuHiV7                                    $
//$                                                                                 $
//$    - LTC: MJyEtVt7EFmA18Bo1vjRMbguivHnVbbWvp                                    $
//$                                                                                 $
//$ - Tether TRC20 (USDT): TWQdh36osEJ3mDrG7kGEHgSVHQSgSR61ZY                       $
//$                                                                                 $
//$ Пожертвуйте столько, сколько считаете нужным.                                   $
//$ Donate as much as you see fit.                                                  $
//$                                                                                 $
//$ Сделайте это, если найдете этот материал полезным!                              $
//$ Do it if you find the stuff useful!                                             $
//$                                                                                 $
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

indicator(shorttitle='*DBBS*', title='<[$/Double Bollinger Bands Signals/$]>', overlay=true)

length = input.int(20, minval=1)
src = input(close, title='Source')
mult = input.float(2.0, minval=0.001, maxval=50)
basis = ta.sma(src, length)
dev = mult * ta.stdev(src, length)
upper = basis + dev
lower = basis - dev

plot(upper, color=#e8f90280, style=plot.style_linebr, linewidth=2, title='Upper Band 1')
plot(lower, color=#e8f90280, style=plot.style_linebr, linewidth=2,title='Lower Band 1')

a = high > upper ? upper : na
plot(a, color=#00ff00, style=plot.style_linebr, linewidth=4, title='Upper Breakout 1')
b = low < lower ? lower : na
plot(b, color=#ff0000, style=plot.style_linebr, linewidth=4, title='Lower Breakout 1')

length1 = input.int(20, minval=1, title='Length 2')
src1 = input(close, title='Source 2')
mult1 = input.float(1.0, minval=0.001, maxval=50)
basis1 = ta.sma(src1, length1)
dev1 = mult1 * ta.stdev(src1, length1)
upper1 = basis1 + dev1
lower1 = basis1 - dev1

plot(upper1, color=#fffffe80,style=plot.style_linebr, linewidth=1, title='Upper Band 2')
plot(lower1, color=#fffffe80,style=plot.style_linebr, linewidth=1, title='Lower Band 2')

a1 = high > upper1 ? upper1 : na
plot(a1, color=#00ff00, style=plot.style_linebr, linewidth=4, title='Upper Breakout 2')
b1 = low < lower1 ? lower1 : na
plot(b1, color=#ff0000, style=plot.style_linebr, linewidth=4, title='Lower Breakout 2')

src2 = input(defval=close, title='Source 3')
length2 = input.int(20, minval=1, title='SMA Length 3')

sma = ta.sma(src2, length2)
stdev = ta.stdev(src2, length2)

upper(mul) =>
    sma + stdev * mul
lower(mul) =>
    sma - stdev * mul
mid(mul) =>
    (upper(mul) + lower(mul)) / 2

upperBand3 = plot(upper(4), color=#ff5252, linewidth=1, title='Upper Band 3')
upperBand2 = plot(upper(3), color=#ff5252, linewidth=1, title='Upper Band 2')
upperBand1 = plot(upper(2), color=#ff5252, linewidth=1, title='Upper Band 1')
midBand1   = plot(mid  (2), color=#2196f3, linewidth=1, title='Mid Band 1')
lowerBand1 = plot(lower(2), color=#4caf50, linewidth=1, title='Lower Band 1')
lowerBand2 = plot(lower(3), color=#4caf50, linewidth=1, title='Lower Band 2')
lowerBand3 = plot(lower(4), color=#4caf50, linewidth=1, title='Lower Band 3')

fill(upperBand3, upperBand2, color=#ff525266, title='Fill 1')
fill(upperBand2, upperBand1, color=#ff525233, title='Fill 2')
fill(upperBand1, lowerBand1, color=#2195f31a, title='Fill 3')
fill(lowerBand1, lowerBand2, color=#4caf504d, title='Fill 4')
fill(lowerBand2, lowerBand3, color=#4caf5080, title='Fill 5')

// Водяной знак
watermarki_supp = input.bool(true, "Водяной знак", group="Авторский знак") 

// Позиция водяного знака
string  i_tableYpos_oto_supp = input.string("top", "Положение", inline = "12", options = ["top", "middle", "bottom"])
string  i_tableXpos_oto_supp = input.string("center", "", inline = "12", options = ["left", "center", "right"])

// Размеры водяного знака
int     i_height_oto_supp    = input.int(7, "Высота", minval = 1, maxval = 100, inline = "13")
int     i_width_oto_supp     = input.int(30, "Ширина",  minval = 1, maxval = 100, inline = "13a")

// Цвет текста и фона
color   i_c_text_oto_supp    = input.color(#ffffff, "", inline = "14")
color   _bg_oto_supp    = input.color(#2196f34d, "", inline = "14")

// Размер текста
string  i_textSize  = input.string("normal", "Размер", inline = "14", options = ["tiny", "small", "normal", "large", "huge", "auto"])

// Тексты водяного знака
i_text2_supp =  "💰«УДАЧНОЙ ТОРГОВЛИ»💰"
i_text1_supp =  "💲«ДА ПРИБУДЕТ С ВАМИ ПРОФИТ»💲"

// Создание таблицы для водяного знака
var table watermark_supp = table.new(i_tableYpos_oto_supp + "_" + i_tableXpos_oto_supp, 1, 1)

// Отображение водяного знака
if barstate.islast and watermarki_supp
    varip bool _changeText_supp = true
    _changeText_supp := not _changeText_supp
    string _txt_supp = _changeText_supp ? i_text2_supp : i_text1_supp
    table.cell(watermark_supp, 0, 0, _txt_supp, i_width_oto_supp, i_height_oto_supp, i_c_text_oto_supp, text_size = i_textSize, bgcolor = _bg_oto_supp)

//#!
// Отображение временного интервала
showTF = input.bool(true, "показать временной интервал", inline = "24")
// Отображение префикса заголовка
showpf = input.bool(true, "показать префикс заголовка", inline = "24")

// Позиция заголовка
string  i_tableYpos = input.string("bottom", "Положение", inline = "12", options = ["top", "middle", "bottom"])
string  i_tableXpos = input.string("center", "", inline = "12", options = ["left", "center", "right"])

// Размеры текста заголовка
size1 = input.string("huge", "заголовок", inline = "14", options = ["tiny", "small", "normal", "large", "huge", "auto"])
size2 = input.string("auto", "дополнительно", inline = "14", options = ["tiny", "small", "normal", "large", "huge", "auto"])

// Цвет и текст заголовка
color = input.color(#999999, "цвет")
string = input.string("🕙 DM")
seperator = input.string("/", "разделитель")

cur = syminfo.currency
base = syminfo.basecurrency
exchange = syminfo.prefix
      
// Получение временного интервала
getTimeFrame() =>
    tf = timeframe.multiplier
    tfstr = ""
    if timeframe.isseconds
        tfstr := "с"
    if timeframe.isminutes
        if tf >= 60
            tf := tf / 60
            tfstr := "ч"
        else
            tfstr := "м"
    if timeframe.isdaily
        tfstr := "Д"
    if timeframe.isweekly
        tfstr := "Н"
    if timeframe.ismonthly
        tfstr := "М"  
        
    [tfstr, str.tostring(tf)]
        
// Текущий цвет свечи
get_candle_color() =>
    candleColor = close > open ? #05ff0d : #ff0505
    candleColor

var table table1 = table.new(i_tableYpos + "_" + i_tableXpos , 3, 1)

if barstate.islast
    
    str1 = base + seperator + cur
    [tf, period] = getTimeFrame()

    table.cell(table1, 0, 0, showpf ? exchange : "", text_color = get_candle_color(),  text_size=size2)

    table.cell(table1, 1, 0, str1 + (showTF ? (" " + period + tf) : ""), text_color = get_candle_color(),  text_size=size1)

    table.cell(table1, 2, 0, string, text_color = get_candle_color(),  text_size=size2)
    
// Входные параметры
lengthMA1 = input.int(title='Длина 1', minval=1, defval=120)
lengthMA2 = input.int(title='Длина 2', minval=1, defval=12)
maInput = input.string(title='Тип MA', defval='EMA', options=['EMA', 'SMA', 'VWMA', 'WMA'])
srcMA = input(title='Источник MA', defval=hl2)

srcBB = input(close, title='Источник BB') 

// Функция для расчета скользящей средней
getMA(src, length) =>
    ma = 0.0

    if maInput == 'EMA'
        ma := ta.ema(src, length)
    if maInput == 'SMA'
        ma := ta.sma(src, length)
    if maInput == 'VWMA'
        ma := ta.vwma(src, length)
    if maInput == 'WMA'
        ma := ta.wma(src, length)
    ma

// ТРЕНД С КАХЛМАНОМ
srchull = input(hl2, 'Данные цены')
lengthhull = input(24, 'Период')
showcross = input(true, 'Показывать пересечения')
gain = input(10000, 'Прибыль')
k = input(true, 'Использовать Кахлмана')

// Функция для расчета Hull MA
hullMA(_srchull, _lengthhull) =>
    ta.wma(2 * ta.wma(_srchull, _lengthhull / 2) - ta.wma(_srchull, _lengthhull), math.round(math.sqrt(_lengthhull)))

// Альтернативная Hull MA
hullMA3(_srchull, _lengthhull) =>
    p = _lengthhull / 2
    ta.wma(ta.wma(close, p / 3) * 3 - ta.wma(close, p / 2) - ta.wma(close, p), p)

// Функция для расчета фильтра Кахлмана
kahlman(x, g) =>
    kf = 0.0
    dk = x - nz(kf[1], x)
    smooth = nz(kf[1], x) + dk * math.sqrt(g / 10000 * 2)
    velo = 0.0
    velo := nz(velo[1], 0) + g / 10000 * dk
    kf := smooth + velo
    kf

// Расчет значений индикатора
hullMAValue = k ? kahlman(hullMA(srchull, lengthhull), gain) : hullMA(srchull, lengthhull)
hullMA3Value = k ? kahlman(hullMA3(srchull, lengthhull), gain) : hullMA3(srchull, lengthhull)
c = hullMA3Value > hullMAValue ? #00e676 : #ff5252
crossdn = hullMAValue > hullMA3Value and hullMAValue[1] < hullMA3Value[1]
crossup = hullMA3Value > hullMAValue and hullMA3Value[1] < hullMAValue[1]

// Построение графиков и сигналов с прозрачностью
p1hma = plot(hullMAValue, color=color.new(c, 75), linewidth=1, title='Длинный сигнал')
p2hma = plot(hullMA3Value, color=color.new(c, 75), linewidth=1, title='Короткий сигнал')
fill(p1hma, p2hma, color=color.new(c, 55), title='Заполнение')
plotshape(showcross and crossdn ? hullMAValue : na, location=location.abovebar, style=shape.labeldown, color=#ff000080, size=size.tiny, text='S', textcolor=#ffffff, offset=-1)
plotshape(showcross and crossup ? hullMAValue : na, location=location.belowbar, style=shape.labelup, color=#00ff004c, size=size.tiny, text='B', textcolor=#ffffff, offset=-1)

// Параметры Gauge
tc = input.int(25, "Gauge Size", minval=3)
upColor = input.color(#05ff00 , "Up Color")
downColor = input.color(#ff0000, "Down Color")

// Функция измерения
t = table.new(position.middle_right, 3, tc + 1)
printTable(txt, col, row, bg_color, txt1, col1, row1, bg_color1) =>
    table.cell(t, col, row, txt, bgcolor=bg_color)
    table.cell(t, col1, row1, txt1, bgcolor=bg_color1, text_color=#fefffe)

// Пересчет и отображение Gauge
basisGauge = ta.sma(src, length) // Исправлено с source на src
grad = math.abs(basisGauge - src) / (ta.highest(basisGauge - src, 200)) * 100
grad1 = math.min(grad, 40)
grad1 := 100 - grad1
y = 1 - math.min(100, grad1) / 100

for i = 1 to tc
    base_color = chart.fg_color
    gauge_color = color.from_gradient(i, 1, tc, src > basisGauge ? upColor : downColor, base_color)
    printTable("", 1, i, gauge_color, ">", 1, math.round(y * tc), #ffffff00)

//==================================================================================================================================================================================//