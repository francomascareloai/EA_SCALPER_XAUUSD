// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Join our channel for more free tools: https://t.me/simpleforextools

//@version=5
indicator("Futures Algo SMC [AlgoPoint]", overlay=true, max_labels_count=500, max_lines_count=500)

// Constants
color CLEAR = color.rgb(0,0,0,100)

// Inputs
theme = input.string('Colored', 'Mode', ['Colored', 'Monochrome'], group = 'Theme')
barcoloring = input.bool(true, 'Bar Coloring', group = 'Theme')
swingSize = 10
bosConfType = 'Candle Close'
choch = true
showHalf = false
halfColor = #2927b0
halfStyle = 'Solid'
halfWidth = 1
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
bosStyle = input.string('Dashed', 'Market Structures Line Style', ['Solid', 'Dashed', 'Dotted'], group='Market Structures')
bosWidth = input.int(1, 'Market Structures Line Width', minval=1, group='Market Structures')
showSwing = input.bool(false, 'Show Swing Points', tooltip='Show or hide HH, LH, HL, LL', group = 'Market Structures')

//Colors
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
bosbrokeup = (theme == 'Colored' ? #008976ba : #707277)
bosbrokedown = (theme == 'Colored' ? #f23646ba : #707277)
fvgbulcolor = (theme == 'Colored' ? #0899813d : #4346514b)
fvgbearcolor = (theme == 'Colored' ? #f235133b : #4346514b)
trendlinescolor = (theme == 'Colored' ? #2962ff : #707277)
buysidecolor = (theme == 'Colored' ? #008976ba : color.new(#d1d4dc,  15))
selsidecolor = (theme == 'Colored' ? #f23646ba : color.new(#d1d4dc,  15))
srcolor = (theme == 'Colored' ? color.new(#673ab7, 25) : #4346514b)
upBar = #d1d4dc
downBar = #5d606b
// Functions 
lineStyle(x) =>
    switch x
        'Solid' => line.style_solid
        'Dashed' => line.style_dashed
        'Dotted' => line.style_dotted


// Calculations
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
//Finding high and low pivots
pivHi = ta.pivothigh(high, swingSize, swingSize)
pivLo = ta.pivotlow(low, swingSize, swingSize)
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
//Tracking the previous swing levels to determine hh lh hl ll
var float prevHigh = na
var float prevLow = na
var int prevHighIndex = na
var int prevLowIndex = na
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
//Tracking whether previous levels have been breached
var bool highActive = false
var bool lowActive = false
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
bool hh = false
bool lh = false
bool hl = false
bool ll = false
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
//Variable to track the previous swing type, used later on to draw 0.5 Retracement Levels (HH = 2, LH = 1, HL = -1, LL = -2)
var int prevSwing = 0

if not na(pivHi)
    if pivHi >= prevHigh
        hh := true
        prevSwing := 2
    else
        lh := true
        prevSwing := 1
    prevHigh := pivHi
    highActive := true
    prevHighIndex := bar_index - swingSize

if not na(pivLo)
    if pivLo >= prevLow
        hl := true
        prevSwing := -1
    else
        ll := true
        prevSwing := -2
    prevLow := pivLo
    lowActive := true
    prevLowIndex := bar_index - swingSize

//Generating the breakout signals
bool highBroken = false
bool lowBroken = false

//Tracking prev breakout
var int prevBreakoutDir = 0

float highSrc = bosConfType == 'Candle Close' ? close : high
float lowSrc = bosConfType == 'Candle Close' ? close : low

if highSrc > prevHigh and highActive
    highBroken := true
    highActive := false
if lowSrc < prevLow and lowActive
    lowBroken := true
    lowActive := false


// Visual Output
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
//Swing level labels
if hh and showSwing
    label.new(bar_index - swingSize, pivHi, 'HH', color=CLEAR, style=label.style_label_down, textcolor=bosbrokeup)
    //Detecting if it is a hh after a hl
    if prevSwing[1] == -1 and showHalf
        line.new(prevLowIndex, (prevLow + pivHi) / 2, bar_index - swingSize, (prevLow + pivHi) / 2, color=halfColor, style=lineStyle(halfStyle), width=halfWidth)
if lh and showSwing
    label.new(bar_index - swingSize, pivHi, 'LH', color=CLEAR, style=label.style_label_down, textcolor=bosbrokedown)
if hl and showSwing
    label.new(bar_index - swingSize, pivLo, 'HL', color=CLEAR, style=label.style_label_up, textcolor=bosbrokeup)
if ll and showSwing
    label.new(bar_index - swingSize, pivLo, 'LL', color=CLEAR, style=label.style_label_up, textcolor=bosbrokedown)
    //Detecting if it is a ll after a lh
    if prevSwing[1] == 1 and showHalf
        line.new(prevHighIndex, (prevHigh + pivLo) / 2, bar_index - swingSize, (prevHigh + pivLo) / 2, color=halfColor, style=lineStyle(halfStyle), width=halfWidth)

//Generating the BOS Lines
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
if highBroken
    line.new(prevHighIndex, prevHigh, bar_index, prevHigh, color=bosbrokeup, style=lineStyle(bosStyle), width=bosWidth)
    label.new(math.floor(bar_index - (bar_index - prevHighIndex) / 2), prevHigh, prevBreakoutDir == -1 and choch ? 'CHoCH' : 'BOS', color=CLEAR, textcolor=bosbrokeup, size=size.tiny)
    prevBreakoutDir := 1
if lowBroken
    line.new(prevLowIndex, prevLow, bar_index, prevLow, color=bosbrokedown, style=lineStyle(bosStyle), width=bosWidth)
    label.new(math.floor(bar_index - (bar_index - prevLowIndex) / 2), prevLow, prevBreakoutDir == 1 and choch ? 'CHoCH' : 'BOS', color=CLEAR, textcolor=bosbrokedown, style=label.style_label_up, size=size.tiny)
    prevBreakoutDir := -1

// EQH/EQL
length_eqh = 7
n=bar_index
atrre = ta.atr(200)
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
show_equal_highlow = input(false, 'Equal Highs & Lows', group = 'Market Structures',inline = 'equilibrium_zone')
eq_bear_color = bosbrokeup
eq_bull_color = bosbrokedown
eq_threshold = 0.10
label_sizes_s ="Small"
label_size_buysell = label_sizes_s == "Small" ? size.tiny : label_sizes_s == "Medium" ? size.small : label_sizes_s == "Large" ? size.normal : label_sizes_s == "Medium2" ? size.normal : label_sizes_s == "Large2" ? size.large : size.huge
var high_eqh_pre = 0.,var eq_top_x = 0,var low_eqh_pre = 0.,var eq_btm_x = 0
if show_equal_highlow
    high_eqh = ta.pivothigh(length_eqh, length_eqh)
    low_eqh = ta.pivotlow(length_eqh, length_eqh)
    if low_eqh 
        if math.min(low_eqh, low_eqh_pre) > math.max(low_eqh, low_eqh_pre) - atrre * eq_threshold
            eql_line = line.new(eq_btm_x, low_eqh_pre, n-length_eqh, low_eqh, color = eq_bull_color, style = line.style_dotted)
            eql_lbl = label.new(int(math.avg(n-length_eqh, eq_btm_x)), low_eqh, 'EQL', color = #00000000, textcolor = eq_bull_color, style = label.style_label_up, size = label_size_buysell)
        low_eqh_pre := low_eqh
        eq_btm_x := n-length_eqh
    if high_eqh     
        if math.max(high_eqh, high_eqh_pre) < math.min(high_eqh, high_eqh_pre) + atrre * eq_threshold
            eqh_line = line.new(eq_top_x, high_eqh_pre, n-length_eqh, high_eqh, color = eq_bear_color, style = line.style_dotted)
            eqh_lbl = label.new(int(math.avg(n-length_eqh, eq_top_x)), high_eqh, 'EQH', color = #00000000, textcolor = eq_bear_color, style = label.style_label_down, size = label_size_buysell)
        high_eqh_pre := high_eqh
        eq_top_x := n-length_eqh

// Trendlines

showTL      = input(true, 'TrendLine', group = 'TrendLines')
//general
f_barssincee(_cond, _count) =>
    _barssince = bar_index - ta.valuewhen(_cond, bar_index, _count)
    _barssince

barssince(_cond, _count) => int(math.max(1, nz(f_barssincee(_cond, _count))))
f_vw(cond, expr, count) => ta.valuewhen(cond, expr, count)
tostring(x, y)=> x + str.tostring(y)
var int dec = str.length(str.tostring(syminfo.mintick))-2
gr5         = 'Trendlines'
xa = 'al'
showPriceTl = false
xacad = 'A'
newestTL    = true
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
xbled = 'P'
newestBreak = true
xefx = 'R'
periodlen   = input.string('Adaptive', 'Trendline Term', ['Long Term', 'Short Term','Adaptive'])
xtod = 'g'
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
period = (periodlen == 'Adaptive' ? 30 : periodlen == 'Long Term' ? 40 : periodlen == 'Short Term' ? 20 : 0)
//period      = input(30, 'Trendline Period')
srcI        = input.string('Wick', 'TrendLine Source', ['Close Body', 'Wick'])
xacw = 'A'
srcL        = srcI=='Wick'? low  : close
xiuk = 'l'
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
srcH        = srcI=='Wick'? high : close
xpoi = 'poi'
lStyleI     = input.string('Dashed', 'TrendLine Style', ['Solid', 'Dashed', 'Dotted'])
xoo = 'E'
y2_mult     = 1
lStyle      = lStyleI=='Solid'? line.style_solid : lStyleI=='Dashed'? line.style_dashed : line.style_dotted
xmy = 'my'
lWidth      = input(2, 'TrendLine Width')
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
lColor      = trendlinescolor
xfop = 'o'
supTextCol  = color.red
resTextCol  = color.blue
truncate(number) =>
    factor = math.pow(10, dec)
    int(number * factor) / factor

EndTime     = timestamp('19 Jan 2022 00:00 +0000')
inDateRange = time<=EndTime

fVwSeries (x, xVal, xBar)=>
    x0      = truncate(ta.valuewhen(x, xVal, 0))
    x1      = truncate(ta.valuewhen(x, xVal, 1))
    x2      = truncate(ta.valuewhen(x, xVal, 2))
    x0Bar   = ta.valuewhen(x, xBar, 0) - f_barssincee(x, 0)
    x1Bar   = ta.valuewhen(x, xBar, 1) - f_barssincee(x, 1)
    x2Bar   = ta.valuewhen(x, xBar, 2) - f_barssincee(x, 2)
    
    [x0, x1, x2, x0Bar, x1Bar, x2Bar]


fTst(x, y)=> x + str.tostring(y)
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
phFound     = ta.pivothigh(srcH, period, period)
plFound     = ta.pivotlow (srcL, period, period)
phVal       = ta.valuewhen(phFound, srcH[period], 0)
plVal       = ta.valuewhen(plFound, srcL[period], 0)
phVal1      = ta.valuewhen(phFound, srcH[period], 1)
plVal1      = ta.valuewhen(plFound, srcL[period], 1)
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
a_bar_time  = time - time[1]
noneCol     = color.new(color.red, 100)
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
fGetPriceTl(slope_, x2_, y2_) =>
    current_price  = y2_ + (slope_/(x2_ - time))
    current_price

f_trendline(cond_, y1Val_, x1Bar_, y2Val_, x2Bar_, color_, tlPriceText, textCol) =>
    
    x1      = ta.valuewhen(cond_, time[x1Bar_], 0)
    x2      = ta.valuewhen(cond_, time[x2Bar_], 0)
    y1      = ta.valuewhen(cond_, y1Val_, 0)
    y2      = ta.valuewhen(cond_, y2Val_, 0)
    slope_  = ta.valuewhen(cond_, (y2-y1)/(x2-x1), 0)

    currentPrice    = truncate(y2 + (time-x2)*slope_) 
    var label tlPrice     = na
    
    if close and newestTL
        a_trendline = line.new (x1, y1, time,  currentPrice, xloc.bar_time, color=lColor, style=lStyle, width=lWidth)
        line.delete (a_trendline[1])
        
        a_trendline
    
    newY2   = x2 + (y2_mult * a_bar_time * 25)
    
    if cond_ and not newestTL
        a_trendline = line.new(x1, y1, newY2,  currentPrice, xloc.bar_time, color=lColor, style=lStyle, width=lWidth)
        a_trendline
    if showPriceTl
        tlPrice     := label.new(bar_index+10, currentPrice, fTst(tlPriceText, currentPrice), color=noneCol, style=label.style_label_left, textcolor=textCol)
        label.delete(tlPrice[1])

    currentPrice
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
newUp   = phFound and phVal<phVal1 and showTL
newLo   = plFound and plVal>plVal1 and showTL
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
upperTl = f_trendline(newUp, phVal1, f_barssincee(phFound,1)+period, phVal, f_barssincee(phFound,0)+period,color.black, 'Upper = ', resTextCol)
lowerTl = f_trendline(newLo, plVal1, f_barssincee(plFound,1)+period, plVal, f_barssincee(plFound,0)+period,color.black, 'Lower = ', supTextCol)
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
highestSince    = ta.highest(srcH, barssince(phFound and phVal<phVal1 and showTL,0))
lowestSince     = ta.lowest (srcL, barssince(plFound and plVal>plVal1 and showTL,0))
breakUpper      = srcH[1]<upperTl[1] and srcH>upperTl
breakLower      = srcL[1]>lowerTl[1] and srcL<lowerTl
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
// FVG

showliquiditylev   = input.string('Mode 1', 'Liquidity Levels Detecting Mode', ['Mode 1', 'Mode 2', 'Close'], group = 'Liquidity Levels')
//Settings
//-----------------------------------------------------------------------------{
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
liqGrp = 'Liquidity Detection'
liqLen = 13
liqMar = 10 / 6.9
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
liqBuy = true
marBuy    = 2.3
cLIQ_B = showliquiditylev == 'Mode 1' ? buysidecolor : #00897700
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
liqSel = true
marSel = 2.3
cLIQ_S = showliquiditylev == 'Mode 1' ? selsidecolor : #00897700
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
lqVoid = false
cLQV_B = showliquiditylev == 'Mode 1' ? buysidecolor : #00897700
cLQV_S = showliquiditylev == 'Mode 1' ? selsidecolor : #00897700
lqText = false
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
mode   = 'Present'
visLiq = showliquiditylev == 'Mode 1' ? 3 : 0
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
//-----------------------------------------------------------------------------}
//General Calculations
//-----------------------------------------------------------------------------{
maxSize = 50
atr     = ta.atr(10)
atr200  = ta.atr(200)
per     = mode == 'Present' ? last_bar_index - bar_index <=  500 : true
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
//-----------------------------------------------------------------------------}
//User Defined Types
//-----------------------------------------------------------------------------{
// @type        used to store pivot high/low data 
//
// @field d     (array<int>) The array where the trend direction is to be maintained
// @field x     (array<int>) The array where the bar index value of pivot high/low is to be maintained
// @field y     (array<float>) The array where the price value of pivot high/low is to be maintained
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
type ZZ 
    int   [] d
    int   [] x 
    float [] y 
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
// @type        bar properties with their values 
//
// @field o     (float) open price of the bar
// @field h     (float) high price of the bar
// @field l     (float) low price of the bar
// @field c     (float) close price of the bar
// @field i     (int) index of the bar
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
type bar
    float o = open
    float h = high
    float l = low
    float c = close
    int   i = bar_index

// @type        liquidity object definition 
//
// @field bx    (box) box maitaing the liquity level margin extreme levels
// @field bxz   (box) box maitaing the liquity zone margin extreme levels
// @field bxt   (box) box maitaing the labels
// @field brZ   (bool) mainains broken zone status
// @field brL   (bool) mainains broken level status
// @field ln    (line) maitaing the liquity level line
// @field lne   (line) maitaing the liquity extended level line

type liq
    box   bx
    box   bxz
    box   bxt
    bool  brZ
    bool  brL
    line  ln
    line  lne

//-----------------------------------------------------------------------------}
//Variables
//-----------------------------------------------------------------------------{
var ZZ aZZ = ZZ.new(
 array.new <int>  (maxSize,  0), 
 array.new <int>  (maxSize,  0), 
 array.new <float>(maxSize, na)
 )

bar b = bar.new()
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
var liq[] b_liq_B = array.new<liq> (1, liq.new(box(na), box(na), box(na), false, false, line(na), line(na)))
var liq[] b_liq_S = array.new<liq> (1, liq.new(box(na), box(na), box(na), false, false, line(na), line(na)))
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
var b_liq_V = array.new_box()
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
var int dir = na, var int x1 = na, var float y1 = na, var int x2 = na, var float y2 = na
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
//-----------------------------------------------------------------------------}
//Functions/methods
//-----------------------------------------------------------------------------{
// @function        maintains arrays 
//                     it prepends a `value` to the arrays and removes their oldest element at last position
// @param aZZ       (UDT<array<int>, array<int>, array<float>>) The UDT obejct of arrays
// @param _d        (array<int>) The array where the trend direction is maintained
// @param _x        (array<int>) The array where the bar index value of pivot high/low is maintained
// @param _y        (array<float>) The array where the price value of pivot high/low is maintained
//
// @returns         none

method in_out(ZZ aZZ, int _d, int _x, float _y) =>
    aZZ.d.unshift(_d), aZZ.x.unshift(_x), aZZ.y.unshift(_y), aZZ.d.pop(), aZZ.x.pop(), aZZ.y.pop()


// @function        (build-in) sets the maximum number of bars that is available for historical reference 
                    
max_bars_back(time, 1000)

//-----------------------------------------------------------------------------}
//Calculations
//-----------------------------------------------------------------------------{
x2 := b.i - 1
ph  = ta.pivothigh(liqLen, 1)
pl  = ta.pivotlow (liqLen, 1)

if ph   
    dir := aZZ.d.get(0) 
    x1  := aZZ.x.get(0) 
    y1  := aZZ.y.get(0) 
    y2  := nz(b.h[1])

    if dir < 1
        aZZ.in_out(1, x2, y2)
    else
        if dir == 1 and ph > y1 
            aZZ.x.set(0, x2), aZZ.y.set(0, y2)
    
    if per
        count = 0
        st_P  = 0.
        st_B  = 0
        minP  = 0.
        maxP  = 10e6

        for i = 0 to maxSize - 1
            if aZZ.d.get(i) ==  1 
                if aZZ.y.get(i) > ph + (atr / liqMar)
                    break
                else
                    if aZZ.y.get(i) > ph - (atr / liqMar) and aZZ.y.get(i) < ph + (atr / liqMar)
                        count += 1
                        st_B := aZZ.x.get(i)
                        st_P := aZZ.y.get(i)
                        if aZZ.y.get(i) > minP
                            minP := aZZ.y.get(i)
                        if aZZ.y.get(i) < maxP 
                            maxP := aZZ.y.get(i)

        if count > 2
            getB = b_liq_B.get(0)

            if st_B == getB.bx.get_left()
                getB.bx.set_top(math.avg(minP, maxP) + (atr / liqMar))
                getB.bx.set_rightbottom(b.i + 10, math.avg(minP, maxP) - (atr / liqMar))
            else
                b_liq_B.unshift(
                 liq.new(
                   box.new(st_B, math.avg(minP, maxP) + (atr / liqMar), b.i + 10, math.avg(minP, maxP) - (atr / liqMar), bgcolor=color(na), border_color=color(na)), 
                   box.new(na, na, na, na, bgcolor = color(na), border_color = color(na)),
                   box.new(st_B, st_P, b.i + 10, st_P, text = '$$$', text_size = size.small, text_halign = text.align_left, text_valign = text.align_bottom, text_color = color.new(cLIQ_B, 25), bgcolor = color(na), border_color = color(na)),
                   false, 
                   false,
                   line.new(st_B   , st_P, b.i - 1, st_P, color = color.new(cLIQ_B, 0)),
                   line.new(b.i - 1, st_P, na     , st_P, color = color.new(cLIQ_B, 0), style = line.style_dotted))
                 )

                alert('buyside liquidity level detected/updated for ' + syminfo.ticker)

            if b_liq_B.size() > visLiq
                getLast = b_liq_B.pop()
                getLast.bx.delete()
                getLast.bxz.delete()
                getLast.bxt.delete()
                getLast.ln.delete()
                getLast.lne.delete()               

if pl
    dir := aZZ.d.get (0) 
    x1  := aZZ.x.get (0) 
    y1  := aZZ.y.get (0) 
    y2  := nz(b.l[1])
    
    if dir > -1
        aZZ.in_out(-1, x2, y2)
    else
        if dir == -1 and pl < y1 
            aZZ.x.set(0, x2), aZZ.y.set(0, y2)
    
    if per
        count = 0
        st_P  = 0.
        st_B  = 0
        minP  = 0.
        maxP  = 10e6

        for i = 0 to maxSize - 1
            if aZZ.d.get(i) == -1 
                if aZZ.y.get(i) < pl - (atr / liqMar)
                    break
                else
                    if aZZ.y.get(i) > pl - (atr / liqMar) and aZZ.y.get(i) < pl + (atr / liqMar)
                        count += 1
                        st_B := aZZ.x.get(i)
                        st_P := aZZ.y.get(i)
                        if aZZ.y.get(i) > minP
                            minP := aZZ.y.get(i)
                        if aZZ.y.get(i) < maxP 
                            maxP := aZZ.y.get(i)

        if count > 2
            getB = b_liq_S.get(0)

            if st_B == getB.bx.get_left()
                getB.bx.set_top(math.avg(minP, maxP) + (atr / liqMar))
                getB.bx.set_rightbottom(b.i + 10, math.avg(minP, maxP) - (atr / liqMar))
            else
                b_liq_S.unshift(
                 liq.new(
                   box.new(st_B, math.avg(minP, maxP) + (atr / liqMar), b.i + 10, math.avg(minP, maxP) - (atr / liqMar), bgcolor=color(na), border_color=color(na)),
                   box.new(na, na, na, na, bgcolor=color(na), border_color=color(na)),
                   box.new(st_B, st_P, b.i + 10, st_P, text = '$$$', text_size = size.small, text_halign = text.align_left, text_valign = text.align_top, text_color = color.new(cLIQ_S, 25), bgcolor=color(na), border_color=color(na)),
                   false,
                   false,
                   line.new(st_B   , st_P, b.i - 1, st_P, color = color.new(cLIQ_S, 0)),
                   line.new(b.i - 1, st_P, na     , st_P, color = color.new(cLIQ_S, 0), style = line.style_dotted))
                 )  

                alert('sellside liquidity level detected/updated for ' + syminfo.ticker)

            if b_liq_S.size() > visLiq
                getLast = b_liq_S.pop()
                getLast.bx.delete()
                getLast.bxz.delete()
                getLast.bxt.delete()
                getLast.ln.delete()            
                getLast.lne.delete()               


for i = 0 to b_liq_B.size() - 1
    x = b_liq_B.get(i)
    
    if not x.brL
        x.lne.set_x2(b.i)

        if b.h > x.bx.get_top()
            x.brL := true
            x.brZ := true
            alert('buyside liquidity level breached for ' + syminfo.ticker)

            x.bxz.set_lefttop(b.i - 1, math.min(x.ln.get_y1() + marBuy * (atr), b.h))
            x.bxz.set_rightbottom(b.i + 1, x.ln.get_y1())
            x.bxz.set_bgcolor(color.new(cLIQ_B,100))

    else if x.brZ
        if b.l > x.ln.get_y1() - marBuy * (atr) and b.h < x.ln.get_y1() + marBuy * (atr)
            x.bxz.set_right(b.i + 1)
            x.bxz.set_top(math.max(b.h, x.bxz.get_top()))
            if liqBuy
                x.lne.set_x2(b.i + 1)
        else
            x.brZ := false

for i = 0 to b_liq_S.size() - 1
    x = b_liq_S.get(i)

    if not x.brL
        x.lne.set_x2(b.i)

        if b.l < x.bx.get_bottom()
            x.brL := true
            x.brZ := true
            alert('sellside liquidity level breached for ' + syminfo.ticker)

            x.bxz.set_lefttop(b.i - 1, x.ln.get_y1())
            x.bxz.set_rightbottom(b.i + 1, math.max(x.ln.get_y1() - marSel * (atr), b.l))
            x.bxz.set_bgcolor(color.new(cLIQ_S, 100))

    else if x.brZ
        if b.l > x.ln.get_y1() - marSel * (atr) and b.h < x.ln.get_y1() + marSel * (atr)
            x.bxz.set_rightbottom(b.i + 1, math.min(b.l, x.bxz.get_bottom()))
            if liqSel
                x.lne.set_x2(b.i + 1)
        else
            x.brZ := false
////////////// Liquidity V2
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------       Liquidity Levels
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

currentTF  = true
htfTF  = ""//input.timeframe("", title = "Timeframe", inline="1_")
_highLineStyleHTF  = "Solid"//input.string("Solid", title = "Line Style", options=["Solid", "Dashed", "Dotted"], group=liquidity_level_group,inline='5')
highLineStyleHTF = _highLineStyleHTF=="Solid" ? line.style_solid : _highLineStyleHTF=="Dashed" ? line.style_dashed : line.style_dotted
box_width  = 2.5//input.float(3.0, title = "Width", group=liquidity_level_group,inline='5', minval = 1, maxval = 10, step = 0.5)
lineWidthHTF=2
lowLineColorHTF = showliquiditylev == 'Mode 2' ? selsidecolor : #00897700
highLineColorHTF = showliquiditylev == 'Mode 2' ? selsidecolor : #00897700
highBoxBorderColorHTF = color.new(highLineColorHTF,90)
lowBoxBorderColorHTF = color.new(lowLineColorHTF,90)
displayStyle_liq  = "Lines"//'Lines'

// --
highLineColor = highLineColorHTF//input.color(#1f4ef5, "High Line   ", group = liquidity_level_group, inline = "1")
lowLineColor = lowLineColorHTF//input.color(#fd441c, "Low Line", group = liquidity_level_group, inline = "1")
highBoxBgColor = highLineColorHTF//input.color(color.new(#1f4ef5, 80), "High Box Bg ", group = liquidity_level_group, inline = "2")
highBoxBorderColor = highBoxBorderColorHTF//input.color(color.new(#1f4ef5, 80), "Box Border", group = liquidity_level_group, inline = "2")
lowBoxBgColor = lowLineColorHTF//input.color(color.new(#fd441c, 80), "Low Box Bg  ", group = liquidity_level_group, inline = "3")
lowBoxBorderColor = lowBoxBorderColorHTF//input.color(color.new(#fd441c, 80), "Box Border", group = liquidity_level_group, inline = "3")
atr_liq = ta.atr(300)

float thold_liq = atr_liq * (box_width / 10)
// --
// --
// --
// ----------------------------------------------------
// Functions 
// ----------------------------------------------------

tf_multi(tf) =>
    ts = timeframe.in_seconds("")
    htfs = timeframe.in_seconds(tf)
    htfs/ts

display_limit_line(_array) =>
    if array.size(_array) > 6/2
        a = array.shift(_array)
        line.delete(a)

display_limit_box(_array) =>
    if array.size(_array) > 6/2
        a = array.shift(_array)
        box.delete(a)

remove_mitigated_lines(_array, _hl) =>
    m = false
    if array.size(_array) > 0      
        for i = array.size(_array) - 1 to 0 by 1
            l = array.get(_array, i)
            hh = "Close" == "Close" ? close[1] : high
            ll = "Close" == "Close" ? close[1] : low
            if _hl == "High" and hh > line.get_y1(l)
                array.remove(_array, i)
                if "Remove" == "Show"
                    line.new(line.get_x1(l),line.get_y1(l),time,line.get_y1(l), xloc=xloc.bar_time, color = highLineColorHTF, style=highLineStyleHTF, width = lineWidthHTF)
                line.delete(l)
                m := true
            if _hl == "Low" and ll < line.get_y1(l)
                array.remove(_array, i)
                if "Remove" == "Show"
                    line.new(line.get_x1(l),line.get_y1(l),time,line.get_y1(l), xloc=xloc.bar_time, color = lowLineColorHTF, style=highLineStyleHTF, width = lineWidthHTF)
                line.delete(l) 
                m := true  
    display_limit_line(_array) 
    m

remove_mitigated_boxes(_array, _hl) =>
    m = false
    if array.size(_array) > 0
        for i = array.size(_array) - 1 to 0 by 1
            l = array.get(_array, i)
            hh = "Close" == "Close" ? close[1] : high
            ll = "Close" == "Close" ? close[1] : low
            if _hl == "High" and hh > box.get_top(l)
                array.remove(_array, i)
                if "Remove" == "Show"
                    box.new(box.get_left(l),box.get_top(l),time,box.get_bottom(l), xloc=xloc.bar_time, bgcolor = color.new(highBoxBgColor, 90), border_color = color.new(highBoxBorderColor, 90), border_style = highLineStyleHTF)
                box.delete(l)
                m := true
            if _hl == "Low" and ll < box.get_top(l)
                array.remove(_array, i)
                if "Remove" == "Show"
                    box.new(box.get_left(l),box.get_top(l),time,box.get_bottom(l), xloc=xloc.bar_time, bgcolor = color.new(lowBoxBgColor, 90), border_color = color.new(lowBoxBorderColor, 90), border_style = highLineStyleHTF)
                box.delete(l)
                m := true
    display_limit_box(_array) 
    m

extend_line_to_current(lineArray) =>
    if array.size(lineArray) > 0
        for i = array.size(lineArray) - 1 to 0 by 1
            l = array.get(lineArray, i)
            //timeExt = timenow + ((timediff)*20)
            //line.set_x2(l, timeExt)

extend_box_to_current(boxArray) =>
    if array.size(boxArray) > 0
        for i = array.size(boxArray) - 1 to 0 by 1
            b = array.get(boxArray, i)
            //timeExt = timenow + ((timediff)*20)
            //box.set_right(b, //timeExt)

// ----------------------------------------------------
// Higher TimeFrame
// ----------------------------------------------------
// Varibles 
// Lines
var highLineArrayHTF = array.new_line()
var lowLineArrayHTF = array.new_line()

// Boxes
var highBoxArrayHTF = array.new_box()
var lowBoxArrayHTF = array.new_box()

// Get HTF
[_time, _open, _high, _low, _close] = request.security(syminfo.tickerid, htfTF, [time, open, high, low, close])

// Pivots
pivotHighHTF = ta.pivothigh(_high, 8*tf_multi(htfTF), 8+tf_multi(htfTF))
pivotLowHTF = ta.pivotlow(_low, 8*tf_multi(htfTF), 8+tf_multi(htfTF))

if currentTF
    timeExt = time+((time[1]-time[2])*10)
    dis = 8+tf_multi(htfTF)
    if pivotHighHTF
        if displayStyle_liq == "Lines"
            array.push(highLineArrayHTF, line.new(_time[dis],_high[dis],_time[+1],_high[dis],color = highLineColorHTF, style=highLineStyleHTF, xloc=xloc.bar_time, width = lineWidthHTF))
        else
            y1 = _high[dis]-thold_liq//math.max(_open[dis], _close[dis])
            array.push(highBoxArrayHTF, box.new(_time[dis],_high[dis],_time[+1],y1,bgcolor = highLineColorHTF, border_color=highBoxBorderColorHTF, xloc=xloc.bar_time, border_style = highLineStyleHTF, border_width = lineWidthHTF))  
    if pivotLowHTF
        if displayStyle_liq == "Lines"
            array.push(lowLineArrayHTF, line.new(_time[dis],_low[dis],_time[+1],_low[dis],color = lowLineColorHTF, style=highLineStyleHTF, xloc=xloc.bar_time, width = lineWidthHTF))
        else
            y1 = _low[dis]+thold_liq//math.min(_open[dis], _close[dis])
            array.push(lowBoxArrayHTF, box.new(_time[dis],_low[dis],_time[+1],y1,bgcolor = lowLineColorHTF, border_color=lowBoxBorderColorHTF, xloc=xloc.bar_time, border_style = highLineStyleHTF, border_width = lineWidthHTF))

// ----------------------------------------------------
// Run Functions
// ----------------------------------------------------
highLineAlertHTF = remove_mitigated_lines(highLineArrayHTF, "High")
lowLineAlertHTF = remove_mitigated_lines(lowLineArrayHTF, "Low")
highBoxAlertHTF = remove_mitigated_boxes(highBoxArrayHTF, "High")
lowBoxAlertHTF = remove_mitigated_boxes(lowBoxArrayHTF, "Low")


extend_line_to_current(highLineArrayHTF)
extend_line_to_current(lowLineArrayHTF)
extend_box_to_current(highBoxArrayHTF)
extend_box_to_current(lowBoxArrayHTF)

// Multi-Timeframe S/R

sr_line_trans = 30
sr_trackprice = true

left = 5
right = 5
line_width = 3

activeATF = input.bool(false, "Current Timeframe", group="Multi-Timeframe S/R", inline="", tooltip="Show you current timeframe support and resistance levels")

activeD = input.bool(false, "Daily  ", group="Multi-Timeframe S/R", inline="sr-a")
active4h = input.bool(false, "4 Hour  ", group="Multi-Timeframe S/R", inline="sr-a")
active1h = input.bool(false, "1 Hour  ", group="Multi-Timeframe S/R", inline="sr-a")
active30m = input.bool(false, "M30   ", group="Multi-Timeframe S/R", inline="sr-b")
active15m = input.bool(false, "M15    ", group="Multi-Timeframe S/R", inline="sr-b")
active5m = input.bool(false, "M5", group="Multi-Timeframe S/R", inline="sr-b")


sr_color = srcolor 
c_white = srcolor

float level1 = na
float level2 = na
float level3 = na
float level4 = na
float level5 = na
float level6 = na
float level7 = na
float level8 = na
float level9 = na
float level0 = na

float level15m = na
float level15m1 = na

float level5m = na
float level5m1 = na

pivot_tf_high(tf, src, left, right, occ) =>
    request.security(syminfo.tickerid, tf, ta.valuewhen(ta.pivothigh(src, left, right), close[right], 0))

pivot_tf_low(tf, src, left, right, occ) =>
    request.security(syminfo.tickerid, tf, ta.valuewhen(ta.pivotlow(src, left, right), close[right], 0))

if activeATF
    level1 := ta.valuewhen(ta.pivothigh(close, left, right), close[right], 0)
    level2 := ta.valuewhen(ta.pivotlow(close, left, right), close[right], 0)

if timeframe.isintraday
    if active4h
        level3 := pivot_tf_high('240', close, left, right, 0)
        level4 := pivot_tf_low('240', close, left, right, 0)

    if active1h
        level5 := pivot_tf_high('60', close, left, right, 0)
        level6 := pivot_tf_low('60', close, left, right, 0)
    
    if active30m
        level7 := pivot_tf_high('30', close, left, right, 0)
        level8 := pivot_tf_low('30', close, left, right, 0)
    
    if active15m
        level15m := pivot_tf_high('15', close, left, right, 0)
        level15m1 := pivot_tf_low('15', close, left, right, 0)
    
    if active5m
        level5m := pivot_tf_high('5', close, left, right, 0)
        level5m1 := pivot_tf_low('5', close, left, right, 0)

    if activeD
        level9 := pivot_tf_high('D', close, left, right, 0)
        level0 := pivot_tf_low('D', close, left, right, 0)
        level0


//Only show the strongest support/resistance levels
if level5 == level7
    level7 := na
if level6 == level8
    level8 := na
    
if level1 == level3 or level1 == level5 or level1 == level7 or level1 == level9 or level1 == level15m or level1 == level15m1 or level1 == level5m or level1 == level5m1
    level1 := na
if level2 == level4 or level2 == level6 or level2 == level8 or level2 == level0 or level2 == level15m or level2 == level15m1 or level2 == level5m or level2 == level5m1
    level2 := na
    
if level15m == level3 or level15m == level4 or level15m == level5 or level15m == level6 or level15m == level7 or level15m == level8
    level15m := na
if level15m1 == level3 or level15m1 == level4 or level15m1 == level5 or level15m1 == level6 or level15m1 == level7 or level15m1 == level8
    level15m1 := na
    
if level5m == level3 or level5m == level4 or level5m == level5 or level5m == level6 or level5m == level7 or level5m == level8 or level5m == level15m1 or level5m == level15m
    level5m := na

if level5m1 == level3 or level5m1 == level4 or level5m1 == level5 or level5m1 == level6 or level5m1 == level7 or level5m1 == level8 or level5m1 == level15m1 or level5m1 == level15m
    level5m1 := na


    
create_line_label(lvl, lvl2, txt)=>
    l1 = line.new(x1=bar_index - 1, y1=lvl, x2=bar_index, y2=lvl, extend=extend.both, width=line_width, color=sr_color)
    l2 = line.new(x1=bar_index - 1, y1=lvl2, x2=bar_index, y2=lvl2, extend=extend.both, width=line_width, color=sr_color)
    line.delete(l1[1])
    line.delete(l2[1])
    if not na(lvl)
        lab = label.new(bar_index + 5, lvl, text=txt, style=label.style_none, textcolor=c_white)
        label.delete(lab[1])
    if not na(lvl2)
        lab2 = label.new(bar_index + 5, lvl2, text=txt, style=label.style_none, textcolor=c_white)
        label.delete(lab2[1])

    
if barstate.islast
    create_line_label(level1, level2, "ATF")
    create_line_label(level3, level4, "H4")
    create_line_label(level5, level6, "H1")
    create_line_label(level7, level8, "M30")
    create_line_label(level15m, level15m1, "M15")
    create_line_label(level5m, level5m1, "M5")
    create_line_label(level0, level9, "D")
    
// Bar Color

// Input
fastLength = 12
slowLength = 26
srcre = close
signalLength = 9

// Data reference
[macd, signal, hist] = ta.macd(srcre, fastLength, slowLength, signalLength)

// 4 level of green
greenHigh = #05df09
greenMidHigh = #05df09
greenMidLow = #388E3C
greenLow = #5f3a97

// Yellow
yellowLow = #5f3a97

// 4 level of red
redHigh = #ea0402
redMidHigh = #ea0402
redMidLow = #cc0402
redLow = #5f3a97

// Default color
candleBody = yellowLow

// Ranging trend
if hist > 0
    if hist > hist[1] and hist[1] > 0
        candleBody := greenLow
        
if hist < 0
    if hist < hist[1] and hist[1] < 0
        candleBody := redLow

// Bullish trend
if macd > 0 and hist > 0
    candleBody := greenMidLow
    
    if hist > hist[1] and macd[1] > 0 and hist[1] > 0
        candleBody := greenMidHigh
        
        if hist > hist[2] and macd[2] > 0 and hist[2] > 0
            candleBody := greenHigh

// Bearish trend
if macd < 0 and hist < 0
    candleBody := redMidLow
    
    if hist < hist[1] and macd[1] < 0 and hist[1] < 0
        candleBody := redMidHigh
        
        if hist < hist[2] and macd[2] < 0 and hist[2] < 0
            candleBody := redHigh

barcolor(barcoloring == true and theme == 'Colored' ? candleBody : barcoloring == true and theme == 'Monochrome' and close >= open ? upBar : barcoloring == true and theme == 'Monochrome' and close <= open ? downBar : na ) // Include suggestion by Shaheen204
 

// MTF areas

// MTF S/R //
group               = "MULTI-TIMEFRAME S/R AREA (Beta Feature)"
showSR              = input.bool(false, title = "", inline = "01", group=group)
timef               = input.timeframe("", "", inline = "01", group=group)
levels              = input.int(4 , "Levels", inline = "01", group = group)
linewidth           = input.int(1, "Width", inline = "02", group = group) * 20
supportcolor        = (theme == 'Colored' ? #0089774b : #d1d4dc4b)
resistancecolor     = (theme == 'Colored' ? #b228344b : #d1d4dc4b)
labelon             = input.string("On", "Label", ["On", "Off"], inline = "03", group = group)
labelsize           = input.string("Default", "Size", ["Small", "Default", "Large"], inline = "03", group = group)
labelcol            = input.color(#787b86, "", inline = "03", group = group)
labelloc            = input.int(10, "Offset", inline = "04", group = group) + 30
showtimef           = input.bool(true, "Show Timeframe", inline = "04", group = group)
showtprice          = input.bool(true, "Show Price", inline = "04", group = group)


// get data on ticker based on chosen timeframe
src_c = request.security(syminfo.tickerid,timef,close, gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_off)
src_o = request.security(syminfo.tickerid,timef,open, gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_off)
f_resInMinutes() =>
    _resInMinutes = timeframe.multiplier * (timeframe.isseconds ? 1. / 60 : timeframe.isminutes ? 1. : timeframe.isdaily ? 60. * 24 : timeframe.isweekly ? 60. * 24 * 7 : timeframe.ismonthly ? 60. * 24 * 30.4375 : na)
    _resInMinutes
f_timefResInMinutes(_res) =>
    request.security(syminfo.tickerid, _res, f_resInMinutes())
f_timefIsIntraday(_res) =>
    [intraday, daily, weekly, monthly] = request.security(syminfo.tickerid, _res, [timeframe.isintraday, timeframe.isdaily, timeframe.isweekly, timeframe.ismonthly])
    check = intraday ? "Intraday" : daily ? "Daily" : weekly ? "Weekly" : monthly ? "Monthly" : "Error" 
    check
mtimef_multiplier = int (f_timefResInMinutes(timef) / f_resInMinutes())
prd = 10
maxnumpp = 284
ChannelW = 10
min_strength = 2
prd := prd * mtimef_multiplier
float src1 = math.max(src_c, src_o) 
float src2 = math.min(src_c, src_o)
float src3 = math.max(close, open)  
float src4 = math.min(close, open)   
float phsa = ta.pivothigh(src1, prd, prd)
float plsa = ta.pivotlow(src2, prd, prd)
Lstyle = line.style_solid
timef_res = f_timefIsIntraday(timef)
timef_text = str.tostring(timef)
if str.tostring(timef) == ""
    timef_text := na(timeframe.multiplier / 60) ? timeframe.period : timeframe.multiplier < 60 ?  timeframe.period + " M |" : str.tostring(timeframe.multiplier / 60) + " H |"
else if timef_res == "Intraday"
    timef_text := na(str.tonumber(timef) / 60) ? str.tostring(timef) : str.tonumber(timef) < 60 ?  str.tostring(timef) + " M |" : str.tostring(str.tonumber(timef) / 60) + " H |"
else
    timef_text := str.tostring(timef)
//calculate maximum S/R channel zone width
prdhighest = request.security(syminfo.tickerid, timef, ta.highest(300))
prdlowest = request.security(syminfo.tickerid, timef, ta.lowest(300))
cwidth = (prdhighest - prdlowest) * ChannelW / 100
var pivotvals = array.new_float(0)
if phsa or plsa
    array.unshift(pivotvals, phsa ? phsa : plsa)
    if array.size(pivotvals) > maxnumpp  // limit the array size
        array.pop(pivotvals)
get_sr_vals(ind) =>
    float lo = array.get(pivotvals, ind)
    float hi = lo
    int numpp = 0
    for y = 0 to array.size(pivotvals) - 1 by 1
        float cpp = array.get(pivotvals, y)
        float wdth = cpp <= lo ? hi - cpp : cpp - lo
        if wdth <= cwidth  // fits the max channel width?
            lo := cpp <= lo ? cpp : lo
            hi := cpp > lo ? cpp : hi
            numpp += 1
            numpp
    [hi, lo, numpp]
var sr_up_level = array.new_float(0)
var sr_dn_level = array.new_float(0)
sr_strength = array.new_float(0)

find_loc(strength) =>
    ret = array.size(sr_strength)
    for i = ret > 0 ? array.size(sr_strength) - 1 : na to 0 by 1
        if strength <= array.get(sr_strength, i)
            break
        ret := i
        ret
    ret

check_sr(hi, lo, strength) =>
    ret = true
    for i = 0 to array.size(sr_up_level) > 0 ? array.size(sr_up_level) - 1 : na by 1
        //included?
        if array.get(sr_up_level, i) >= lo and array.get(sr_up_level, i) <= hi or array.get(sr_dn_level, i) >= lo and array.get(sr_dn_level, i) <= hi
            if strength >= array.get(sr_strength, i)
                array.remove(sr_strength, i)
                array.remove(sr_up_level, i)
                array.remove(sr_dn_level, i)
                ret
            else
                ret := false
                ret
            break
    ret

var sr_lines = array.new_line(11, na)
var sr_labels = array.new_label(11, na)
var timef_labels = array.new_label(11, na)

if phsa or plsa
    //because of new calculation, remove old S/R levels
    array.clear(sr_up_level)
    array.clear(sr_dn_level)
    array.clear(sr_strength)
    //find S/R zones
    for x = 0 to array.size(pivotvals) - 1 by 1
        [hi, lo, strength] = get_sr_vals(x)
        if check_sr(hi, lo, strength)
            loc = find_loc(strength)
            // if strength is in first levels sr then insert it to the arrays 
            if loc < levels and strength >= min_strength
                array.insert(sr_strength, loc, strength)
                array.insert(sr_up_level, loc, hi)
                array.insert(sr_dn_level, loc, lo)
                // keep size of the arrays = 5
                if array.size(sr_strength) > levels
                    array.pop(sr_strength)
                    array.pop(sr_up_level)
                    array.pop(sr_dn_level)

    for x = 1 to 10 by 1
        line.delete(array.get(sr_lines, x))
        label.delete(array.get(sr_labels, x))
        label.delete(array.get(timef_labels, x))

    for x = 0 to array.size(sr_up_level) > 0 ? array.size(sr_up_level) - 1 : na by 1
        float mid = math.round_to_mintick((array.get(sr_up_level, x) + array.get(sr_dn_level, x)) / 2)
        if showSR
            array.set(sr_lines, x + 1, line.new(x1=bar_index, y1=mid, x2=bar_index - 1, y2=mid, extend=extend.both, color=mid >= close ? resistancecolor : supportcolor, style=Lstyle, width=linewidth))
            if labelon == "On" 
                size = labelsize == "Small" ? size.small : labelsize == "Default" ? size.normal : size.large
                array.set(sr_labels, x + 1, label.new(x=bar_index + labelloc, y=mid, text=(showtimef ? timef_text : na) + (showtprice ? (" " + str.tostring(mid)) : na), color=mid >= close ? #ff525200 : #00e67700, textcolor=labelcol,
                 size = size, style=label.style_label_left))

f_crossed_over() =>
    ret = false
    for x = 0 to array.size(sr_up_level) > 0 ? array.size(sr_up_level) - 1 : na by 1
        float mid = math.round_to_mintick((array.get(sr_up_level, x) + array.get(sr_dn_level, x)) / 2)
        if close[1] <= mid and close > mid
            ret := true
            ret
    ret

f_crossed_under() =>
    ret = false
    for x = 0 to array.size(sr_up_level) > 0 ? array.size(sr_up_level) - 1 : na by 1
        float mid = math.round_to_mintick((array.get(sr_up_level, x) + array.get(sr_dn_level, x)) / 2)
        if close[1] >= mid and close < mid
            ret := true
            ret
    ret

// Signals

stability = 0.5
rsiindex = 50
candledelta = 5



//
stable_candle = math.abs(close - open) / ta.tr > stability
rsi = ta.rsi(close, 14)

bullish_engulfing = close[1] < open[1] and close > open and close > open[1]
rsi_below_50 = rsi < rsiindex
decrease_over_5 = close < close[candledelta]

bulla = bullish_engulfing and stable_candle and rsi_below_50 and decrease_over_5


bearish_engulfing = close[1] > open[1] and close < open and close < open[1]
rsi_above_50 = rsi > rsiindex
increase_over_5 = close > close[candledelta]

beara = bearish_engulfing and stable_candle and rsi_above_50 and increase_over_5


signalmode = input.string(defval="Futures Algo", title="Algo Mode", options = ["EzAlgo V9", "Gainz Algo", "Futures Algo", "Close"], group="Build in Algo's")



colorBuy = (theme == 'Colored' ? #00897799 : #70727799)
colorSell = (theme == 'Colored' ? #f2364699 : #70727799)
colorBuytp = (theme == 'Colored' ? #ff0015 : #70727799)
colorSelltp = (theme == 'Colored' ? #00ff0a : #70727799)
showReversal = true

wavetrend(src, chlLen, avgLen) =>
    esa = ta.ema(src, chlLen)
    d = ta.ema(math.abs(src - esa), chlLen)
    ci = (src - esa) / (0.015 * d)
    wt1 = ta.ema(ci, avgLen)
    wt2 = ta.sma(wt1, 3)
    [wt1, wt2]
[wt1, wt2] = wavetrend(hlc3, 13, 21)

//frost = bull ? plotshape(style = shape.labelup, location = location.belowbar, color = colorBuy, size=size.small) : na
//frost1 = bear ? plotshape(bar_index , high, 'SELL', color=selllbl, style=labelystylybear, textcolor=txtcl, size=sizy) : na

plotshape(showReversal and signalmode == "Gainz Algo" and bulla , "Reversal Buy" , shape.labelup, location.belowbar, color = colorBuy, size=size.small)
plotshape(showReversal and signalmode == "Gainz Algo" and beara , "Reversal Sell", shape.labeldown, location.abovebar, color = colorSell, size=size.small)

plotshape(showReversal and signalmode == "EzAlgo V9" and ta.crossover(wt1, wt2) and wt2 <= -55, "EzAlgo V9 Buy" , shape.labelup, location.belowbar, color = colorBuy, size=size.small)
plotshape(showReversal and signalmode == "EzAlgo V9" and ta.crossunder(wt1, wt2) and wt2 >= 55, "EzAlgo V9 Sell", shape.labeldown, location.abovebar, color = colorSell, size=size.small)

// Take Profit Points
Showtpp = input.bool(false, 'Possible Take Profit', inline = 'overlayLine53', group="Build in Algo's")
wavetrendd(srcd, chlLend, avgLend) =>
    esad = ta.ema(srcd, chlLend)
    dd = ta.ema(math.abs(srcd - esad), chlLend)
    cid = (srcd - esad) / (0.015 * dd)
    wt1d = ta.ema(cid, avgLend)
    wt2d = ta.sma(wt1d, 3)
    [wt1d, wt2d]

[wt1d, wt2d] = wavetrend(close, 5, 10)
plotshape(ta.crossover(wt1d, wt2d) and wt2d <= -53 and showReversal and Showtpp, "Don't Sell/Bottom" , shape.xcross, location.belowbar, colorBuytp, size=size.tiny)
plotshape(ta.crossunder(wt1d, wt2d) and wt2d >= 53 and showReversal and Showtpp, "Don't Buy/Top", shape.xcross, location.abovebar, colorSelltp, size=size.tiny)


// Selection
ShowSmartTrail = input.bool(false, 'Smart Trail', inline = 'overlayLine1', group="Build in Algo's")
show_rev = input.bool(false, 'Reversal Cloud', inline = 'overlayLine4', group="Build in Algo's")
Show_rangefilter = input.bool(false, 'Trend Catcher', inline = 'overlayLine5', group="Build in Algo's")
Show_SuperIchi = input.bool(false, 'SuperIchi', inline = 'overlayLine6', group="Build in Algo's")

// Smart Trail
trailType = 'modified'
ATRPeriod = 13
ATRFactor = 4
smoothing = 8

norm_o = request.security(ticker.new(syminfo.prefix, syminfo.ticker), timeframe.period, open)
norm_h = request.security(ticker.new(syminfo.prefix, syminfo.ticker), timeframe.period, high)
norm_l = request.security(ticker.new(syminfo.prefix, syminfo.ticker), timeframe.period, low)
norm_c = request.security(ticker.new(syminfo.prefix, syminfo.ticker), timeframe.period, close)
//}

//////// FUNCTIONS //////////////
//{
// Wilders ma //
Wild_ma(_src, _malength) =>
    _wild = 0.0
    _wild := nz(_wild[1]) + (_src - nz(_wild[1])) / _malength
    _wild

/////////// TRUE RANGE CALCULATIONS ///////////////// 
HiLo = math.min(norm_h - norm_l, 1.5 * nz(ta.sma(norm_h - norm_l, ATRPeriod)))

HRef = norm_l <= norm_h[1] ? norm_h - norm_c[1] : norm_h - norm_c[1] - 0.5 * (norm_l - norm_h[1])

LRef = norm_h >= norm_l[1] ? norm_c[1] - norm_l : norm_c[1] - norm_l - 0.5 * (norm_l[1] - norm_h)

trueRange = trailType == 'modified' ? math.max(HiLo, HRef, LRef) : math.max(norm_h - norm_l, math.abs(norm_h - norm_c[1]), math.abs(norm_l - norm_c[1]))
//}


/////////// TRADE LOGIC ////////////////////////
//{
loss = ATRFactor * Wild_ma(trueRange, ATRPeriod)

Up = norm_c - loss
Dn = norm_c + loss

TrendUp = Up
TrendDown = Dn
Trend = 1

TrendUp := norm_c[1] > TrendUp[1] ? math.max(Up, TrendUp[1]) : Up
TrendDown := norm_c[1] < TrendDown[1] ? math.min(Dn, TrendDown[1]) : Dn

Trend := norm_c > TrendDown[1] ? 1 : norm_c < TrendUp[1] ? -1 : nz(Trend[1], 1)
trail = Trend == 1 ? TrendUp : TrendDown

ex = 0.0
ex := ta.crossover(Trend, 0) ? norm_h : ta.crossunder(Trend, 0) ? norm_l : Trend == 1 ? math.max(ex[1], norm_h) : Trend == -1 ? math.min(ex[1], norm_l) : ex[1]
//}

////// FIBONACCI LEVELS ///////////
//{
state = Trend == 1 ? 'long' : 'short'

fib1Level = 61.8
fib2Level = 78.6
fib3Level = 88.6

f1 = ex + (trail - ex) * fib1Level / 100
//signalcocaie = xacad + xacafag + xacafag
f2 = ex + (trail - ex) * fib2Level / 100
f3 = ex + (trail - ex) * fib3Level / 100
l100 = trail + 0
colorpstlineb = (theme == 'Colored' ? #2157f9 : #434651e8)
colorstlines = (theme == 'Colored' ? #ff1100 : #707277e8)
colorstfb = (theme == 'Colored' ? #2157f933 : #43465130)
colorstfs = (theme == 'Colored' ? #ff110033 : #70727730)
fill(plot(ShowSmartTrail ? (ta.sma(trail, smoothing)) : na, 'Trailingstop', style=plot.style_line, color=Trend == 1 ? colorpstlineb : Trend == -1 ? colorstlines : na),
 plot( ShowSmartTrail ? (ta.sma(f2, smoothing)) : na, 'Fib 2', style=plot.style_line, display=display.none),
 color=state == 'long' ? colorstfb : state == 'short' ? colorstfs : na)
//}

// Lux Algo Reversal Band
//func
kama(ssrc, llen) =>
    kama = 0.0
    sum_1 = math.sum(math.abs(ssrc - ssrc[1]), llen)
    sum_2 = math.sum(math.abs(ssrc - ssrc[1]), llen)
    kama := nz(kama[1]) + math.pow((sum_1 != 0 ? math.abs(ssrc - ssrc[llen]) / sum_2 : 0) * (0.288 - 0.0666) + 0.0666, 2) * (ssrc - nz(kama[1]))
    kama

//inputs
llength = 50
bd1 = 9
bd2 = 11
bd3 = 14

//logic
rg = kama(ta.tr, llength)
basiss = kama(close, llength)
upper1s = basiss + rg * bd1
upper2 = basiss + rg * bd2
upper3 = basiss + rg * bd3
lower1s = basiss - rg * bd1
lower2 = basiss - rg * bd2
lower3 = basiss - rg * bd3

//ploting
pp1 = plot(show_rev ? upper1s : na, transp=100)
//signalsourcegenerator = xbled + xefx + xaik + xefx + xiakx + xykad + xykabadada + xykadagaba
pp2 = plot(show_rev ? upper2  : na, transp=100)
pp3 = plot(show_rev ? upper3  : na, transp=100)
//reversalengine = xacw + xiuk + xtod + xfop + xsad
pp4 = plot(show_rev ? lower1s  : na, transp=100)
pp5 = plot(show_rev ? lower2  : na, transp=100)
//cacheclear = xweb + xsite + xdomain + 'site: '
//pp6 = plot(show_rev ? lower3  : na, transp=100)
//labelplotornot = xfwad + xebl + xoo + xoo









// Range Filter DW 


//---------------------Range Filter----------------------------------------------------------------------------------------------------------------------

//Conditional Sampling EMA Function 
Cond_EMA(x, cond, n) =>
    var val = array.new_float(0)
    var ema_val = array.new_float(1)
    if cond
        array.push(val, x)
        if array.size(val) > 1
            array.remove(val, 0)
        if na(array.get(ema_val, 0))
            array.fill(ema_val, array.get(val, 0))
        array.set(ema_val, 0, (array.get(val, 0) - array.get(ema_val, 0)) * (2 / (n + 1)) + array.get(ema_val, 0))
    EMA = array.get(ema_val, 0)
    EMA

//Conditional Sampling SMA Function
Cond_SMA(x, cond, n) =>
    var vals = array.new_float(0)
    if cond
        array.push(vals, x)
        if array.size(vals) > n
            array.remove(vals, 0)
    SMA = array.avg(vals)
    SMA

//Standard Deviation Function
Stdev(x, n) =>
    math.sqrt(Cond_SMA(math.pow(x, 2), 1, n) - math.pow(Cond_SMA(x, 1, n), 2))

//Range Size Function
rng_size(x, scale, qty, n) =>
    ATR = Cond_EMA(ta.tr(true), 1, n)
    AC = Cond_EMA(math.abs(x - x[1]), 1, n)
    SD = Stdev(x, n)
    rng_size = scale == 'Pips' ? qty * 0.0001 : scale == 'Points' ? qty * syminfo.pointvalue : scale == '% of Price' ? close * qty / 100 : scale == 'ATR' ? qty * ATR : scale == 'Average Change' ? qty * AC : scale == 'Standard Deviation' ? qty * SD : scale == 'Ticks' ? qty * syminfo.mintick : qty
    rng_size



sensitivity = 4.5
supertrend(_src, factor, atrLen) =>
	atr = ta.atr(atrLen)
	upperBand = _src + factor * atr
	lowerBand = _src - factor * atr
	prevLowerBand = nz(lowerBand[1])
	prevUpperBand = nz(upperBand[1])
	lowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand
	upperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand
	int direction = na
	float superTrend = na
	prevSuperTrend = superTrend[1]
	if na(atr[1])
		direction := 1
	else if prevSuperTrend == prevUpperBand
		direction := close > upperBand ? -1 : 1
	else
		direction := close < lowerBand ? 1 : -1
	superTrend := direction == -1 ? lowerBand : upperBand
	[superTrend, direction] 
	


// SMA 
ocAvg       = math.avg(open, close)
sma44        = ta.sma(close, 8)
sma55        = ta.sma(close, 9)
sma99        = ta.sma(close, 13)
psarr        = ta.sar(0.02, 0.02, 0.2)
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
//*in Easy Words Super Trend + SMA = Signals
[supertrend, direction] = supertrend(close, sensitivity, 11)

// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
sourceee = close, periodd = 150
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
// High Lows
y11 = low - (ta.atr(30) * 2), y1B = low - ta.atr(30)
y22 = high + (ta.atr(30) * 2), y2B = high + ta.atr(30)
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
bullw = ta.crossover(close, supertrend) and close >= sma99
bearw = ta.crossunder(close, supertrend) and close <= sma99
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
// Braid Filter
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
//-- Inputs
maType = 'McGinley'
Period1 = 3
Period2 = 7
Period3 = 20
PipsMinSepPercent = 80

//-- Moving Average
ma(type, src, len) =>
    float result = 0
    if type == 'SMA'  // Simple
        result := ta.sma(src, len)
        result
    if type == 'EMA'  // Exponential
        result := ta.ema(src, len)
        result
    if type == 'DEMA'  // Double Exponential
        e = ta.ema(src, len)
        result := 2 * e - ta.ema(e, len)
        result
    if type == 'TEMA'  // Triple Exponential
        e = ta.ema(src, len)
        result := 3 * (e - ta.ema(e, len)) + ta.ema(ta.ema(e, len), len)
        result
    if type == 'WMA'  // Weighted
        result := ta.wma(src, len)
        result
    if type == 'VWMA'  // Volume Weighted
        result := ta.vwma(src, len)
        result
    if type == 'SMMA'  // Smoothed
        w = ta.wma(src, len)
        result := na(w[1]) ? ta.sma(src, len) : (w[1] * (len - 1) + src) / len
        result
    if type == 'RMA'
        result := ta.rma(src, len)
        result
    if type == 'HMA'  // Hull
        result := ta.wma(2 * ta.wma(src, len / 2) - ta.wma(src, len), math.round(math.sqrt(len)))
        result
    if type == 'LSMA'  // Least Squares
        result := ta.linreg(src, len, 0)
        result
    if type == 'Kijun'  //Kijun-sen
        kijun = math.avg(ta.lowest(len), ta.highest(len))
        result := kijun
        result
    if type == 'McGinley'
        mg = 0.0
        mg := na(mg[1]) ? ta.ema(src, len) : mg[1] + (src - mg[1]) / (len * math.pow(src / mg[1], 4))
        result := mg
        result
    result

//-- Braid Filter   
ma01 = ma(maType, close, Period1)
ma02 = ma(maType, open, Period2)
ma03 = ma(maType, close, Period3)
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
max = math.max(math.max(ma01, ma02), ma03)
min = math.min(math.min(ma01, ma02), ma03)
dif = max - min
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
filter = ta.atr(14) * PipsMinSepPercent / 100
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
//-- Plots
BraidColor = ma01 > ma02 and dif > filter ? color.green : ma02 > ma01 and dif > filter ? color.red : color.gray

//plot(dif, 'Braid', BraidColor, 5, plot.style_columns)
//plot(filter, 'Filter', color.new(color.blue, 0), 2, plot.style_line)
//bgcolor(BraidColor, transp=90)

// Braid Filter Finish

//buy  = bull and ma01 > ma02 and dif > filter ? label.new(bar_index, y1, "▲", xloc.bar_index, yloc.price, #04994b, label.style_label_up, color.white, size.normal) : na
//sell = bear and ma02 > ma01 and dif > filter ? label.new(bar_index, y2, "▼", xloc.bar_index, yloc.price, #b4060d, label.style_label_down, color.white, size.normal) : na
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
colortteb = (theme == 'Colored' ? #04994b : #7072777e)
colorttes = (theme == 'Colored' ? #b4060d : #4346517e)
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
buy  =  bullw and signalmode == "Futures Algo" ? label.new(bar_index, y11, sma44 >= sma55 ? "▲" : "▲+", xloc.bar_index, yloc.price, colortteb, label.style_label_up, color.white, size.normal) : na
sell =  bearw and signalmode == "Futures Algo" ? label.new(bar_index, y22, sma44 <= sma55 ? "▼" : "▼+", xloc.bar_index, yloc.price, colorttes, label.style_label_down, color.white, size.normal) : na
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
// Futures Algo Take Profit
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
multiplier = 2
src5 = close
len5 = 150
offsete = 0
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
calcSlope(src5, len5) =>
    sumX = 0.0
    sumY = 0.0
    sumXSqr = 0.0
    sumXY = 0.0
    for i = 1 to len5 by 1
        val = src5[len5 - i]
        per = i + 1.0
        sumX += per
        sumY += val
        sumXSqr += per * per
        sumXY += val * per
        sumXY


    slope = (len5 * sumXY - sumX * sumY) / (len5 * sumXSqr - sumX * sumX)
    average = sumY / len5
    intercept = average - slope * sumX / len5 + slope
    [slope, average, intercept]

var float tmp = na
[s, a, i] = calcSlope(src5, len5)
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
vwap1 = i + s * (len5 - offsete)
sdev = ta.stdev(close, len5)
dev = multiplier * sdev
top = vwap1 + dev
bott = vwap1 - dev
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
//
z1 = vwap1 + dev
x1aa = vwap1 - dev
// This code is created by algopoint. All other leaked algos is available at algopoint.mysellix.io
// AlgoPoint Official Contact Adrress
// Instagram:             algopoint
// Instagram:             algopoint01
// Website:               algopoint.mysellix.io
// Mail:                  algopointstore@gmail.com
low1 = ta.crossover(close, x1aa)
high1 = ta.crossunder(close, z1)
colortpb = (theme == 'Colored' ? #0055ff : #4346517e)
colortps = (theme == 'Colored' ? #0055ff : #4346517e)
plotshape(signalmode == "Futures Algo" and close < supertrend ? low1 : na, title='low', text='', color=colortps, style=shape.xcross, location=location.belowbar, size=size.tiny, textcolor=color.new(color.white, 0))  //plot for buy icon
plotshape(signalmode == "Futures Algo" and close > supertrend ? high1 : na, title='high', text='', color=colortpb, style=shape.xcross, location=location.abovebar, size=size.tiny, textcolor=color.new(color.white, 0))  //plot for sell icon


// ==========================================================================================

// === Dashboard with Telegram Link ===
var table myTable = table.new(position.top_center, 1, 1, border_width=1, frame_color=color.black, bgcolor=color.white)

// Add Telegram Message to Dashboard
table.cell(myTable, 0, 0, "Join Telegram @simpleforextools", bgcolor=color.blue, text_color=color.white, text_size=size.normal)