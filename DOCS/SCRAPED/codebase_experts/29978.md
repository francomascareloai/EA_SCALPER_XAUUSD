# Design patterns - Abstract Factory - library for MetaTrader 5

Source: https://www.mql5.com/en/code/29978

* [![](https://c.mql5.com/i/sidebar/mt.svg)MetaTrader 5](/en/code/mt5)
  + [![](https://c.mql5.com/i/sidebar/expert.svg)Experts](/en/code/mt5/experts)
  + [![](https://c.mql5.com/i/sidebar/indicator.svg)Indicators](/en/code/mt5/indicators)
  + [![](https://c.mql5.com/i/sidebar/scripts.svg)Scripts](/en/code/mt5/scripts)
  + [![](https://c.mql5.com/i/sidebar/library.svg)Libraries](/en/code/mt5/libraries)
* [![](https://c.mql5.com/i/sidebar/mt.svg)MetaTrader 4](/en/code/mt4)
  + [![](https://c.mql5.com/i/sidebar/expert.svg)Experts](/en/code/mt4/experts)
  + [![](https://c.mql5.com/i/sidebar/indicator.svg)Indicators](/en/code/mt4/indicators)
  + [![](https://c.mql5.com/i/sidebar/scripts.svg)Scripts](/en/code/mt4/scripts)
  + [![](https://c.mql5.com/i/sidebar/library.svg)Libraries](/en/code/mt4/libraries)

* [![](https://c.mql5.com/i/sidebar/storage.svg)Storage](/en/code/storage)

Watch [how to download](https://youtu.be/rloNyFVtHuA?list=PLltlMLQ7OLeKwyQwC8FhiKwjl9syKhOCK) trading robots for free

Find us on [Twitter](https://x.com/mql5com)!  
 Join our fan page

Interesting script?  
So post a [link](/en/code/29978) to it -  
let others appraise it

You liked the script? Try it in the [MetaTrader 5](https://download.mql5.com/cdn/web/metaquotes.ltd/mt5/mt5setup.exe?utm_source=www.mql5.com&utm_campaign=download) terminal

[to pocket](#pocket "Pocket allows you to insert a complete content description to the appropriate comment")

![Libraries](https://c.mql5.com/i/code/library.png)

# Design patterns - Abstract Factory - library for MetaTrader 5

[DMITRII PECHERITSA](/en/users/dmipec)

Views:
:   3050

Rating:
:   (7)

Published:
:   15 July 2020, 11:42
:   [Pattern.mq5](/en/code/download/29978/pattern.mq5 "Pattern.mq5")
    (0.11 KB)
    [view](# "view")

    [Patterns.mqh](/en/code/download/29978/patterns.mqh "Patterns.mqh")
    (0.41 KB)
    [view](# "view")

    [AbstractFactory.mqh](/en/code/download/29978/abstractfactory.mqh "AbstractFactory.mqh")
    (26 KB)
    [view](# "view")

    [Download as ZIP](/en/code/download/29978.zip "Download all attachments in the single ZIP archive") [How to download code from MetaEditor](https://www.metatrader5.com/en/metaeditor/help/workspace/toolbox#codebase)

    ![MQL5 - Language of trade strategies built-in the MetaTrader 5 client terminal](https://c.mql5.com/i/registerlandings/logo-2.png)

    You are missing trading opportunities:

    * Free trading apps
    * Over 8,000 signals for copying
    * Economic news for exploring financial markets

    Registration
    Log in

    latin characters without spaces

    a password will be sent to this email

    An error occurred

    * [Log in With Google](https://www.mql5.com/en/auth_oauth2?provider=Google&amp;return=popup&amp;reg=1)

    You agree to [website policy](/en/about/privacy) and [terms of use](/en/about/terms)

    If you do not have an account, please [register](https://www.mql5.com/en/auth_register)

    Allow the use of cookies to log in to the MQL5.com website.

    Please enable the necessary setting in your browser, otherwise you will not be able to log in.

     

    [Forgot your login/password?](https://www.mql5.com/en/auth_forgotten?return=popup)

    * [Log in With Google](https://www.mql5.com/en/auth_oauth2?provider=Google&amp;return=popup)
:   ![MQL5 Freelance](https://c.mql5.com/i/code/icon_freelance.svg)
    Need a robot or indicator based on this code? Order it on Freelance
    [Go to Freelance](/en/job/new "Go to Freelance")

```mql5
//+----------------+----------------------------------------------------------------------------------------+
//|    Abstract    | Provide an interface for creating families of related or dependent objects without     |
//|     Factory    | specifying their concrete classes.                                                     |
//+----------------+----------------------------------------------------------------------------------------+
//|      When      | 1) a system should be independent of how its products are created, composed, and       |
//|                | represented. 2) a system should be configured with one of multiple families of         |
//|                | products. 3) a family of related product objects is designed to be used together, and  |
//|                | you need to enforce this constraint. 4) you want to provide a class library of         |
//|                | products, and you want to reveal just their interfaces, not their implementations.     |
//+----------------+----------------------------------------------------------------------------------------+
//|                                                Structure                                                |
//+---------------------------------------------------------------------------------------------------------+
//
//               +----------------+                                                              +------+
//               | AbstractFactory|<-------------------------------------------------------------|Client|
//               +----------------+                                                              +------+
//               |CreateProductA()|                                +----------------+                |
//               |CreateProductA()|                                |AbstractProductA|<---------------+
//               +----------------+                                +----------------+                |
//                        ^                                                ^                         |
//                        |                                                |                         |
//            +-----------+-----------+                            +-------+------+                  |
//            |                       |                            |              |                  |
//   +----------------+      +----------------+               +---------+    +---------+             |
//   |ConcreteFactory1|- +   |ConcreteFactory2|- - - - + - - >|ProductA2|    |ProductA1|<- - - +     |
//   +----------------+  |   +----------------+        |      +---------+    +---------+       |     |
//   |CreateProductA()|      |CreateProductA()|                                                      |
//   |CreateProductB()|  |   |CreateProductB()|        |                                       |     |
//   +----------------+      +----------------+                                                      |
//                       |                             |                                       |     |
//                                                                 +----------------+                |
//                       |                             |           |AbstractProductB|<---------|-----+
//                                                                 +----------------+
//                       |                             |                   ^                   |
//                                                                         |
//                       |                             |           +-------+------+            |
//                                                                 |              |
//                       |                             |      +---------+    +---------+       |
//                                                     + - - >|ProductB2|    |ProductB1|<- - - +
//                       |                                    +---------+    +---------+       |
//
//                       |                                                                     |
//                       + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
//
//+-----+----------+----------------------------------------------------------------------------------------+
//| Who | Abstract | declares an interface for operations that create abstract product objects.             |
//|     |  Factory |                                                                                        |
//|     +----------+----------------------------------------------------------------------------------------+
//|     | Concrete | implements the operations to create concrete product objects.                          |
//|     |  Factory |                                                                                        |
//|     +----------+----------------------------------------------------------------------------------------+
//|     | Abstract | declares an interface for a type of product object.                                    |
//|     |  Product |                                                                                        |
//|     +----------+----------------------------------------------------------------------------------------+
//|     | Concrete | 1) defines a product object to be created by the corresponding concrete factory. 2)    |
//|     |  Product | implements the AbstractProduct interface.                                              |
//|     +----------+----------------------------------------------------------------------------------------+
//|     |   Client | uses only interfaces declared by AbstractFactory and AbstractProduct classes.          |
//+-----+----------+----------------------------------------------------------------------------------------+
//|       How      | 1) Normally a single instance of a ConcreteFactory class is created at run-time. This  |
//|                | concrete factory creates product objects having a particular implementation. To        |
//|                | create different product objects, clients should use a different concrete factory. 2)  |
//|                | AbstractFactory defers creation of product objects to its ConcreteFactory subclass.    |
//+----------------+----------------------------------------------------------------------------------------+
//|       Why      | 1) It isolates concrete classes: Clients manipulate instances through their abstract   |
//|                | interfaces. 2) It makes exchanging product families easy: use different product        |
//|                | configurations simply by changing the concrete factory; the whole product family       |
//|                | changes at once. 3) It promotes consistency among products. 4) Supporting new kinds    |
//|                | of products is difficult: requires extending the factory interface, AbstractFactory    |
//|                | class and all of its subclasses.                                                       |
//+----------------+----------------------------------------------------------------------------------------+
//|      Notes     | 1) Factories as singletons. 2) Creating the products: define a factory method for      |
//|                | each product. If many product families are possible, the concrete factory can be a     |
//|                | Prototype: no new concrete factory class for each new product family. 3) Defining      |
//|                | extensible factories: AbstractFactory will only need a single "Make" operation with a  |
//|                | parameter indicating the kind of object to create; all objects have the same abstract  |
//|                | base class.                                                                            |
//+----------------+----------------------------------------------------------------------------------------+
//|                                                   Code                                                  |
//+---------------------------------------------------------------------------------------------------------+
#include <SRC\Patterns\Patterns.mqh>
namespace AbstractFactory
{
interface AbstractProductA {};
interface AbstractProductB {void Interact(AbstractProductA*);};
interface AbstractFactory
  {
   AbstractProductA* CreateProductA();
   AbstractProductB* CreateProductB();
  };
//--------------------------------------------------------------------
class ProductA1:public AbstractProductA {public:ProductA1(); ~ProductA1();};
void ProductA1::ProductA1(void) {Print(" Product A1 constructed.");}
void ProductA1::~ProductA1(void) {Print(" Product A1 destructed.");}
//--------------------------------------------------------------------
class ProductA2:public AbstractProductA {public:ProductA2(); ~ProductA2();};
void ProductA2::ProductA2(void) {Print(" Product A2 constructed.");}
void ProductA2::~ProductA2(void) {Print(" Product A2 destructed.");}
//--------------------------------------------------------------------
class ProductB1:public AbstractProductB
  {
public:
                     ProductB1();
                    ~ProductB1();
   void              Interact(AbstractProductA*);
  };
void ProductB1::ProductB1(void) {Print(" Product B1 constructed.");}
void ProductB1::~ProductB1(void) {Print(" Product B1 destructed.");}
void ProductB1::Interact(AbstractProductA*p) {Print("  Product B1: ",&this," interacts with Product A: ",p);}
//--------------------------------------------------------------------
class ProductB2:public AbstractProductB
  {
public:
                     ProductB2();
                    ~ProductB2();
   void              Interact(AbstractProductA*);
  };
void ProductB2::ProductB2(void) {Print(" Product B2 constructed.");}
void ProductB2::~ProductB2(void) {Print(" Product B2 destructed.");}
void ProductB2::Interact(AbstractProductA*p) {Print("  Product B2: ",&this," interacts with Product A: ",p);}
//--------------------------------------------------------------------
class Factory1:public AbstractFactory
  {
public:
                     Factory1();
                    ~Factory1();
   AbstractProductA* CreateProductA();
   AbstractProductB* CreateProductB();
  };
//---
void Factory1::Factory1(void) {Print("Factory 1 constructed.");}
void Factory1::~Factory1(void) {Print("Factory 1 destructed.");}
AbstractProductA* Factory1::CreateProductA(void) {return new ProductA1;}
AbstractProductB* Factory1::CreateProductB(void)  {return new ProductB1;}
//--------------------------------------------------------------------
class Factory2:public AbstractFactory
  {
public:
                     Factory2();
                    ~Factory2();
   AbstractProductA* CreateProductA();
   AbstractProductB* CreateProductB();
  };
//---
void Factory2::Factory2(void) {Print("Factory 2 constructed.");}
void Factory2::~Factory2(void) {Print("Factory 2 destructed.");}
AbstractProductA* Factory2::CreateProductA(void) {return new ProductA1;}
AbstractProductB* Factory2::CreateProductB(void) {return new ProductB1;}
//--------------------------------------------------------------------
class FactoryClient
  {
public:
   void              Run();
   void              Switch(AbstractFactory*);
                     FactoryClient(AbstractFactory*);
                    ~FactoryClient();
protected:
   AbstractProductA* apa;
   AbstractProductB* apb;
   AbstractFactory*  factory;
   void              Delete();
  };
//---
void FactoryClient::FactoryClient(AbstractFactory* af)   {Switch(af);}
void FactoryClient::~FactoryClient(void)                 {Delete();}
void FactoryClient::Run(void)                            {apb.Interact(apa);}
void FactoryClient::Delete(void)    {delete apa; delete apb; delete factory;}
void FactoryClient::Switch(AbstractFactory *af)
  {
   Delete();
   factory=af;
   apa=factory.CreateProductA();
   apb=factory.CreateProductB();
  }
//--------------------------------------------------------------------
class Client:public ClientExample {public:string Output(); void Run();};
string Client::Output(void) {return __FUNCTION__;}
void Client::Run()
  {
   FactoryClient client(new Factory1);
   client.Run();
   client.Switch(new Factory2);
   client.Run();
  }
}
//+---------------------------------------------------------------------------------------------------------+
//|                                                  Output                                                 |
//+---------------------------------------------------------------------------------------------------------+
//Creational::AbstractFactory::Client::Output
//Factory 1 constructed.
// Product A1 constructed.
// Product B1 constructed.
//  Product B1: 126877696 interacts with Product A: 125829120
//Factory 2 constructed.
// Product A1 destructed.
// Product B1 destructed.
//Factory 1 destructed.
// Product A2 constructed.
// Product B2 constructed.
//  Product B2: 130023424 interacts with Product A: 128974848
// Product A2 destructed.
// Product B2 destructed.
//Factory 2 destructed.
```

**[Go to discussion](/en/forum/346700)**

![Identify potential entries](https://c.mql5.com/i/code/indicator.png)
[Identify potential entries](/en/code/30105)

I want to share with you this story. When I started trading, I learnt the scalping strategy in a volatile market. I really loved scalping especially when I see the price is moving fast. However, scalping for a long period of time is exhausting to me especially in a volatile market; volatile market requires fast analysis, actions and reactions; that is why I always reach a point that I loss concentration, focus and I start making those really stupid mistakes.
That is why I created this indicator that helped me to automatically identify these potential entries (based on the formation of candlesticks) instead of doing all the work myself. I know there are plenty of Metatraders who also suffer from this and that is why I would like to share this indicator with you, hopefully it will be beneficial. Do not forget to send you comments as well as rate these scripts. Happy trading!

![Design patterns - Twin](https://c.mql5.com/i/code/library.png)
[Design patterns - Twin](/en/code/29787)

Modeling multiple inheritance with the Twin pattern.

![Open Random Charts](https://c.mql5.com/i/code/script.png)
[Open Random Charts](/en/code/30185)

This script opens randomly selected charts and applies user-defined template.

![Identify potential Trends/Range (Pivot Points)](https://c.mql5.com/i/code/script.png)
[Identify potential Trends/Range (Pivot Points)](/en/code/30212)

When I start learning about trading, I remember the trading pioneer Shawn Lucas (founder of Apiary-fund) saying "trading is simple, you go from bound range market to breakout market and vice versa". I looked at few charts and he was right. So I told myself, I have to always eyeball ranging market and trending market but with the help of an indicator. There are plenty for indicator that help us eyeball these ranging/trending market and they work really well, but I like using Pivot Points.