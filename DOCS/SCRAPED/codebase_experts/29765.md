# Object List - library for MetaTrader 5

Source: https://www.mql5.com/en/code/29765

* [![](https://c.mql5.com/i/sidebar/mt.svg)MetaTrader 5](/en/code/mt5)
  + [![](https://c.mql5.com/i/sidebar/expert.svg)Experts](/en/code/mt5/experts)
  + [![](https://c.mql5.com/i/sidebar/indicator.svg)Indicators](/en/code/mt5/indicators)
  + [![](https://c.mql5.com/i/sidebar/scripts.svg)Scripts](/en/code/mt5/scripts)
  + [![](https://c.mql5.com/i/sidebar/library.svg)Libraries](/en/code/mt5/libraries)
* [![](https://c.mql5.com/i/sidebar/mt.svg)MetaTrader 4](/en/code/mt4)
  + [![](https://c.mql5.com/i/sidebar/expert.svg)Experts](/en/code/mt4/experts)
  + [![](https://c.mql5.com/i/sidebar/indicator.svg)Indicators](/en/code/mt4/indicators)
  + [![](https://c.mql5.com/i/sidebar/scripts.svg)Scripts](/en/code/mt4/scripts)
  + [![](https://c.mql5.com/i/sidebar/library.svg)Libraries](/en/code/mt4/libraries)

* [![](https://c.mql5.com/i/sidebar/storage.svg)Storage](/en/code/storage)

Watch [how to download](https://youtu.be/rloNyFVtHuA?list=PLltlMLQ7OLeKwyQwC8FhiKwjl9syKhOCK) trading robots for free

Find us on [Facebook](https://www.facebook.com/mql5.community/)!  
 Join our fan page

Interesting script?  
So post a [link](/en/code/29765) to it -  
let others appraise it

You liked the script? Try it in the [MetaTrader 5](https://download.mql5.com/cdn/web/metaquotes.ltd/mt5/mt5setup.exe?utm_source=www.mql5.com&utm_campaign=download) terminal

[to pocket](#pocket "Pocket allows you to insert a complete content description to the appropriate comment")

![Libraries](https://c.mql5.com/i/code/library.png)

# Object List - library for MetaTrader 5

[DMITRII PECHERITSA](/en/users/dmipec)

Views:
:   5556

Rating:
:   (10)

Published:
:   19 June 2020, 11:07

Updated:
:   20 June 2020, 06:12
:   [ObjectList.mq5](/en/code/download/29765/objectlist.mq5 "ObjectList.mq5")
    (3.56 KB)
    [view](# "view")

    [ObjectList.mqh](/en/code/download/29765/objectlist.mqh "ObjectList.mqh")
    (6.64 KB)
    [view](# "view")

    [Download as ZIP](/en/code/download/29765.zip "Download all attachments in the single ZIP archive") [How to download code from MetaEditor](https://www.metatrader5.com/en/metaeditor/help/workspace/toolbox#codebase)

    ![MQL5 - Language of trade strategies built-in the MetaTrader 5 client terminal](https://c.mql5.com/i/registerlandings/logo-2.png)

    You are missing trading opportunities:

    * Free trading apps
    * Over 8,000 signals for copying
    * Economic news for exploring financial markets

    Registration
    Log in

    latin characters without spaces

    a password will be sent to this email

    An error occurred

    * [Log in With Google](https://www.mql5.com/en/auth_oauth2?provider=Google&amp;return=popup&amp;reg=1)

    You agree to [website policy](/en/about/privacy) and [terms of use](/en/about/terms)

    If you do not have an account, please [register](https://www.mql5.com/en/auth_register)

    Allow the use of cookies to log in to the MQL5.com website.

    Please enable the necessary setting in your browser, otherwise you will not be able to log in.

     

    [Forgot your login/password?](https://www.mql5.com/en/auth_forgotten?return=popup)

    * [Log in With Google](https://www.mql5.com/en/auth_oauth2?provider=Google&amp;return=popup)
:   ![MQL5 Freelance](https://c.mql5.com/i/code/icon_freelance.svg)
    Need a robot or indicator based on this code? Order it on Freelance
    [Go to Freelance](/en/job/new "Go to Freelance")

```mql5
/****************************************************************
Object List
The List class template provides a basic container for storing an ordered list of objects.
For convenience, List also provides synonyms for stack operations,
 which make code that uses List for stacks more explicit without defining another class.
/**/
```

```mql5
/****************************************************************/
template<typename T>class ObjectList
  {
public:
   //construction, destruction, initialization, and assignment
                     ObjectList(bool memdelete=true):mdelete(memdelete) {}
                     ObjectList(ObjectList&src) {mdelete=src.mdelete; Copy(items,src.items); Copy(mem,src.mem);}
                    ~ObjectList() {RemoveAll(); if(mdelete) EmptyMem();}
   ObjectList        operator=(ObjectList&);
   void              MemDelete(bool memdelete) {mdelete=memdelete;}
   //accessing
   T*                operator[](int i) {return Get(i);}
   T*                Get(int at) {int c=Count(); if(c>0&&at>=0&&at<c) {return items[at];} return NULL;}
   T*                First() {int c=Count(); if(c>0) {return items[0];} return NULL;}
   T*                Last() {int c=Count(); if(c>0) {return items[c-1];} return NULL;}
   bool              TryGet(T*dst,int at) {if((dst=Get(at))!=NULL) {return true;} else {return false;}}
   //
   int               Count() {KillBad(); return ArraySize(items);}
   int               Find(T*item) {int c=Count(); for(int i=0; i<c; i++) {if(item==items[i]) {return i;}} return -1;}
   void              PrintHash() {for(int i=0; i<ArraySize(items); i++) {PrintFormat("%d:%d(%s)",i,Hash(items[i]),typename(items[i]));}}
   int               Hash(T*item) {string s; StringConcatenate(s,s,item); return (int)StringToInteger(s);}
   int               Hash(int at) {T*p=Get(at); return (p!=NULL)?Hash(p):0;}
   //adding
   void              operator+=(T*item) {Append(item);}
   void              operator^=(T*item) {Prepend(item);}
   void              Append(T*item) {Append(item,items);}
   void              Prepend(T*item) {IncreaseAt(0); items[0]=item;}
   //removing
   void              operator-=(T*item) {Remove(item,0);}
   void              operator/=(T*item) {Remove(item,1);}
   void              operator~() {RemoveAll();}
   void              Remove(T*item,bool del=0) {int f=Find(item); if(f>-1) {{if(del) {Delete(item);} else {Append(item,mem);}} ReduceAt(f);}}
   void              RemoveLast(bool del=0) {KillBad(); if(del) {Delete(Last());} else {Append(Last(),mem);} ReduceAt(ArraySize(items)-1);}
   void              RemoveFirst(bool del=0) {KillBad(); if(del) {Delete(First());} else {Append(First(),mem);} ReduceAt(0);}
   void              RemoveAll(bool del=0);
   //stack interface
   T*                Top() {return Last();}
   void              Push(T*item) {Append(item);}
   T*                Pop() {T*top=Top(); RemoveLast(); return top;}
protected:
   T*                items[];
   T*                mem[];
   bool              mdelete;
   //service
   void              Append(T*item,T*&dst[]) {int r=ArrayResize(dst,ArraySize(dst)+1); dst[r-1]=item;}
   void              EmptyMem() {for(int i=0; i<ArraySize(mem); i++) {Delete(mem[i]);} ArrayFree(mem);}
   void              Delete(T*item) {if(CheckPointer(item)==1)delete item;}
   void              KillBad() {for(int i=0; i<ArraySize(items); i++) {if(items[i]==NULL) {ReduceAt(i); i--;}}}
   void              ReduceAt(int);
   void              IncreaseAt(int);
   void              Copy(T*&dst[],T*&src[]) {int c=ArraySize(src); ArrayResize(dst,c); for(int i=0; i<c; i++) {dst[i]=src[i];}}
  };
/**/
```

```mql5
/****************************************************************
Structural notes
   By default, when the list is destroyed, it deletes all dynamic objects.
      Automatic objects will be destroyed anyway.
      This means that you do not have to use operator delete on any objects that you create.
      Once the object has been added to the list, it will not forget it,
       and be able to access it for erasing on destruction.
      Anything that is removed from the list, is transferred to the recycle bin,
       and kept there for safety, keeping the 'hanging' pointers,
       and thus minimizing the chance for the 'bad pointer access' critical error.
      This is justified in most cases, because computer memory is huge these days.
      There is not much burden on efficiency either, only memory, slight though.
      However, for flexibility, the Remove methods have the option to permanently delete the removed object.
      If you need to keep the objects after the list destruction (rare),
       use the MemDelete method to set the memdelete flag false.
      The 'del' parameter in Remove methods is a flag for deleting the object from memory.
      Access to the object will no longer be available, and will raise a critical error.
   The list keeps references to valid objects only, null pointers are removed on access/count attempt.
      However if you use access methods with pointer return, and try to access wrong index,
       you will get a null pointer, this means error index.
      There is a classic workaround for this: the TryGet method which writes the pointer and tells you
       if the returned pointer is valid, so if the method returns false, you shall not use the pointer.
   Hash methods return Mql internal object 'hash codes', as seen when you try to print an object/pointer.
      I'm not sure how these codes are generated, but they seem to be pretty reliable in identifying objects with ==.
Available operators:
   [index] Get,            eg. Class T* pointer=list[3];
   += Append,              eg. list+=pointer;   //list+=&object;
   ^= Prepend,             eg. list^=pointer;   //list+=&object;
   -= Remove,              eg. list-=pointer;   //list+=&object;
   /= Remove & delete,     eg. list/=pointer;   //list+=&object;
   ~ RemoveAll,            eg. ~list;
   = Copy list,            eg. Class listA=listB; //A-new,B-existing
/**/
```

```mql5
/****************************************************************
Example of ObjectList usage
/****************************************************************/
void OnStart()
  {
   ObjectList<A>list;
   A* o1=new B();             //dynamic
   A  o2;                     //automatic
   A* o3=&o2;                 //automatic
   /**/
   list+=&o2;                 //append object ref
   list^=o1;                  //prepend
   list+=o3;                  //append pointer
   list.PrintHash();          //see output
   /**/
     {string s; for(int i=0; i<13; i++) {s+="-";} Print(s);}
   /**/
   list-=&o2;                 //remove
   ObjectList<A>list2=list;   //copy list
   list2.PrintHash();         //see output
   /**/
     {string s; for(int i=0; i<13; i++) {s+="-";} Print(s);}
   /**/
   ~list;                     //clean list, this is empty now
   list2.RemoveLast();        //remove
   list2.PrintHash();         //see output
   /**/
     {string s; for(int i=0; i<13; i++) {s+="-";} Print(s);}
   /**/
   A* o=list2[0];                                        //direct access
   Print(list2.Hash(o));   //2097152     //   same...    //risky to use o without check, but if you sure
   Print(list2.Hash(0));   //2097152     //...object
   Print(list2.TryGet(o,666)); //false, don't use o      //safe access
   /**
   ...On destruction the list will delete the dynamic object o1 from memory.
   /**/
  }
/****************************************************************
Output:
/**
   0:2097152(A*)
   1:3145728(A*)
   2:3145728(A*)
   -------------
   0:2097152(A*)
   1:3145728(A*)
   -------------
   0:2097152(A*)
   -------------
   2097152
   2097152
   false
/**/
```

**[Go to discussion](/en/forum/344583)**

![M1MA indicator](https://c.mql5.com/i/code/indicator.png)
[M1MA indicator](/en/code/29673)

M1-based Moving Average. It gives more adequate estimation of average price per bar compared to any standard price type (close, open, median, typical, weighted, etc).

![Bar Time Count Down](https://c.mql5.com/i/code/indicator.png)
[Bar Time Count Down](/en/code/29647)

This MT5 indicator is to count down the remaining time of the current bar as the format HH:MM:SS

![Basic List](https://c.mql5.com/i/code/library.png)
[Basic List](/en/code/29780)

A basic container for storing an ordered list of basic data type objects.

![custom trail-stop by MA - update 4](https://c.mql5.com/i/code/expert.png)
[custom trail-stop by MA - update 4](/en/code/29797)

this is my first try at creating an EA from ground up - update 4