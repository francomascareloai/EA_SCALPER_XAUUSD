# MQL5 Book - Part 1 (Pages 1-200)

## Page 1

© 2000-2024, M etaQuotes Ltd

---

## Page 2

Contents
2
Contents
MQL5 Programming for Traders
13
..................................................................................................................................................................................................... 1 5
1
Part 1 . Introduction to MQL5 and development environment
......................................................................................................................................................................................1 6
1 .1  Editing, compiling, and running programs
......................................................................................................................................................................................1 9
1 .2 MQL Wizard and program draft
......................................................................................................................................................................................22
1 .3 Statements, code blocks, and functions
......................................................................................................................................................................................24
1 .4 First program
......................................................................................................................................................................................26
1 .5 Data types and values
......................................................................................................................................................................................28
1 .6 Variables and identifiers
......................................................................................................................................................................................29
1 .7 Assignment and initialization, expressions and arrays
......................................................................................................................................................................................31 
1 .8 Data input
......................................................................................................................................................................................33
1 .9 Error fixing and debugging
......................................................................................................................................................................................37
1 .1 0 Data output
......................................................................................................................................................................................39
1 .1 1  Formatting, indentation, and spaces
......................................................................................................................................................................................41 
1 .1 2 Mini summary
..................................................................................................................................................................................................... 42
2
Part 2. Programming fundamentals
......................................................................................................................................................................................43
2.1  Identifiers
......................................................................................................................................................................................44
2.2 Built-in data types
.............................................................................................................................................................................. 46
2.2.1  Integers
.............................................................................................................................................................................. 50
2.2.2 Floating-point numbers
.............................................................................................................................................................................. 53
2.2.3 Character types
.............................................................................................................................................................................. 54
2.2.4 String type
.............................................................................................................................................................................. 55
2.2.5 Logic (Boolean) type
.............................................................................................................................................................................. 56
2.2.6 Date and time
.............................................................................................................................................................................. 57
2.2.7 Color
.............................................................................................................................................................................. 58
2.2.8 Enumerations
.............................................................................................................................................................................. 61 
2.2.9 Custom enumerations
.............................................................................................................................................................................. 64
2.2.1 0 Void type
......................................................................................................................................................................................64
2.3 Variables
.............................................................................................................................................................................. 65
2.3.1  Declaration and definition of variables
.............................................................................................................................................................................. 66
2.3.2 Context, scope, and lifetime of variables
.............................................................................................................................................................................. 68
2.3.3 Initialization
.............................................................................................................................................................................. 74
2.3.4 Static variables
.............................................................................................................................................................................. 76
2.3.5 Constant variables
.............................................................................................................................................................................. 77
2.3.6 Input variables
.............................................................................................................................................................................. 78
2.3.7 External variables
......................................................................................................................................................................................81 
2.4 Arrays
.............................................................................................................................................................................. 82
2.4.1  Array characteristics
.............................................................................................................................................................................. 83
2.4.2 Description of arrays
.............................................................................................................................................................................. 85
2.4.3 Using arrays
......................................................................................................................................................................................88
2.5 Expressions
.............................................................................................................................................................................. 88
2.5.1  Basic concepts
.............................................................................................................................................................................. 90
2.5.2 Assignment operation
.............................................................................................................................................................................. 92
2.5.3 Arithmetic operations
.............................................................................................................................................................................. 94
2.5.4 Increment and decrement
.............................................................................................................................................................................. 95
2.5.5 Comparison operations
.............................................................................................................................................................................. 97
2.5.6 Logical operations
.............................................................................................................................................................................. 98
2.5.7 Bitwise operations
.............................................................................................................................................................................. 1 00
2.5.8 Modification operations
.............................................................................................................................................................................. 1 02
2.5.9 Conditional ternary operator
.............................................................................................................................................................................. 1 04
2.5.1 0 Comma
.............................................................................................................................................................................. 1 04
2.5.1 1  Special operators sizeof and typename

---

## Page 3

Contents
3
.............................................................................................................................................................................. 1 06
2.5.1 2 Grouping with parentheses
.............................................................................................................................................................................. 1 06
2.5.1 3 Priorities of operations
......................................................................................................................................................................................1 08
2.6 Type conversion
.............................................................................................................................................................................. 1 09
2.6.1 . Implicit type conversion
.............................................................................................................................................................................. 1 1 0
2.6.2. Arithmetic type conversions
.............................................................................................................................................................................. 1 1 2
2.6.3. Explicit type conversion
......................................................................................................................................................................................1 1 3
2.7 Statements
.............................................................................................................................................................................. 1 1 4
2.7.1  Compound statements (blocks of code)
.............................................................................................................................................................................. 1 1 4
2.7.2 Declaration/definition statements
.............................................................................................................................................................................. 1 1 8
2.7.3 Simple statements (expressions)
.............................................................................................................................................................................. 1 1 9
2.7.4 Overview of control statements
.............................................................................................................................................................................. 1 20
2.7.5 For loop
.............................................................................................................................................................................. 1 24
2.7.6 While loop
.............................................................................................................................................................................. 1 26
2.7.7 Do loop
.............................................................................................................................................................................. 1 26
2.7.8 If selection
.............................................................................................................................................................................. 1 29
2.7.9 Switch selection
.............................................................................................................................................................................. 1 32
2.7.1 0 Break jump
.............................................................................................................................................................................. 1 35
2.7.1 1  Continue jump
.............................................................................................................................................................................. 1 36
2.7.1 2 Return jump
.............................................................................................................................................................................. 1 36
2.7.1 3 Empty statement
......................................................................................................................................................................................1 37
2.8 Functions
.............................................................................................................................................................................. 1 38
2.8.1  Function definition
.............................................................................................................................................................................. 1 39
2.8.2 Function call
.............................................................................................................................................................................. 1 40
2.8.3 Parameters and arguments
.............................................................................................................................................................................. 1 41 
2.8.4 Value parameters and reference parameters
.............................................................................................................................................................................. 1 44
2.8.5 Optional parameters
.............................................................................................................................................................................. 1 45
2.8.6 Return values
.............................................................................................................................................................................. 1 46
2.8.7 Function declaration
.............................................................................................................................................................................. 1 47
2.8.8 Recursion
.............................................................................................................................................................................. 1 48
2.8.9 Function overloading
.............................................................................................................................................................................. 1 50
2.8.1 0 Function pointers (typedef)
.............................................................................................................................................................................. 1 53
2.8.1 1  Inlining
......................................................................................................................................................................................1 53
2.9 Preprocessor
.............................................................................................................................................................................. 1 54
2.9.1  Including source files (#include)
.............................................................................................................................................................................. 1 55
2.9.2 Overview of macro substitution directives
.............................................................................................................................................................................. 1 56
2.9.3 Simple form of #define
.............................................................................................................................................................................. 1 58
2.9.4 Form of #define as a pseudo-function
.............................................................................................................................................................................. 1 61 
2.9.5 Special operators '#' and '##' inside #define definitions
.............................................................................................................................................................................. 1 62
2.9.6 Cancelling macro substitution (#undef)
.............................................................................................................................................................................. 1 62
2.9.7 Predefined preprocessor constants
.............................................................................................................................................................................. 1 63
2.9.8 Conditional compilation (#ifdef/#ifndef/#else/#endif)
.............................................................................................................................................................................. 1 64
2.9.9 General program properties (#property)
..................................................................................................................................................................................................... 1 66
3
Part 3. Object Oriented Programming
......................................................................................................................................................................................1 66
3.1  Structures and unions
.............................................................................................................................................................................. 1 67
3.1 .1  Definition of structures
.............................................................................................................................................................................. 1 69
3.1 .2 Functions (methods) in structures
.............................................................................................................................................................................. 1 70
3.1 .3 Copying structures
.............................................................................................................................................................................. 1 71 
3.1 .4 Constructors and destructors
.............................................................................................................................................................................. 1 74
3.1 .5 Packing structures in memory and interacting with DLLs
.............................................................................................................................................................................. 1 75
3.1 .6 Structure layout and inheritance
.............................................................................................................................................................................. 1 77
3.1 .7 Access rights
.............................................................................................................................................................................. 1 78
3.1 .8 Unions
......................................................................................................................................................................................1 80
3.2 Classes and interfaces
.............................................................................................................................................................................. 1 80
3.2.1  OOP fundamentals: Abstraction
.............................................................................................................................................................................. 1 81 
3.2.2 OOP fundamentals: Encapsulation
.............................................................................................................................................................................. 1 82
3.2.3 OOP fundamentals: Inheritance

---

## Page 4

Contents
4
.............................................................................................................................................................................. 1 83
3.2.4 OOP fundamentals: Polymorphism
.............................................................................................................................................................................. 1 83
3.2.5 OOP fundamentals: Composition (design)
.............................................................................................................................................................................. 1 84
3.2.6 Class definition
.............................................................................................................................................................................. 1 87
3.2.7 Access rights
.............................................................................................................................................................................. 1 88
3.2.8 Constructors: default, parametric, and copying
.............................................................................................................................................................................. 1 94
3.2.9 Destructors
.............................................................................................................................................................................. 1 95
3.2.1 0 Self-reference: this
.............................................................................................................................................................................. 1 98
3.2.1 1  Inheritance
.............................................................................................................................................................................. 203
3.2.1 2 Dynamic creation of objects: new and delete
.............................................................................................................................................................................. 205
3.2.1 3 Pointers
.............................................................................................................................................................................. 21 1 
3.2.1 4 Virtual methods (virtual and override)
.............................................................................................................................................................................. 220
3.2.1 5 Static members
.............................................................................................................................................................................. 222
3.2.1 6 Nested types, namespaces, and the context operator '::'
.............................................................................................................................................................................. 226
3.2.1 7 Splitting class declaration and definition
.............................................................................................................................................................................. 229
3.2.1 8 Abstract classes and interfaces
.............................................................................................................................................................................. 231 
3.2.1 9 Operator overloading
.............................................................................................................................................................................. 242
3.2.20 Object type сasting: dynamic_cast and pointer void *
.............................................................................................................................................................................. 246
3.2.21  Pointers, references, and const
.............................................................................................................................................................................. 250
3.2.22 Inheritance management: final and delete
......................................................................................................................................................................................251 
3.3 Templates
.............................................................................................................................................................................. 252
3.3.1  Template header
.............................................................................................................................................................................. 253
3.3.2 General template operation principles
.............................................................................................................................................................................. 255
3.3.3 Templates vs preprocessor macros
.............................................................................................................................................................................. 256
3.3.4 Features of built-in and object types in templates
.............................................................................................................................................................................. 260
3.3.5 Function templates
.............................................................................................................................................................................. 265
3.3.6 Object type templates
.............................................................................................................................................................................. 270
3.3.7 Method templates
.............................................................................................................................................................................. 276
3.3.8 Nested templates
.............................................................................................................................................................................. 277
3.3.9 Absent template specialization
..................................................................................................................................................................................................... 281 
4
Part 4. Common APIs
......................................................................................................................................................................................281 
4.1  Built-in type conversions
.............................................................................................................................................................................. 282
4.1 .1  Numbers to strings and vice versa
.............................................................................................................................................................................. 286
4.1 .2 Normalization of doubles
.............................................................................................................................................................................. 287
4.1 .3 Date and time
.............................................................................................................................................................................. 296
4.1 .4 Color
.............................................................................................................................................................................. 299
4.1 .5 Structures
.............................................................................................................................................................................. 301 
4.1 .6 Enumerations
.............................................................................................................................................................................. 303
4.1 .7 Type complex
......................................................................................................................................................................................304
4.2 Working with strings and symbols
.............................................................................................................................................................................. 305
4.2.1  Initialization and measurement of strings
.............................................................................................................................................................................. 309
4.2.2 String concatenation
.............................................................................................................................................................................. 31 0
4.2.3 String comparison
.............................................................................................................................................................................. 31 6
4.2.4 Changing the character case and trimming spaces
.............................................................................................................................................................................. 31 8
4.2.5 Finding, replacing, and extracting string fragments
.............................................................................................................................................................................. 322
4.2.6 Working with symbols and code pages
.............................................................................................................................................................................. 329
4.2.7 Universal formatted data output to a string
......................................................................................................................................................................................335
4.3 Working with arrays
.............................................................................................................................................................................. 336
4.3.1  Logging arrays
.............................................................................................................................................................................. 339
4.3.2 Dynamic arrays
.............................................................................................................................................................................. 346
4.3.3 Array measurement
.............................................................................................................................................................................. 347
4.3.4 Initializing and populating arrays
.............................................................................................................................................................................. 349
4.3.5 Copying and editing arrays
.............................................................................................................................................................................. 361 
4.3.6 Moving (swapping) arrays
.............................................................................................................................................................................. 363
4.3.7 Comparing, sorting, and searching in arrays
.............................................................................................................................................................................. 378
4.3.8 Timeseries indexing direction in arrays
.............................................................................................................................................................................. 382
4.3.9 Zeroing objects and arrays

---

## Page 5

Contents
5
......................................................................................................................................................................................387
4.4 Mathematical functions
.............................................................................................................................................................................. 388
4.4.1  The absolute value of a number
.............................................................................................................................................................................. 390
4.4.2 Maximum and minimum of two numbers
.............................................................................................................................................................................. 390
4.4.3 Rounding functions
.............................................................................................................................................................................. 391 
4.4.4 Remainder after division (Modulo operation)
.............................................................................................................................................................................. 392
4.4.5 Powers and roots
.............................................................................................................................................................................. 392
4.4.6 Exponential and logarithmic functions
.............................................................................................................................................................................. 394
4.4.7 Trigonometric functions
.............................................................................................................................................................................. 397
4.4.8 Hyperbolic functions
.............................................................................................................................................................................. 398
4.4.9 Normality test for real numbers
.............................................................................................................................................................................. 401 
4.4.1 0 Random number generation
.............................................................................................................................................................................. 402
4.4.1 1  Endianness control in integers
......................................................................................................................................................................................404
4.5 Working with files
.............................................................................................................................................................................. 406
4.5.1  Information storage methods: text and binary
.............................................................................................................................................................................. 408
4.5.2 Writing and reading files in simplified mode
.............................................................................................................................................................................. 41 2
4.5.3 Opening and closing files
.............................................................................................................................................................................. 41 8
4.5.4 Managing file descriptors
.............................................................................................................................................................................. 425
4.5.5 Selecting an encoding for text mode
.............................................................................................................................................................................. 428
4.5.6 Writing and reading arrays
.............................................................................................................................................................................. 433
4.5.7 Writing and reading structures (binary files)
.............................................................................................................................................................................. 438
4.5.8 Writing and reading variables (binary files)
.............................................................................................................................................................................. 446
4.5.9 Writing and reading variables (text files)
.............................................................................................................................................................................. 455
4.5.1 0 Managing position in a file
.............................................................................................................................................................................. 461 
4.5.1 1  Getting file properties
.............................................................................................................................................................................. 465
4.5.1 2 Force write cache to disk
.............................................................................................................................................................................. 470
4.5.1 3 Deleting a file and checking if it exists
.............................................................................................................................................................................. 472
4.5.1 4 Copying and moving files
.............................................................................................................................................................................. 474
4.5.1 5 Searching for files and folders
.............................................................................................................................................................................. 476
4.5.1 6 Working with folders
.............................................................................................................................................................................. 478
4.5.1 7 File or folder selection dialog
......................................................................................................................................................................................482
4.6 Client terminal global variables
.............................................................................................................................................................................. 483
4.6.1  Writing and reading global variables
.............................................................................................................................................................................. 485
4.6.2 Checking the existence and last activity time
.............................................................................................................................................................................. 486
4.6.3 Getting a list of global variables
.............................................................................................................................................................................. 487
4.6.4 Deleting global variables
.............................................................................................................................................................................. 488
4.6.5 Temporary global variables
.............................................................................................................................................................................. 489
4.6.6 Synchronizing programs using global variables
.............................................................................................................................................................................. 499
4.6.7 Flushing global variables to disk
......................................................................................................................................................................................500
4.7 Functions for working with time
.............................................................................................................................................................................. 502
4.7.1  Local and server time
.............................................................................................................................................................................. 505
4.7.2 Daylight saving time (local)
.............................................................................................................................................................................. 51 1 
4.7.3 Universal Time
.............................................................................................................................................................................. 51 1 
4.7.4 Pausing a program
.............................................................................................................................................................................. 51 2
4.7.5 Time interval counters
......................................................................................................................................................................................51 3
4.8 User interaction
.............................................................................................................................................................................. 51 4
4.8.1  Logging messages
.............................................................................................................................................................................. 51 8
4.8.2 Alerts
.............................................................................................................................................................................. 51 9
4.8.3 Displaying messages in the chart window
.............................................................................................................................................................................. 523
4.8.4 Message dialog box
.............................................................................................................................................................................. 528
4.8.5 Sound alerts
......................................................................................................................................................................................529
4.9 MQL program execution environment
.............................................................................................................................................................................. 530
4.9.1  Getting a general list of terminal and program properties
.............................................................................................................................................................................. 534
4.9.2 Terminal build number
.............................................................................................................................................................................. 534
4.9.3 Program type and license
.............................................................................................................................................................................. 536
4.9.4 Terminal and program operating modes
.............................................................................................................................................................................. 538
4.9.5 Permissions

---

## Page 6

Contents
6
.............................................................................................................................................................................. 541 
4.9.6 Checking network connections
.............................................................................................................................................................................. 543
4.9.7 Computing resources: memory, disk, and CPU
.............................................................................................................................................................................. 544
4.9.8 Screen specifications
.............................................................................................................................................................................. 546
4.9.9 Terminal and program string properties
.............................................................................................................................................................................. 548
4.9.1 0 Custom properties: Bar limit and interface language
.............................................................................................................................................................................. 548
4.9.1 1  Binding a program to runtime properties
.............................................................................................................................................................................. 558
4.9.1 2 Checking keyboard status
.............................................................................................................................................................................. 560
4.9.1 3 Checking the MQL program status and reason for termination
.............................................................................................................................................................................. 562
4.9.1 4 Programmatically closing the terminal and setting a return code
.............................................................................................................................................................................. 564
4.9.1 5 Handling runtime errors
.............................................................................................................................................................................. 566
4.9.1 6 User-defined errors
.............................................................................................................................................................................. 571 
4.9.1 7 Debug management
.............................................................................................................................................................................. 571 
4.9.1 8 Predefined variables
.............................................................................................................................................................................. 572
4.9.1 9 Predefined constants of the MQL5 language
......................................................................................................................................................................................574
4.1 0 Matrices and vectors
.............................................................................................................................................................................. 574
4.1 0.1  Types of matrices and vectors
.............................................................................................................................................................................. 576
4.1 0.2 Creating and initializing matrices and vectors
.............................................................................................................................................................................. 579
4.1 0.3 Copying matrices, vectors, and arrays
.............................................................................................................................................................................. 581 
4.1 0.4 Copying timeseries to matrices and vectors
.............................................................................................................................................................................. 582
4.1 0.5 Copying tick history to matrices and vectors
.............................................................................................................................................................................. 583
4.1 0.6 Evaluation of expressions with matrices and vectors
.............................................................................................................................................................................. 584
4.1 0.7 Manipulating matrices and vectors
.............................................................................................................................................................................. 588
4.1 0.8 Products of matrices and vectors
.............................................................................................................................................................................. 590
4.1 0.9 Transformations (decomposition) of matrices
.............................................................................................................................................................................. 592
4.1 0.1 0 Obtaining statistics
.............................................................................................................................................................................. 593
4.1 0.1 1  Characteristics of matrices and vectors
.............................................................................................................................................................................. 595
4.1 0.1 2 Solving equations
.............................................................................................................................................................................. 601 
4.1 0.1 3 Machine learning methods
..................................................................................................................................................................................................... 61 1 
5
Part 5. Creating application programs
......................................................................................................................................................................................61 2
5.1  General principles for executing MQL programs
.............................................................................................................................................................................. 61 3
5.1 .1  Designing MQL programs of various types
.............................................................................................................................................................................. 61 6
5.1 .2 Threads
.............................................................................................................................................................................. 61 7
5.1 .3 Overview of event handling functions
.............................................................................................................................................................................. 623
5.1 .4 Features of starting and stopping programs of various types
.............................................................................................................................................................................. 626
5.1 .5 Reference events of indicators and Expert Advisors: OnInit and OnDeinit
.............................................................................................................................................................................. 628
5.1 .6 The main function of scripts and services: OnStart
.............................................................................................................................................................................. 629
5.1 .7 Programmatic removal of Expert Advisors and scripts: ExpertRemove
......................................................................................................................................................................................631 
5.2 Scripts and services
.............................................................................................................................................................................. 631 
5.2.1  Scripts
.............................................................................................................................................................................. 632
5.2.2 Services
.............................................................................................................................................................................. 636
5.2.3 Restrictions for scripts and services
......................................................................................................................................................................................637
5.3 Timeseries
.............................................................................................................................................................................. 639
5.3.1  Symbols and timeframes
.............................................................................................................................................................................. 642
5.3.2 Technical aspects of timeseries organization and storage
.............................................................................................................................................................................. 643
5.3.3 Getting characteristics of price arrays
.............................................................................................................................................................................. 645
5.3.4 Number of available bars (Bars/iBars)
.............................................................................................................................................................................. 645
5.3.5 Search bar index by time (iBarShift)
.............................................................................................................................................................................. 648
5.3.6 Overview of Copy functions for obtaining arrays of quotes
.............................................................................................................................................................................. 652
5.3.7 Getting quotes as an array of MqlRates structures
.............................................................................................................................................................................. 655
5.3.8 Separate request for arrays of prices, volumes, spreads, time
.............................................................................................................................................................................. 657
5.3.9 Reading price, volume, spread, and time by bar index
.............................................................................................................................................................................. 660
5.3.1 0 Finding the maximum and minimum values in a timeseries
.............................................................................................................................................................................. 664
5.3.1 1  Working with real tick arrays in MqlTick structures
......................................................................................................................................................................................675
5.4 Creating custom indicators
.............................................................................................................................................................................. 675
5.4.1  Main characteristics of indicators
.............................................................................................................................................................................. 676
5.4.2 Main indicator event: OnCalculate

---

## Page 7

Contents
7
.............................................................................................................................................................................. 680
5.4.3 Two types of indicators: for main window and subwindow
.............................................................................................................................................................................. 681 
5.4.4 Setting the number of buffers and graphic plots
.............................................................................................................................................................................. 682
5.4.5 Assigning an array as a buffer: SetIndexBuffer
.............................................................................................................................................................................. 685
5.4.6 Plot settings: PlotIndexSetInteger
.............................................................................................................................................................................. 691 
5.4.7 Buffer and chart mapping rules
.............................................................................................................................................................................. 695
5.4.8 Applying directives to customize plots
.............................................................................................................................................................................. 697
5.4.9 Setting plot names
.............................................................................................................................................................................. 698
5.4.1 0 Visualizing data gaps (empty elements)
.............................................................................................................................................................................. 704
5.4.1 1  Indicators in separate subwindows: sizes and levels
.............................................................................................................................................................................. 71 0
5.4.1 2 General properties of indicators: title and value accuracy
.............................................................................................................................................................................. 71 1 
5.4.1 3 Item-wise chart coloring
.............................................................................................................................................................................. 71 4
5.4.1 4 Skip drawing on initial bars
.............................................................................................................................................................................. 720
5.4.1 5 Waiting for data and managing visibility (DRAW_NONE)
.............................................................................................................................................................................. 732
5.4.1 6 Multicurrency and multitimeframe indicators
.............................................................................................................................................................................. 754
5.4.1 7 Tracking bar formation
.............................................................................................................................................................................. 757
5.4.1 8 Testing indicators
.............................................................................................................................................................................. 759
5.4.1 9 Limitations and advantages of indicators
.............................................................................................................................................................................. 760
5.4.20 Creating an indicator draft in the MQL Wizard
......................................................................................................................................................................................762
5.5 Using ready-made indicators from MQL programs
.............................................................................................................................................................................. 763
5.5.1  Handles and counters of indicator owners
.............................................................................................................................................................................. 765
5.5.2 A simple way to create indicator instances: iCustom
.............................................................................................................................................................................. 768
5.5.3 Checking the number of calculated bars: BarsCalculated
.............................................................................................................................................................................. 770
5.5.4 Getting timeseries data from an indicator: CopyBuffer
.............................................................................................................................................................................. 780
5.5.5 Support for multiple symbols and timeframes
.............................................................................................................................................................................. 786
5.5.6 Overview of built-in indicators
.............................................................................................................................................................................. 792
5.5.7 Using built-in indicators
.............................................................................................................................................................................. 801 
5.5.8 Advanced way to create indicators: IndicatorCreate
.............................................................................................................................................................................. 81 2
5.5.9 Flexible creation of indicators with IndicatorCreate
.............................................................................................................................................................................. 820
5.5.1 0 Overview of functions managing indicators on the chart
.............................................................................................................................................................................. 821 
5.5.1 1  Combining output to main and auxiliary windows
.............................................................................................................................................................................. 824
5.5.1 2 Reading data from charts that have a shift
.............................................................................................................................................................................. 827
5.5.1 3 Deleting indicator instances: IndicatorRelease
.............................................................................................................................................................................. 832
5.5.1 4 Getting indicator settings by its handle
.............................................................................................................................................................................. 835
5.5.1 5 Defining data source for an indicator
......................................................................................................................................................................................836
5.6 Working with timer
.............................................................................................................................................................................. 837
5.6.1  Turning timer on and off
.............................................................................................................................................................................. 838
5.6.2 Timer event: OnTimer
.............................................................................................................................................................................. 847
5.6.3 High-precision timer: EventSetMillisecondTimer
......................................................................................................................................................................................849
5.7 Working with charts
.............................................................................................................................................................................. 850
5.7.1  Functions for getting the basic properties of the current chart
.............................................................................................................................................................................. 851 
5.7.2 Chart identification
.............................................................................................................................................................................. 852
5.7.3 Getting the list of charts
.............................................................................................................................................................................. 853
5.7.4 Getting the symbol and timeframe of an arbitrary chart
.............................................................................................................................................................................. 854
5.7.5 Overview of functions for working with the complete set of properties
.............................................................................................................................................................................. 856
5.7.6 Descriptive chart properties
.............................................................................................................................................................................. 858
5.7.7 Checking the status of the main window
.............................................................................................................................................................................. 858
5.7.8 Getting the number and visibility of windows/subwindows
.............................................................................................................................................................................. 860
5.7.9 Chart display modes
.............................................................................................................................................................................. 868
5.7.1 0 Managing the visibility of chart elements
.............................................................................................................................................................................. 872
5.7.1 1  Horizontal shifts
.............................................................................................................................................................................. 873
5.7.1 2 Horizontal scale (by time)
.............................................................................................................................................................................. 875
5.7.1 3 Vertical scale (by price and indicator readings)
.............................................................................................................................................................................. 878
5.7.1 4 Colors
.............................................................................................................................................................................. 881 
5.7.1 5 Mouse and keyboard control
.............................................................................................................................................................................. 884
5.7.1 6 Undocking chart window
.............................................................................................................................................................................. 885
5.7.1 7 Getting MQL program drop coordinates on a chart

---

## Page 8

Contents
8
.............................................................................................................................................................................. 887
5.7.1 8 Translation of screen coordinates to time/price and vice versa
.............................................................................................................................................................................. 890
5.7.1 9 Scrolling charts along the time axis
.............................................................................................................................................................................. 893
5.7.20 Chart redraw request
.............................................................................................................................................................................. 894
5.7.21  Switching symbol and timeframe
.............................................................................................................................................................................. 894
5.7.22 Managing indicators on the chart
.............................................................................................................................................................................. 900
5.7.23 Opening and closing charts
.............................................................................................................................................................................. 903
5.7.24 Working with tpl chart templates
.............................................................................................................................................................................. 91 8
5.7.25 Saving a chart image
......................................................................................................................................................................................921 
5.8 Graphical objects
.............................................................................................................................................................................. 922
5.8.1  Object types and features of specifying their coordinates
.............................................................................................................................................................................. 923
5.8.2 Time and price bound objects
.............................................................................................................................................................................. 925
5.8.3 Objects bound to screen coordinates
.............................................................................................................................................................................. 925
5.8.4 Creating objects
.............................................................................................................................................................................. 928
5.8.5 Deleting objects
.............................................................................................................................................................................. 930
5.8.6 Finding objects
.............................................................................................................................................................................. 934
5.8.7 Overview of object property access functions
.............................................................................................................................................................................. 952
5.8.8 Main object properties
.............................................................................................................................................................................. 953
5.8.9 Price and time coordinates
.............................................................................................................................................................................. 956
5.8.1 0 Anchor window corner and screen coordinates
.............................................................................................................................................................................. 960
5.8.1 1  Defining anchor point on the object
.............................................................................................................................................................................. 962
5.8.1 2 Managing the object state
.............................................................................................................................................................................. 963
5.8.1 3 Priority of objects (Z-Order)
.............................................................................................................................................................................. 966
5.8.1 4 Object display settings: color, style, and frame
.............................................................................................................................................................................. 979
5.8.1 5 Font settings
.............................................................................................................................................................................. 982
5.8.1 6 Rotating text at an arbitrary angle
.............................................................................................................................................................................. 984
5.8.1 7 Determining object width and height
.............................................................................................................................................................................. 991 
5.8.1 8 Visibility of objects in the context of timeframes
.............................................................................................................................................................................. 994
5.8.1 9 Assigning a character code to a label
.............................................................................................................................................................................. 995
5.8.20 Ray properties for objects with straight lines
.............................................................................................................................................................................. 998
5.8.21  Managing object pressed state
.............................................................................................................................................................................. 1 000
5.8.22 Adjusting images in bitmap objects
.............................................................................................................................................................................. 1 001 
5.8.23 Cropping (outputting part) of an image
.............................................................................................................................................................................. 1 004
5.8.24 Input field properties: alignment and read-only
.............................................................................................................................................................................. 1 006
5.8.25 Standard deviation channel width
.............................................................................................................................................................................. 1 006
5.8.26 Setting levels in level objects
.............................................................................................................................................................................. 1 01 0
5.8.27 Additional properties of Gann, Fibonacci, and Elliot objects
.............................................................................................................................................................................. 1 01 1 
5.8.28 Chart object
.............................................................................................................................................................................. 1 01 5
5.8.29 Moving objects
.............................................................................................................................................................................. 1 01 6
5.8.30 Getting time or price at the specified line points
......................................................................................................................................................................................1 020
5.9 Interactive events on charts
.............................................................................................................................................................................. 1 021 
5.9.1  Event handling function OnChartEvent
.............................................................................................................................................................................. 1 023
5.9.2 Event-related chart properties
.............................................................................................................................................................................. 1 025
5.9.3 Chart change event
.............................................................................................................................................................................. 1 027
5.9.4 Keyboard events
.............................................................................................................................................................................. 1 036
5.9.5 Mouse events
.............................................................................................................................................................................. 1 039
5.9.6 Graphical object events
.............................................................................................................................................................................. 1 043
5.9.7 Generation of custom events
..................................................................................................................................................................................................... 1 049
6
Part 6. Trading automation
......................................................................................................................................................................................1 049
6.1  Financial instruments and Market Watch
.............................................................................................................................................................................. 1 050
6.1 .1  Getting available symbols and Market Watch lists
.............................................................................................................................................................................. 1 051 
6.1 .2 Editing the Market Watch list
.............................................................................................................................................................................. 1 054
6.1 .3 Checking if a symbol exists
.............................................................................................................................................................................. 1 055
6.1 .4 Checking the symbol data relevance
.............................................................................................................................................................................. 1 057
6.1 .5 Getting the last tick of a symbol
.............................................................................................................................................................................. 1 061 
6.1 .6 Schedules of trading and quoting sessions
.............................................................................................................................................................................. 1 066
6.1 .7 Symbol margin rates

---

## Page 9

Contents
9
.............................................................................................................................................................................. 1 067
6.1 .8 Overview of functions for getting symbol properties
.............................................................................................................................................................................. 1 076
6.1 .9 Checking symbol status
.............................................................................................................................................................................. 1 077
6.1 .1 0 Price type for building symbol charts
.............................................................................................................................................................................. 1 083
6.1 .1 1  Base, quote, and margin currencies of the instrument
.............................................................................................................................................................................. 1 090
6.1 .1 2 Price representation accuracy and change steps
.............................................................................................................................................................................. 1 093
6.1 .1 3 Permitted volumes of trading operations
.............................................................................................................................................................................. 1 096
6.1 .1 4 Trading permission
.............................................................................................................................................................................. 1 1 00
6.1 .1 5 Symbol trading conditions and order execution modes
.............................................................................................................................................................................. 1 1 04
6.1 .1 6 Margin requirements
.............................................................................................................................................................................. 1 1 1 2
6.1 .1 7 Pending order expiration rules
.............................................................................................................................................................................. 1 1 1 7
6.1 .1 8 Spreads and order distance from the current price
.............................................................................................................................................................................. 1 1 21 
6.1 .1 9 Getting swap sizes
.............................................................................................................................................................................. 1 1 26
6.1 .20 Current market information (tick)
.............................................................................................................................................................................. 1 1 28
6.1 .21  Descriptive symbol properties
.............................................................................................................................................................................. 1 1 31 
6.1 .22 Depth of Market
.............................................................................................................................................................................. 1 1 33
6.1 .23 Custom symbol properties
.............................................................................................................................................................................. 1 1 34
6.1 .24 Specific properties (stock exchange, derivatives, bonds)
......................................................................................................................................................................................1 1 35
6.2 Depth of Market
.............................................................................................................................................................................. 1 1 36
6.2.1  Managing subscriptions to Depth of Market events
.............................................................................................................................................................................. 1 1 38
6.2.2 Receiving events about changes in the Depth of Market
.............................................................................................................................................................................. 1 1 40
6.2.3 Reading the current Depth of Market data
.............................................................................................................................................................................. 1 1 47
6.2.4 Using Depth of Market data in applied algorithms
......................................................................................................................................................................................1 1 55
6.3 Trading account information
.............................................................................................................................................................................. 1 1 56
6.3.1  Overview of functions for getting account properties
.............................................................................................................................................................................. 1 1 59
6.3.2 Identifying the account, client, server, and broker
.............................................................................................................................................................................. 1 1 60
6.3.3 Account type: real, demo or contest
.............................................................................................................................................................................. 1 1 61 
6.3.4 Account currency
.............................................................................................................................................................................. 1 1 61 
6.3.5 Account type: netting or hedging
.............................................................................................................................................................................. 1 1 62
6.3.6 Restrictions and permissions for account operations
.............................................................................................................................................................................. 1 1 65
6.3.7 Account margin settings
.............................................................................................................................................................................. 1 1 68
6.3.8 Current financial performance of the account
......................................................................................................................................................................................1 1 69
6.4 Creating Expert Advisors
.............................................................................................................................................................................. 1 1 70
6.4.1  Expert Advisors main event: OnTick
.............................................................................................................................................................................. 1 1 72
6.4.2 Basic principles and concepts: order, deal, and position
.............................................................................................................................................................................. 1 1 73
6.4.3 Types of trading operations
.............................................................................................................................................................................. 1 1 74
6.4.4 Order types
.............................................................................................................................................................................. 1 1 76
6.4.5 Order execution modes by price and volume
.............................................................................................................................................................................. 1 1 77
6.4.6 Pending order expiration dates
.............................................................................................................................................................................. 1 1 78
6.4.7 Margin calculation for a future order: OrderCalcMargin
.............................................................................................................................................................................. 1 1 90
6.4.8 Estimating the profit of a trading operation: OrderCalcProfit
.............................................................................................................................................................................. 1 1 96
6.4.9 MqlTradeRequest structure
.............................................................................................................................................................................. 1 1 99
6.4.1 0 MqlTradeCheckResult structure
.............................................................................................................................................................................. 1 201 
6.4.1 1  Request validation: OrderCheck
.............................................................................................................................................................................. 1 206
6.4.1 2 Request sending result: MqlTradeResult structure
.............................................................................................................................................................................. 1 207
6.4.1 3 Sending a trade request: OrderSend and OrderSendAsync
.............................................................................................................................................................................. 1 21 4
6.4.1 4 Buying and selling operations
.............................................................................................................................................................................. 1 229
6.4.1 5 Modying Stop Loss and/or Take Profit levels of a position
.............................................................................................................................................................................. 1 236
6.4.1 6 Trailing stop
.............................................................................................................................................................................. 1 247
6.4.1 7 Closing a position: full and partial
.............................................................................................................................................................................. 1 256
6.4.1 8 Closing opposite positions: fill and partial
.............................................................................................................................................................................. 1 265
6.4.1 9 Placing a pending order
.............................................................................................................................................................................. 1 276
6.4.20 Modifying a pending order
.............................................................................................................................................................................. 1 287
6.4.21  Deleting a pending order
.............................................................................................................................................................................. 1 290
6.4.22 Getting a list of active orders
.............................................................................................................................................................................. 1 292
6.4.23 Order properties (active and historical)
.............................................................................................................................................................................. 1 296
6.4.24 Functions for reading properties of active orders

---

## Page 10

Contents
10
.............................................................................................................................................................................. 1 304
6.4.25 Selecting orders by properties
.............................................................................................................................................................................. 1 321 
6.4.26 Getting the list of positions
.............................................................................................................................................................................. 1 323
6.4.27 Position properties
.............................................................................................................................................................................. 1 325
6.4.28 Functions for reading position properties
.............................................................................................................................................................................. 1 335
6.4.29 Deal properties
.............................................................................................................................................................................. 1 339
6.4.30 Selecting orders and deals from history
.............................................................................................................................................................................. 1 341 
6.4.31  Functions for reading order properties from history
.............................................................................................................................................................................. 1 344
6.4.32 Functions for reading deal properties from history
.............................................................................................................................................................................. 1 356
6.4.33 Types of trading transactions
.............................................................................................................................................................................. 1 359
6.4.34 OnTradeTransaction event
.............................................................................................................................................................................. 1 378
6.4.35 Synchronous and asynchronous requests
.............................................................................................................................................................................. 1 391 
6.4.36 OnTrade event
.............................................................................................................................................................................. 1 399
6.4.37 Monitoring trading environment changes
.............................................................................................................................................................................. 1 429
6.4.38 Creating multi-symbol Expert Advisors
.............................................................................................................................................................................. 1 444
6.4.39 Limitations and benefits of Expert Advisors
.............................................................................................................................................................................. 1 445
6.4.40 Creating Expert Advisors in the MQL Wizard
......................................................................................................................................................................................1 449
6.5 Testing and optimization of Expert Advisors
.............................................................................................................................................................................. 1 450
6.5.1  Generating ticks in tester
.............................................................................................................................................................................. 1 458
6.5.2 Time management in the tester: timer, Sleep, GMT
.............................................................................................................................................................................. 1 459
6.5.3 Testing visualization: chart, objects, indicators
.............................................................................................................................................................................. 1 460
6.5.4 Multicurrency testing
.............................................................................................................................................................................. 1 465
6.5.5 Optimization criteria
.............................................................................................................................................................................. 1 466
6.5.6 Getting testing financial statistics: TesterStatistics
.............................................................................................................................................................................. 1 478
6.5.7 OnTester event
.............................................................................................................................................................................. 1 489
6.5.8 Auto-tuning: ParameterGetRange and ParameterSetRange
.............................................................................................................................................................................. 1 496
6.5.9 Group of OnTester events for optimization control
.............................................................................................................................................................................. 1 497
6.5.1 0 Sending data frames from agents to the terminal
.............................................................................................................................................................................. 1 498
6.5.1 1  Getting data frames in terminal
.............................................................................................................................................................................. 1 506
6.5.1 2 Preprocessor directives for the tester
.............................................................................................................................................................................. 1 51 0
6.5.1 3 Managing indicator visibility: TesterHideIndicators
.............................................................................................................................................................................. 1 51 1 
6.5.1 4 Emulation of deposits and withdrawals
.............................................................................................................................................................................. 1 51 5
6.5.1 5 Forced test stop: TesterStop
.............................................................................................................................................................................. 1 51 5
6.5.1 6 Big Expert Advisor example
.............................................................................................................................................................................. 1 558
6.5.1 7 Mathematical calculations
.............................................................................................................................................................................. 1 560
6.5.1 8 Debugging and profiling
.............................................................................................................................................................................. 1 561 
6.5.1 9 Limitations of functions in the tester
..................................................................................................................................................................................................... 1 562
7
Part 7. Advanced language tools
......................................................................................................................................................................................1 562
7.1  Resources
.............................................................................................................................................................................. 1 563
7.1 .1  Describing resources using the #resource directive
.............................................................................................................................................................................. 1 564
7.1 .2 Shared use of resources of different MQL programs
.............................................................................................................................................................................. 1 565
7.1 .3 Resource variables
.............................................................................................................................................................................. 1 569
7.1 .4 Connecting custom indicators as resources
.............................................................................................................................................................................. 1 576
7.1 .5 Dynamic resource creation: ResourceCreate
.............................................................................................................................................................................. 1 581 
7.1 .6 Deleting dynamic resources: ResourceFree
.............................................................................................................................................................................. 1 581 
7.1 .7 Reading and modifying resource data: ResourceReadImage
.............................................................................................................................................................................. 1 592
7.1 .8 Saving images to a file: ResourceSave
.............................................................................................................................................................................. 1 603
7.1 .9 Fonts and text output to graphic resources
.............................................................................................................................................................................. 1 61 6
7.1 .1 0 Application of graphic resources in trading
......................................................................................................................................................................................1 624
7.2 Custom symbols
.............................................................................................................................................................................. 1 625
7.2.1  Creating and deleting custom symbols
.............................................................................................................................................................................. 1 628
7.2.2 Custom symbol properties
.............................................................................................................................................................................. 1 629
7.2.3 Setting margin rates
.............................................................................................................................................................................. 1 630
7.2.4 Configuring quoting and trading sessions
.............................................................................................................................................................................. 1 630
7.2.5 Adding, replacing, and deleting quotes
.............................................................................................................................................................................. 1 639
7.2.6 Adding, replacing, and removing ticks
.............................................................................................................................................................................. 1 666
7.2.7 Translation of order book changes

---

## Page 11

Contents
11
.............................................................................................................................................................................. 1 672
7.2.8 Custom symbol trading specifics
......................................................................................................................................................................................1 689
7.3 Economic calendar
.............................................................................................................................................................................. 1 689
7.3.1  Basic concepts of the calendar
.............................................................................................................................................................................. 1 696
7.3.2 Getting the list and descriptions of available countries
.............................................................................................................................................................................. 1 698
7.3.3 Querying event types by country and currency
.............................................................................................................................................................................. 1 702
7.3.4 Getting event descriptions by ID
.............................................................................................................................................................................. 1 702
7.3.5 Getting event records by country or currency
.............................................................................................................................................................................. 1 706
7.3.6 Getting event records of a specific type
.............................................................................................................................................................................. 1 709
7.3.7 Reading event records by ID
.............................................................................................................................................................................. 1 71 3
7.3.8 Tracking event changes by country or currency
.............................................................................................................................................................................. 1 723
7.3.9 Tracking event changes by type
.............................................................................................................................................................................. 1 723
7.3.1 0 Filtering events by multiple conditions
.............................................................................................................................................................................. 1 742
7.3.1 1  Transferring calendar database to tester
.............................................................................................................................................................................. 1 765
7.3.1 2 Calendar trading
......................................................................................................................................................................................1 774
7.4 Cryptography
.............................................................................................................................................................................. 1 775
7.4.1  Overview of available information transformation methods
.............................................................................................................................................................................. 1 778
7.4.2 Encryption, hashing, and data packaging: CryptEncode
.............................................................................................................................................................................. 1 789
7.4.3 Data decryption and decompression: CryptDecode
......................................................................................................................................................................................1 795
7.5 Network functions
.............................................................................................................................................................................. 1 796
7.5.1  Sending push notifications
.............................................................................................................................................................................. 1 797
7.5.2 Sending email notifications
.............................................................................................................................................................................. 1 797
7.5.3 Sending files to an FTP server
.............................................................................................................................................................................. 1 798
7.5.4 Data exchange with a web server via HTTP/HTTPS
.............................................................................................................................................................................. 1 81 8
7.5.5 Establishing and breaking a network socket connection
.............................................................................................................................................................................. 1 81 9
7.5.6 Checking socket status
.............................................................................................................................................................................. 1 821 
7.5.7 Setting data send and receive timeouts for sockets
.............................................................................................................................................................................. 1 822
7.5.8 Reading and writing data over an insecure socket connection
.............................................................................................................................................................................. 1 827
7.5.9 Preparing a secure socket connection
.............................................................................................................................................................................. 1 828
7.5.1 0 Reading and writing data over a secure socket connection
......................................................................................................................................................................................1 839
7.6 SQLite database
.............................................................................................................................................................................. 1 841 
7.6.0 Principles of database operations in MQL5
.............................................................................................................................................................................. 1 845
7.6.1  SQL Basics
.............................................................................................................................................................................. 1 849
7.6.2 Structure of tables: data types and restrictions
.............................................................................................................................................................................. 1 852
7.6.3 OOP (MQL5) and SQL integration: ORM concept
.............................................................................................................................................................................. 1 854
7.6.4 Creating, opening, and closing databases
.............................................................................................................................................................................. 1 856
7.6.5 Executing queries without MQL5 data binding
.............................................................................................................................................................................. 1 865
7.6.6 Checking if a table exists in the database
.............................................................................................................................................................................. 1 866
7.6.7 Preparing bound queries: DatabasePrepare
.............................................................................................................................................................................. 1 868
7.6.8 Deleting and resetting prepared queries
.............................................................................................................................................................................. 1 870
7.6.9 Binding data to query parameters: DatabaseBind/Array
.............................................................................................................................................................................. 1 872
7.6.1 0 Executing prepared queries: DatabaseRead/Bind
.............................................................................................................................................................................. 1 874
7.6.1 1  Reading fields separately: DatabaseColumn Functions
.............................................................................................................................................................................. 1 875
7.6.1 2 Examples of CRUD operations in SQLite via ORM objects
.............................................................................................................................................................................. 1 893
7.6.1 3 Transactions
.............................................................................................................................................................................. 1 897
7.6.1 4 Import and export of database tables
.............................................................................................................................................................................. 1 898
7.6.1 5 Printing tables and SQL queries to logs
.............................................................................................................................................................................. 1 899
7.6.1 6 Example of searching for a trading strategy using SQLite
......................................................................................................................................................................................1 91 0
7.7 Development and connection of binary format libraries
.............................................................................................................................................................................. 1 91 1 
7.7.1  Creation of ex5 libraries; export of functions
.............................................................................................................................................................................. 1 91 5
7.7.2 Including libraries; #import of functions
.............................................................................................................................................................................. 1 921 
7.7.3 Library file search order
.............................................................................................................................................................................. 1 921 
7.7.4 DLL connection specifics
.............................................................................................................................................................................. 1 926
7.7.5 Classes and templates in MQL5 libraries
.............................................................................................................................................................................. 1 940
7.7.6 Importing functions from .NET libraries
......................................................................................................................................................................................1 940
7.8 Projects
.............................................................................................................................................................................. 1 942
7.8.1  General rules for working with local projects

---

## Page 12

Contents
12
.............................................................................................................................................................................. 1 945
7.8.2 Project plan of a web service for copying trades and signals
.............................................................................................................................................................................. 1 946
7.8.3 Nodejs based web server
.............................................................................................................................................................................. 1 948
7.8.4 Theoretical foundations of the WebSockets protocol
.............................................................................................................................................................................. 1 949
7.8.5 Server component of web services based on the WebSocket protocol
.............................................................................................................................................................................. 1 958
7.8.6 WebSocket protocol in MQL5
.............................................................................................................................................................................. 1 968
7.8.7 Client programs for echo and chat services in MQL5
.............................................................................................................................................................................. 1 977
7.8.8 Trading signal service and test web page
.............................................................................................................................................................................. 1 982
7.8.9 Signal service client program in MQL5
......................................................................................................................................................................................1 998
7.9 Native python support
.............................................................................................................................................................................. 1 998
7.9.1  Installing Python and the MetaTrader5 package
.............................................................................................................................................................................. 2001 
7.9.2 Overview of functions of the MetaTrader5 package for Python
.............................................................................................................................................................................. 2003
7.9.3 Connecting a Python script to the terminal and account
.............................................................................................................................................................................. 2004
7.9.4 Error checking: last_error
.............................................................................................................................................................................. 2005
7.9.5 Getting information about a trading account
.............................................................................................................................................................................. 2007
7.9.6 Getting information about the terminal
.............................................................................................................................................................................. 2009
7.9.7 Getting information about financial instruments
.............................................................................................................................................................................. 201 3
7.9.8 Subscribing to order book changes
.............................................................................................................................................................................. 201 5
7.9.9 Reading quotes
.............................................................................................................................................................................. 2020
7.9.1 0 Reading tick history
.............................................................................................................................................................................. 2023
7.9.1 1  Calculating margin requirements and evaluating profits
.............................................................................................................................................................................. 2024
7.9.1 2 Checking and sending a trade order
.............................................................................................................................................................................. 2029
7.9.1 3 Getting the number and list of active orders
.............................................................................................................................................................................. 2032
7.9.1 4 Getting the number and list of open positions
.............................................................................................................................................................................. 2034
7.9.1 5 Reading the history of orders and deals
......................................................................................................................................................................................2038
7.1 0 Built-in support for parallel computing: OpenCL
..................................................................................................................................................................................................... 2046
8
Conclusion

---

## Page 13

 
1 3
 
MQL5 Programming for Traders
Modern trading relies heavily on computer technology. Automation now extends beyond the boundaries
of exchanges and brokerage offices, becoming accessible to everyday users through specialized
software solutions. Among the pioneers in this field stands MetaTrader, which emerged in the early
2000s. The latest platform version, MetaTrader 5, remains at the forefront, continuously evolving with
innovative features and functionalities.
A key element continuously refined within MetaTrader 5 is its built-in programming language MQL5. It
enables traders to ascend to a whole new level of trading automation, commonly referred to as
Algorithmic Trading. With MQL5, traders can transform their strategies into applications by writing their
own indicators for analysis, scripts for executing operations, or Expert Advisor for complete trading
automation. Being an automated trading system, an Expert Advisor can operate autonomously, tracking
price changes and promptly alerting traders via email or SMS.
The built-in programming language allows traders to implement virtually any trading concept, from
simple strategies to complex algorithms based on neural networks. MQL5 seamlessly combines the
features of domain-specific and universal programming languages. Over the years, the language has
acquired valuable advancements, such as support for 3D graphics, parallel computations via OpenCL,
Python integration, and SQLite database support.
To unlock the full potential of MetaTrader 5, you must delve into programming. This book will help you
master MQL5 and learn how to create your own trading applications.
It is assumed that the reader is already familiar with MetaTrader 5. Another prerequisite is the
understanding of the fundamental principles of terminal operation within a distributed information
system that facilitates trading. The terminal Help provides detailed information on all available features.
Furthermore, using MQL5 API, traders can access capabilities far beyond the MetaTrader 5 GUI.
Master the programming language to implement complex scenarios, automating various terminal
operation aspects and enhancing trading strategy efficiency.
The book is divided into 7 parts, each focusing on different aspects of MQL5 programming.
• Part 1  introduces basic MQL5 programming principles and MetaEditor, the standard MQL5
framework. Users experienced in programming in other languages should note the features of the
framework.
• Part 2 explains the basic terms, such as types, instructions, operators, expressions, variables, code
blocks, program structures. It describes how these terms are utilized in MQL5 procedural
programming style. Those users who know MQL4 well can skip this part and start reading Part 3.
• Part 3 deals with object oriented programming (OOP) in MQL5. Despite its similarity to other
languages that support the OOP paradigm (especially to C++), MQL5 has certain specific features.
To taste, MQL5 is sort of C±±.
• Part 4 describes common embedded functions which are applicable to in any program.
• Part 5 covers the architectural features of MQL programs and their "majoring" in types to perform
various trading tasks, such as technical analysis using indicators, chart management and marking
the charts with imposing graphical objects onto them, and responses to interactive actions and
events involving MQL programs.
• Part 6 explains how to analyze trading environment and automate trading operations using robots.
This part also presents the program interaction with tester in various modes, including strategy
optimization.

---

## Page 14

 
1 4
 
• Part 7 contains information regarding the extended set of dedicated APIs facilitating the MQL5
integration with adjacent technologies, such as databases, network data exchange, OpenCL,
Python, etc.
Throughout the book, the material is presented in a balanced manner, combining common approaches,
examples, and technical details. The reader is guided through transitioning from one concept to
another, resembling a chicken-and-egg problem inherent in learning programming. To reinforce
understanding, most MQL programs discussed in the book are available as source codes for practical
exploration in MetaEditor/MetaTrader 5.

---

## Page 15

Part 1 . Introduction to MQL5 and development environment
1 5
 
Part 1 . Introduction to MQL5 and development environment
One of the most important changes in MQL5 in its reincarnation in MetaTrader 5 is that it supports the
object-oriented programming (OOP) concept. At the time of its appearance, the preceding MQL4 (the
language of MetaTrader 4) was conventionally compared to the C programming language, while it is
more reasonable to liken MQL5 to C++. In all fairness, it should be noted that today all OOP tools that
initially had only been available in MQL5 were transferred into MQL4. However, users who scarcely
know programming still perceive OOP as something too complicated.
In a sense, this book is aiming at making complex things simple. It is not to replace, but to be added to
the MQL5 Language Reference that is supplied with the terminal and also available on the mql5.com
website.
In this book, we are going to consistently tell you about all the components and techniques of
programming in MQL5, taking baby steps so that each iteration is clear and the OOP technology
gradually unlocks its potential that is especially notable, as with any powerful tool, when it is used
properly and reasonably. As a result, the developers of MQL programs will be able to choose a preferred
programming style suitable for a specific task, i.e., not only the object-oriented but also the 'old'
procedural one, as well as use various combinations of them.
Users of the trading terminal can be conveniently classified into "programmers" (those who have
already some experience in programming in at least one language) and "non-programmers" ("pure"
traders interested in the customization capacity of the terminal using MQL5). The former ones can
optionally skip the first and the second parts of this book describing the basic concepts of language and
immediately start learning about the specific APIs (Application Programming Interfaces) embedded in
MetaTrader 5. For the latter ones, progressive reading is recommended.
Among the category of "programmers," those knowing C++ have the best advantages, since MQL5 and
C++ are similar. However, this "medal" has its reverse side. The matter is that MQL5 does not
completely match with C++ (especially when compared to the recent standards). Therefore, attempts
to write one structure or another through habit "as on pluses" will frequently be interrupted by
unexpected errors of the compiler. Considering specific elements of the language, we will do our best to
point out these differences.
Technical analysis, executing trading orders, or integration with external data sources – all these
functions are available to the terminal users both from the user interface and via software tools
embedded in MQL5.
Since MQL5 programs must perform different functions, there are some specialized program types
supported in MetaTrader 5. This is a standard technique in many software systems. For example, in
Windows, along with usual windowing programs, there are command-line-driven programs and services.
The following program types are available in MQL5:
• Indicators – programs aimed at graphically displaying data arrays computed by a given formula,
normally based on the series of quotes;
• Expert Advisors – programs to automate trading completely or partly;
• Scripts – programs intended for performing one action at a time; and
• Services – programs for performing permanent background actions.
We will discuss the purposes and special features of each type in detail later. It is important to note
now that they all are created in MQL5 and have much in common. Therefore, we will start learning with
common features and gradually get to know about the specificity of each type.

---

## Page 16

Part 1 . Introduction to MQL5 and development environment
1 6
 
The essential technical feature of MetaTrader consists in exerting the entire control in the client
terminal, while commands initiated in it are sent to the server. In other words, MQL-based applications
can only work within the client terminal, most of them requiring a 'live' connection to the server to
function properly. No applications are installed on the server. The server just processes the orders
received from the client terminal and returns the changes in the trading environment. These changes
also become available to MQL5 programs.
Most types of MQL5 programs are executed in the chart context, i.e., to launch a program, you should
'throw' it onto the desired chart. The exception is only a special type, i.e., services: They are intended
for background operation, without being attached to the chart.
We recall that all MQL5 programs are inside the working MetaTrader 5 folder, in the nested folder
named /MQL5/<type>, where <type> is, respectively:
• Indicators
• Experts
• Scripts
• Services
Based on the MetaTrader 5 installation technique, the path to the working folder can be different
(particularly, with the limited user rights in Windows, in a normal mode or portable). For example, it can
be:
C:/Program Files/MetaTrader 5/
or
C:/Users/<username>/AppData/Roaming/MetaQuotes/Terminal/<instance_id>/
The user can get to know where this folder is located exactly by executing the File -> Open data catalog
command (it is available in both terminal and editor). Moreover, when creating a new program, you
don't need to think of looking up the correct folder due to using the MQL Wizard embedded in the
editor. It is called for by the File -> New command and allows selecting the required type of the MQL5
program. The relevant text file containing a source code template will be created automatically where
necessary upon completing the Master and then opened for editing.
In the MQL5 folder, there are other nested folders, along with the above ones, and they are also
directly related to MQL5 programming, but we will refer to them later.
MQL5 Programming for Traders – Source Codes from the Book. Part 1 
Examples from the book are also available in the public project \MQL5\Shared Projects\MQL5Book
1 .1  Editing, compiling, and running programs
All MetaTrader 5 programs are compilable. That is, a source code written in MQL5 must be compiled to
obtain the binary representation that will be exactly the one executed in the terminal.
Programs are edited and compiled using MetaEditor.

---

## Page 17

Part 1 . Introduction to MQL5 and development environment
1 7
1 .1  Editing, compiling, and running programs
Editing an MQL program in MetaEditor
Source code is a text written according to the MQL5 rules and saved as a file having the extension of
mq5. The file containing a compiled program will have the same name, while its extension will be ex5.
In the simplest case, one executable file corresponds with one file containing the source code; however,
as we will see later, coding complex programs frequently requires splitting the source code into multiple
files: The main one and some supporting ones that are enabled from the main file in a special manner.
In this case, the main file must still have the extension of mq5, while those enabled from it must have
the extension of mqh. Then statements from all source files will get into the executable file being
generated. Thus, multiple files containing the source code may be the starting point for creating one
executable file/program. All this mentioned here to complete the picture is going to be presented in the
second part of the book.
We will use the term MQL5 syntax to denote the set of all rules that allow constructing programs in
MQL5. Only the strict adherence to the syntax allows coding programs compatible with the compiler. In
fact, teaching to code consists of sequentially introducing all the rules of a particular language that is
MQL5, in our case. And this is the main purpose of this book.
To compile a source code, we can use the command MetaEditor File -> Compile or just press F7.
However, there are some other, special methods to compile — we will discuss them later. Compiling is
accompanied by displaying the changing status in the editor log (where an MQL5 program consists of
multiple files containing the source code, and enabling each file is marked in a single log line).

---

## Page 18

Part 1 . Introduction to MQL5 and development environment
1 8
1 .1  Editing, compiling, and running programs
Compiling an MQL5 program in MetaEditor
An indication of a successful compilation is zero errors ("0 errors"). Warnings do not affect the
compilation results, they just inform on potential issues. Therefore, it is recommended to fix them on
the same basis as errors (we will tell you later how to do that). Ideally, there should not be any
warnings ("0 warnings").
Upon the successful compilation of an mq5 file, we get a same-name file with the extension of ex5.
MetaTrader 5 Navigator displays as a tree all executable ex5 files located in folder MQL5 and its
subfolders, including the one just compiled.

---

## Page 19

Part 1 . Introduction to MQL5 and development environment
1 9
1 .1  Editing, compiling, and running programs
MetaTrader 5 N avigator with a compiled MQL5 program
Ready programs are launched in the terminal using any methods familiar to the user. For instance, any
program, other than a service, can be dragged with the mouse from Navigator to the chart. We will talk
about the features of services separately.
Besides, developers often need the program to be executed in the debugging mode to find what causes
the errors. There are multiple special commands for this purpose, and we will refer to them in Bug fixing
and debugging.
1 .2 MQL Wizard and program draft
Here we will consider the simplest MQL program that does not really do anything. It is aimed at
introducing the process of writing a source code in the editor, compiling it, and launching it in the
terminal. Following the steps below independently, you will make sure that programming is available to
casual users and start adapting to the integrated development environment of MQL5 programs. It will
always be needed for consolidating the material covered.
The simplest MQL5 programs are scripts. Therefore, it is a script that we are going to try and create.
For this purpose, let's start MQL5 Wizard (File -> New). In the first step, we will select Script in the list
of types and press Next:

---

## Page 20

Part 1 . Introduction to MQL5 and development environment
20
1 .2 MQL Wizard and program draft
Creating a script using MQL Wizard. Step 1
In the second step, we will introduce the script name in the Name field, having added it after the
default folder mentioned above and a backslash: "Scripts\". For instance, let's name the script
"Hello" (that is, the Name field will contain the line: "Scripts\Hello") and, without changing anything
else, press Finish.


---

## Page 21

Part 1 . Introduction to MQL5 and development environment
21 
1 .2 MQL Wizard and program draft
Creating a script using MQL Wizard. Step 2
As a result, the Wizard will create a file named Hello.mq5 and open it for editing. The file is located in
folder MQL5/Scripts (standard location for scripts) because we have used the default folder; however,
we could add any sub-folder or even a sub-folder hierarchy. For instance, if we write
"Scripts\Exercise\Hello" in the Name field at Wizard Step 1 , then the Exercise sub-folder will be created
in the Scripts folder automatically, and the file Hello.mq5 will be located in that sub-folder.
All examples from this book will be located in the MQL5Book folders inside catalogs allocated for the
MQL programs of relevant types. This is necessary to facilitate installing the examples into your
working copy of the terminal and rule out any name conflicts with other MQL programs you have
already installed.
For example, file Hello.mq5 delivered as part of this book is located in MQL5\Scripts\MQL5Book\p1 \,
where p1  means Part 1  this example relates to.
The resulting template of script Hello.mq5 contains the following text:
//+------------------------------------------------------------------+
//|                                                        Hello.mq5 |
//|                                  Copyright 2021, MetaQuotes Ltd. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2021, MetaQuotes Ltd."
#property link      "https://www.mql5.com"
#property version   "1.00"
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
{
}
//+------------------------------------------------------------------+
It is this script that is shown in the preceding screenshots of MetaEditor and MetaTrader 5.
All strings starting with "//" are the comments and do not affect the program intent. They are neither
processed by the compiler nor executed by the terminal. They are only used to exchange explanatory
information among developers or to visually emphasize the code parts to enhance the text readability.
For instance, in this template, the file starts with a block containing a comment where the script name
and the author's copyright are expected to be specified. The second block of comments is the heading
for the main function of the script – it is referred to in more detail below. Finally, the last comment
string visually emphasizes the file end.
Three strings starting with a special directive, #property, provide the compiler with some attributes it
builds into the program in a special manner. In our case, they are not important so far and can even be
deleted. The specific directories are available to each MQL program type – we will know about them as
soon as we proceed to learning the particular program types.
The main part of the script, where we are going to describe the essence of the program actions, is
represented by the OnStart function. Here we have to learn the concepts of 'code block' and 'function'.

---

## Page 22

Part 1 . Introduction to MQL5 and development environment
22
1 .3 Statements, code blocks, and functions
1 .3 Statements, code blocks, and functions
Thus, in the script generated by the Wizard, the OnStart function appears as follows:
void OnStart()
{
}
It is exactly our first subject matter within the context of programming in MQL5. Here again, we
immediately encounter unknown concepts and character sequences. To explain them, we shall make a
short digression.
A program must usually implement the following typical stages when running:
• Defining variables, i.e., named cells in the computer memory to store data;
• Organizing the source data input;
• Processing the data – an applied algorithm; and
• Organizing the output of results.
All these stages are not necessary in terms of maintaining the syntactic correctness of the program.
For example, if we create a program that computes the product of "2*2", it obviously does not need
any input data, because numbers necessary for multiplying are integrated in the program text.
Moreover, since 2 and 2 are constant values in this expression, no named cells (variables) are required
in the program. Since we know it anyway what twice two is, we don't really need to communicate the
product number. Such a program would lack any real function, of course. However, it would be
absolutely correct from a technical point of view.
More interestingly, the program may contain no statements on processing. Our script template
specifically represents a sample 'null' program. But what is the above text fragment?
In his day, Niklaus Wirth, one of the big names in programming, gave a simple generalized definition of
programming as a symbiosis of algorithms and data structures.
"Algorithm" shall mean a sequence of statements of a particular programming language. A statement is
a kind of sentence, i.e., a completed utterance, articulated in a programming language according to its
syntax rules. The name "statement" itself suggests that it is perceived by computers as a guide to
operations. In other words, statements describe when and how the required applied data structures
shall be processed. This is exactly why the interpenetration of algorithms and data structures allows
putting the author's ideas into practice.
Unfortunately, in most practical tasks, the number of statements is so large that they must be
systematized somehow for the human to recognize and control the program behavior.
Here too, the divide-and-conquer algorithm comes to help, which is used practically everywhere in
programming and in different guises. We will learn all of them as we continue in this book, now just
noting the essence.
As known, the algorithm reduces to dividing a large complex task into smaller and simpler ones. Here,
we can compare this process with constructing a house or assembling a spacecraft. Both "products"
consist of multiple different modules that, in turn, consist of components, and the latter ones of even
smaller parts, etc.

---

## Page 23

Part 1 . Introduction to MQL5 and development environment
23
1 .3 Statements, code blocks, and functions
Extending this similarity to algorithms, we can say that statements are small parts, while the entire
program is a house/spacecraft. Therefore, we need structural blocks sized intermediately.
This is why it is customary, when implementing algorithms, to combine logically related statements into
larger named fragments, the functions. In the required places of the program, we can address the
function by its name (call it) and doing so, ask the computer to execute all statements contained inside
the function. The entire program is, in fact, the largest external block and therefore, it can also be
presented by the function, from which smaller functions are called or statements are executed
immediately if they are not many. Now we're approaching the OnStart function.
Name OnStart is reserved in scripts to denote the ultimate function that is called by the terminal itself
as a response to the user's actions when the user launches the script using the context menu
command or dragging the mouse over the chart. Thus, the preceding fragment of the code defines the
function OnStart that predetermines the behavior of our entire script.
Those who know programming in other languages, such as C, C++, Rust, or Kotlin, can notice the
similarity of this function with the function main — the core point of entering into the program.
Any script must contain the function OnStart. Otherwise, the compilation may finish with an error.
Empty function OnStart, as ours, starts being executed by the terminal (as soon as the script is
launched in any manner) and immediately finishes its operation. Strictly speaking, there is no applied
algorithm in our script yet, but there is already a stub function to add it.
In other types of MQL programs, there are also special functions to be defined by the programmer in
their code. We will get into the specific features in the relevant parts of the book.
We will consider the function definition syntax in detail in the second part of this book. For a hands-on
review of it, it is sufficient to mention the following basic essentials to understand the description of
OnStart.
Since functions are usually intended for obtaining an applicable result, the characteristics of the
expected value are described in a special manner in their definition: What data types should be obtained
and whether the data is even necessary. Some functions can perform actions that do not require
returning the value. For example, a function can be intended for changing the settings of the current
chart or to send push notifications when the predefined drawdown level is reached on the account. All
this can be programmed by the statements in the function, and it does not create any new data
(reasonable to be returned to any other parts of the program).
In our case, the situation is similar: As the main function of the script, OnStart could return its result to
the external environment only (directly into the terminal) when completed, but this would not affect the
operation of the script itself in any way (because it has already finished off).
That is exactly why, before the OnStart function name, there is the word void that informs the compiler
that the result is not important to us (void means emptiness). void is one of many procedure words
reserved in MQL5. The compiler knows the meanings of all reserved words, and it is guided by them in
reviewing the source code. Particularly, a programmer may use reserved words to define new terms for
the compiler, such as the function OnStart itself.
Parentheses after the name are integral to the description of any function: They may enclose the list of
function parameters. For instance, if we were writing a function taking a square of a number, we would
have to provide it with one parameter for that number. Then we could call this function from any part of
the program, having sent one argument over it, i.e., the specific value for the parameter. We will see
later how to describe the list of parameters; it is not in this current example. This requirement is posed

---

## Page 24

Part 1 . Introduction to MQL5 and development environment
24
1 .3 Statements, code blocks, and functions
on the function OnStart for it is called by the terminal itself, and it never sends anything to this function
as parameters.
At last, braces are used to mark the beginning and the end of the block containing statements.
Immediately following the function name string, such a block will contain a set of operations performed
by this function. It is also named the function body. In this case, there is nothing inside the braces.
Therefore, the script template does not do anything.
The above sequence of word void, name OnStart, an empty list of parameters, and an empty code
block defines the least, empty implementation of the function OnStart for the compiler. Later, adding
statements into the function body, we will extend the definition of function OnStart.
Having executed the Compile command, we will make sure that the script can be successfully compiled,
and that the ready program appears in the Navigator of the terminal in the folder
Scripts/MQL5Book/p1 . This results from the fact that, on the disk in the relevant folder, there is now
the file of Hello.ex5. It can easily be checked in any file manager.
We can run the script on a chart, but the only confirmation of its execution will be the entries in the
terminal log (tab Log in the Tools window; not to be mixed with the toolbar):
Scripts script Hello (EURUSD,H1) loaded successfully
Scripts script Hello (EURUSD,H1) removed
That is, the script is loaded, the control is sent to the function OnStart, but immediately returned to
the terminal because the function does not do anything, and after that, the terminal unloaded the
script from the chart.
1 .4 First program
Let's try to add to the script something simple but illustrative to demonstrate its operation. Let's
rename the modified script as HelloChart.mq5.
In many programming textbooks, the initial example prints the sacramental "Hello, world". In MQL5, a
similar greeting could appear as follows:
void OnStart()
{
  Print("Hello, world");
}
But we will make it more informative:
void OnStart()
{
  Print("Hello, ", Symbol());
}
Thus, we have added only one string with some language structures.
Here, Print is the name of the function embedded in the terminal and intended to display messages in
the Expert Advisors log (tab Expert Advisors in the Tools window; despite its name Expert Advisors, the
tab collects messages from MQL programs of all types). Unlike the function OnStart that we are
defining independently, the Print function is defined for us in advance and forever. Print is one of many
embedded functions constructing the MQL5 API (application programming interface).

---

## Page 25

Part 1 . Introduction to MQL5 and development environment
25
1 .4 First program
The new line in our code denotes the statement to call the Print function sending into it the list of
arguments (in parentheses) that will be printed in the log. Arguments in the list are separated by
commas. In this case, there are two arguments: Line "Hello " and call for another embedded function,
Symbol, that returns the name of the active instrument on the current chart (the value obtained from it
will immediately get into the list of arguments of function Print, into the location from which the Symbol
function has been called).
The Symbol function does not have any parameters and, therefore, nothing is sent into it inside
parentheses.
For instance, if the script is located on the "EURUSD" chart, then calling the function Symbol() will
return "EURUSD" and, in terms of the program being executed, the statement regarding calling the
function Print will have a new look: Print("Hello, ", "EURUSD"). From a user's point of view, of course, all
these calls for functions and the dynamic substitution of intermediary results are smooth and
immediate. However, for a programmer, it is important to fully realize how the program is executed
step by step to avoid logical errors and achieve strict compliance with the plan conceived.
The "Hello " line in double quotation marks is referred to as the literal, i.e., a fixed sequence of
characters perceived by the computer as a text, as it is (as it is introduced in the source code of the
program).
Thus, the printing statement above must print the two arguments one by one in the log, which should
result in actually joining the two lines and obtaining "Hello, EURUSD".
Importantly, the comma inside the quotation marks will be printed in the log as a part of the line and is
not processed in any special manner. Unlike that, the comma that is placed after the closing quotation
mark and before calling Symbol() is the separating character in the argument list, i.e., affects the
program behavior. If the first comma is omitted, the program will not lose its correctness, although it
will print the word "Hello" without a comma after it. However, if the second comma is omitted, the
program will stop being compiled, since the syntax of the function argument list will be broken: All
values in it (in our case, these are two lines) must be separated by commas.
The compiler error will appear as follows:
'Symbol' - some operator expectedHelloChart.mq516 19
The compiler 'complains' of the lack of something before mentioning Symbol. This will break the
compilation, and the executable file of the program is not created. Therefore, we will put the comma
back in place.
This example shows us how important it is to strictly follow the syntax of the language. The same
characters can work differently, being in different parts of the program. Thus, even a small omission
may be critical. For instance, note the semicolon at the end of the line calling Print. The semicolon
means the end of the statement here. If we forget to put it, strange compiler errors may occur.
To see this, we will try to remove this semicolon and re-compile the script. This results in obtaining new
errors with the description of the problem and its place in the source code.

---

## Page 26

Part 1 . Introduction to MQL5 and development environment
26
1 .4 First program
Compilation errors in the MetaEditor log
'}' - semicolon expectedHelloChart.mq517 1
'}' - unexpected end of programHelloChart.mq517 1
The first error explicitly specifies the absence of the semicolon expected by the compiler. The second
error is propagated: The closing brace signaling the end of the program had been detected before the
current statement ended. In the compiler's opinion, it continues, because it has not encountered the
semicolon yet. It is obvious how to fix the errors: The semicolon must be placed back in the right
position in the statement.
Let's compile and launch the fixed script. Although it is executed very quickly and removed from the
chart practically immediately and a record confirming the script operation appears in the Experts log.
HelloChart (EURUSD,H1)Hello, EURUSD
1 .5 Data types and values
Along with calling the embedded function Symbol, we could also use our own function that we have
defined in the source code. Suppose we would like to print in the log not just "Hello", but different
greetings depending on the time of day. We will determine the time of day accurate to hours: 0-8 is
morning, 8-1 6 is afternoon, and 1 6-24 is evening.
It is logical to suggest that the definition structure of the new function must be similar to that of the
function OnStart already familiar to us. However, its name must be unique, i.e., it should not duplicate
the names of other functions or reserved words. We will study the list of these words further in this
textbook, while now luckily suggesting that the word Greeting can be used as a name.

---

## Page 27

Part 1 . Introduction to MQL5 and development environment
27
1 .5 Data types and values
Like the Symbol function, this function must return a string; this time, however, the string must be one
of the following phrases, depending on the time of day: "Good morning", "Good afternoon", or "Good
evening".
Guided by common sense, we are using the common concept of string here. Apparently, it is familiar to
the compiler, because we saw how it had generated a program printing the predefined text. Thus, we
have smoothly approached to the concept of types in the programming language, one of the types
being a string, i.e., a sequence of characters.
In MQL5, this type is described by the keyword string. This is the second type we know, the first one
was void. We have already seen a value of this type, without knowing it was that: It is the literal "Hello,
". When we just insert a constant (particularly, something like a quoted text) into the source code, its
type description is not required: defines the correct type automatically.
Using the OnStart function description as a sample, we can suggest how the function Greeting should
appear for a first approximation.
string Greeting()
{
}
This text indicates our intention to create the Greeting function, which can return an arbitrary value of
the string type. However, for the function to really return something, it is necessary to use a special
statement with the return operator. It is one of many MQL5 operators: We will explore them all later. If
the function has a return value type other than void, it must contain the operator return.
Particularly, to return the former greeting string "Hello, " from the function, we should write:
string Greeting()
{
  return "Hello, ";
}
Operator return stops the function execution and sends out what is to the right of it, as a result. "Out"
hides the source code fragment, from which the function was called.
We have not explored all the options for writing expressions that could form an arbitrary string.
However, the simplest instance with the quoted text is transferred here without any changes. It is
important that the return value type coincides with the function type, as in our case. At the end of the
statement, we put a semicolon.
However, we wanted to generate different greetings depending on the time of day. Therefore, the
function must have an hour-defining parameter that can take values ranging from 0 through 23.
Obviously, the hour number is an integer, i.e., a number that has no fractional part. It is clear that the
time does not stop within an hour, and minutes are counted in it, the number of minutes being an
integer, too. Then again, it is pointless to determine the time of day accurately to a minute. Therefore,
we will limit ourselves to choosing the greeting by the hour number only.
For integer values, there is a special type int in MQL5. This value should be sent to the function
Greeting from another place in the program, from which this function will be called. Here we have first
faced the necessity of describing a named memory cell, that is, a variable.

---

## Page 28

Part 1 . Introduction to MQL5 and development environment
28
1 .6 Variables and identifiers
1 .6 Variables and identifiers
A variable is a memory cell having a unique name (to be referred to without any errors), which can
store the values of a certain type. This ability is ensured by the fact that the compiler allocates for the
variable just enough memory that is required for it in the special internal format: Each type is sized and
has a relevant memory storing format. More details on this are given in Part 2.
Basically, there is a stricter term, identifier, in the program, which term is used for the names of
variables, functions, and many other entities to be learned later herein. Identifier follows some rules. In
particular, it may only contain Latin characters, numbers, and underscores; and it may not start with a
number. This is why the word 'Greeting' chosen for the function earlier meets these requirements.
Values of a variable can be different, and they can be changed using special statements during the
program execution.
Along with its type and name, a variable is characterized by the context, i.e., an area in the program,
where it is defined and can be used without any errors of compiler. Our example will probably facilitate
understanding this concept without any detailed technical reasoning in the beginning.
The matter is that a particular instance of a variable is the function parameter. The parameter is
intended for sending a certain value into the function. Hereof it is obvious that the code fragment,
where there is such a variable, must be limited to the body of the function. In other words, the
parameter can be used in all statements inside the function block, but not outside. If the programming
language allowed such liberties, this would become a source of many errors due to the potential
possibility to 'spoil' the function inside from a random program fragment that is not related to the
function.
In any case, it is a slightly simplified definition of a variable, which is sufficient for this introductory
section. We will consider some finer nuances later.
Hence, let's generalize our knowledge of variables and parameters: They must have type, name, and
context. We write the first two characteristics in the code explicitly, while the last one results from the
definition location.
Let's see how we can define the parameter of the hour number in the Greeting function. We already
know the desired type, it's int, and we can logically choose the name: hour.
string Greeting(int hour)
{
  return "Hello, ";
}
This function will still return "Hello," whatever the hour. Now we should add some statements that
would select different strings to return, based on the value of parameter hour. Please remember that
there are three possible function response options: "Good morning", "Good afternoon", and "Good
evening". We could suppose that we need 3 variables to describe these strings. However, it is much
more convenient to use an array in such cases, which ensures a unified method of coding algorithms
with access to elements.

---

## Page 29

Part 1 . Introduction to MQL5 and development environment
29
1 .7 Assignment and initialization, expressions and arrays
1 .7 Assignment and initialization, expressions and arrays
An array is a named set of same-type cells that are located in memory contiguously, each being
accessible by its index. In a sense, it is a composite variable characterized by a common identifier,
type of values stored, and quantity of numbered elements.
For instance, an array of 5 integers can be described as follows:
int array[5];
Array size is specified in square brackets after the name. Elements are numbered from 0 through N-1 ,
where N is the array size. They are accessed, i.e., the values are read, using a similar syntax. For
example, to print the first element of the above array into the log, we could write the following
statement:
Print(array[0]);
Please note that index 0 corresponds to the very first element. To print the last element, the
statement would be replaced with the following:
Print(array[4]);
It is supposed, of course, that before printing an element of the array, a useful value has once been
written into it. This record is made using a special statement, i.e., assignment operator. A special
feature of this operator is the use of the symbol '=', to the left of which the array element (or variable)
is specified, in which the record is made, while to the right of it the value to be recorded or its
'equivalent' is specified. Here, 'equivalent' hides the language ability to compute expressions of
arithmetic, logic, and other types (we will learn them in Part 2). Syntax of the expressions is mostly
similar to the rules of writing the equations learned in school-time arithmetic and algebra. For example,
operations of addition ('+'), subtraction ('-'), multiplication ('*'), and division ('/') can be used in an
expression.
Below are examples of operators to fill out some elements of the array above.
array[0] = 10;                       // 10
array[1] = array[0] + 1;             // 11
array[2] = array[0] * array[1] + 1;  // 111
These statements demonstrate various methods of assignment and constructing expressions: In the
first string, literal 1 0 is written into element array[0], while in the second and third lines, the
expressions are used, computing which leads to obtaining the results specified for visual clarity in
comments.
Where array elements (or variables, in a general case) are involved in an expression, the computer
reads their values from memory during program execution and performs the above operations with
them.
It is necessary to distinguish the use of variables and array elements to the left of and to the right of
the '=' character in the assignment statement: On the left, there is a 'receiver' of the processed data
(it is always single), while on the right, there are the 'sources' of initial data for computing (there can
be many 'sources' in an expression, like in the last string of this example, where the values of elements
array[0] and array[1 ] are multiplied together).
In our examples, the '=' character was used to assign the values to the elements of a predefined array.
However, it is sometimes convenient to assign initial values to variables and arrays immediately upon

---

## Page 30

Part 1 . Introduction to MQL5 and development environment
30
1 .7 Assignment and initialization, expressions and arrays
defining them. This is called initialization. The '=' character is used for it, too. Let's consider this
syntax in the context of our applied task.
Let's describe the array of strings with the greeting options inside the function Greeting:
string Greeting(int hour)
{
  string messages[3] = {"Good morning", "Good afternoon", "Good evening"};
  return "Hello, ";
}
In the statement added, not only the messages array with 3 elements is defined, but also its
initialization, i.e., filling with the desired initial values. Initialization highlights the '=' character upon
variable/array name and type description. For a variable, it is necessary to specify only one value after
'=' (without braces), while for an array, as we can see, we can write several values separated by
commas and enclosed in braces.
Do not confuse initialization with assignment. The former is specified in defining a variable/array (and is
made once), while the latter occurs in specific statements (the same variable or array element can be
assigned with different values over and over again). Array elements can only be assigned separately:
MQL5 does not support assigning all elements at a time, as is the case with initialization.
The messages array, being defined inside the function, is available only inside it, like the parameter
hour. Then we will see how we can describe variables available throughout the program code.
How shall we transform the incoming value of hour with the hour number into one of the three
elements?
Recall that, according to our idea, hour can have values from 0 through 23. If we divide it by 8 exactly,
we will obtain the values from 0 through 2. For instance, dividing 1  by 8 will give us 0, and 7 by 8 will
give 0 (in exact division, the fractional part is neglected). However, dividing 8 by 8 is 1 , so all numbers
through 1 5 will give us 1  when divided by 8. Numbers 1 6-23 will correspond with the division result of
2. Integers 0, 1 , and 2 obtained shall be used as indexes to read the messages array element.
In MQL5, operation '/' allows computing the exact division for integers.
Expression to obtain the division results is similar to those we have recently considered for the array,
just the parameter hour and operation '/' must be used. We will use the following statement as a
demonstration of a possible implementation of the hour transformation into the element index:
int index = hour / 8;
Here, a new integer variable, index, is defined and initialized by the value of the above expression.
However, we can omit saving the intermediate value in the index variable and immediately transfer this
expression (to the right of '=') inside square brackets, where the array element number is specified.
Then in the statement with operator return, we can extract the relevant greeting as follows:

---

## Page 31

Part 1 . Introduction to MQL5 and development environment
31 
1 .7 Assignment and initialization, expressions and arrays
string Greeting(int hour)
{
  string messages[3] = {"Good morning", "Good afternoon", "Good evening"};
  return messages[hour / 8];
}
The function is more or less ready. After a couple of sections, we will make some corrections, though.
So far, let's save the project in a file under another name, GoodTime0.mq5, and try to call our function.
For this reason, in OnStart, we will use the call for Greeting inside the Print call.
void OnStart()
{
  Print(Greeting(0), ", ", Symbol());
}
We have saved the separating comma (put inside lateral "Hello, ") between the greeting and the
instrument name. Now there are three arguments in the Print function call: The first and the last ones
will be computed on the fly using calls, respectively, of functions Greeting and Symbol, while the
comma will be sent for printing as it is.
So far, we are sending the constant '0' into the function Greeting. It is its value that will get into the
hour parameter. Having compiled and launched the program, we can make sure that it prints the
desired text in the log.
GoodTime0 (EURUSD,H1)Good morning, EURUSD
However, in practice, greetings must be selected dynamically, depending on the time specified by the
user.
Thus, we have approached the need for arranging data input.
1 .8 Data input
The basic way of data transfer into an MQL program is to use input parameters. They are similar to
those of functions and just variables, from many aspects, particularly, in terms of description syntax
and principles of their further use in the code.
Moreover, an input parameter description has some essential differences:
• It is placed in the text outside of all blocks (we have learned just the blocks constituting the body
of functions yet, but we will learn about the other ones later) or, in other words, beyond any pairs
of braces;
• It starts with the keyword input; and
• It is initialized with a default value.
It is usually recommended to place input parameters at the start of the source code.
For instance, to define an input parameter for entering the hour number in our script, the next string
should be added immediately upon the triple of directives #property:
input int GreetingHour = 0;
This record means several things.

---

## Page 32

Part 1 . Introduction to MQL5 and development environment
32
1 .8 Data input
• First, there is the GreetingHour variable in the script now, which is available from any place of the
source code, including from inside of any function. This definition is called a global-level definition,
which is due to the execution of item 1  from the list above.
• Second, using the input keyword makes such a variable visible inside the program and in the user
interface, in the MQL5 program properties dialog, which opens when it starts. Thus, when starting
the program, a user sets the necessary value of parameters (in our case, one parameter
GreetingHour), and they become the values of the corresponding variables during the execution of
the program.
Let's note again that the default value that we have specified in the code will be shown to the user in
the dialog. However, the user will be able to change it. In this case, it is that new, manually entered
value that will be included in the program (not the initialization value).
The initial value of input parameters is affected by both the initialization in the code and the user's
interactive choice in launching them, and the MQL5 program type, and the way it is launched. The
matter is that different types of MQL5 programs have different life cycles after being launched on
charts. Thus, upon a one-time placement in the chart, indicators and Expert Advisors are 'registered' in
it forever, until the user removes them explicitly. Therefore, the terminal remembers the latest settings
selected and uses them automatically, for example, upon the terminal restart. However, scripts are not
saved in charts between the terminal sessions. Therefore, only the default value may be shown to us
when we launch the script.
Unfortunately, for some reason, the description of an input parameter does not guarantee calling the
dialog of settings at the script start (for scripts as an independent MQL5 program type). For this to
happen, it is necessary to add one more, script-specific directive #property into the code:
#property script_show_inputs
As we will see further, this directive is not required for other types of MQL5 programs.
We needed GreetingHour to transfer its value into the Greeting function. To do so, it is sufficient to
insert it into the Greeting function call, instead of 0:
void OnStart()
{
  Print(Greeting(GreetingHour), ", ", Symbol());
}
Considering the changes we have made to describe the input parameter, let's save the new script
version in file GoodTime1 .mq5. If we compile and start it, we will see the data entry dialog:

---

## Page 33

Part 1 . Introduction to MQL5 and development environment
33
1 .8 Data input
Dialog to enter the parameters of script GoodTime1.mq5
For instance, if we edit the value GreetingHour to 1 0, then the script will display the following greeting:
GoodTime1 (EURUSD,H1)Good afternoon, EURUSD
This is a correct and expected result.
Just for the fun of it, let's run the script again and enter 1 00. Instead of any meaningful response, we
will get:
GoodTime1 (EURUSD,H1)array out of range in 'GoodTime1.mq5' (19,18)
We have just encountered a new phenomenon, i.e., runtime error. In this case, the terminal notifies
that in position 1 8 of string 1 9, our script has tried to read the value of an array element having a non-
existing index (beyond the array size).
Since errors are a permanent and necessary companion of a programmer and we have to learn how to
fix them, let's talk in some more details about them.
1 .9 Error fixing and debugging
Programming art relies on the ability to instruct the program what and how it must do and also to
protect it against potentially doing something wrong. The latter one is unfortunately much more
difficult to execute due to multiple not very obvious factors affecting the program behavior. Incorrect
data, insufficient resources, somebody else's and one's own coding errors are just to name some of the
problems.
Nobody is insured against errors in coding programs. Errors may occur at different stages and are
conveniently divided into:
• Compilation errors returned by the compiler when identifying a source code that does not meet the
required syntax (we have already learned about such errors above); it is easiest to fix them
because the compiler searches for them;
• Program runtime errors returned by the terminal, if an incorrect condition occurs in the program,
such as division by zero, computing the square root of a negative, or an attempt to refer to a non-

---

## Page 34

Part 1 . Introduction to MQL5 and development environment
34
1 .9 Error fixing and debugging
existing element of the array, as in our case; they are more difficult to detect since they usually
occur not at any values of input parameters, but only in specific conditions;
• Program designing errors that lead to its complete shutdown without any tips from the terminal,
such as sticking at an infinite loop; such errors may turn out to be the most complex in terms of
locating and reproducing them, while the reproducibility of a problem in the program is a necessary
condition for fixing it afterward; and
• Hidden errors, where the program seems to work smoothly, but the result provided is not correct;
it is easy to detect if 2*2 is not 4, while it is much more difficult to notice the discrepancies.
But let's get back to the specific situation with our script. According to the error message provided to
us by the MQL program runtime environment, the following statement is wrong:
return messages[hour / 8]
In computing the index of an element from the array, depending on the value of the hour variable, a
value may be obtained that goes beyond the array size of three.
The debugger embedded in MetaEditor allows making sure that it really happens. All its commands are
collected in the Debug menu. They provide many useful functions. Here we are going to only settle on
two: Debut -> Start on Real Data (F5) and Debug -> Start on History Data (Ctrl+F5). You can read about
the other ones in the MetaEditor Help.
Both commands compile the program in a special manner – with the debugging information. Such a
version of the program is not optimized as in standard compilation (more details on optimization, please
see Documentation), while at the same time, it allows using the debugging information to 'look inside'
the program during execution: See the states of variables and function call stacks.
The difference between debugging on real data and on history data consists in starting the program on
an online chart with the former one and on the tester chart in a visual mode with the latter one. To
instruct the editor on what exactly chart and with which settings to use, i.e., symbol, timeframe, date
range, etc., you should preliminarily open the dialog Settings -> Debug and fill out the required fields in
it. Option Use specified settings must be enabled. If it is disabled, the first symbol from the Market
Watch and timeframe H1  will be used in online debugging, while tester settings are used when
debugging on history data.
Please note that only indicators and Expert Advisors can be debugged in the tester. Only online
debugging is available to scripts.
Let's run our script using F5 and enter 1 00 in parameter GreetingHour to reproduce the above problem
situation. The script will start executing, and the terminal will practically immediately display an error
message and request for opening the debugger.
Critical error while running script 'GoodTime1 (EURUSD,H1)'.
Array out of range.
Continue in debugger?
Having responded in the affirmative, we will get into MetaEditor where the current string is highlighted
in the source code, in which the error has occurred (please give a notice of the green arrow in the left
field).

---

## Page 35

Part 1 . Introduction to MQL5 and development environment
35
1 .9 Error fixing and debugging
MetaEditor in the debugging mode in case of an error
The current call stack is displayed in the lower left window part: All functions are listed in it (in bottom-
up order), which had been called before the code execution stopped at the current string. In particular,
in our script, the OnStart function was called (by the terminal itself), and the Greeting function was
called from it (we called it from our code). An overview panel is in the lower right part of the window.
Names of variables can be entered into it, or the entire expressions into the Expression column, and
watch their values in the Values columns in the same string.
For instance, we can use the Add command of the context menu or double-click with the mouse on the
first free string to enter the expression "hour / 8" and make sure that it is equal to 1 2.
Since debugging stopped resulting from an error, there is no sense to continue the program; therefore
we can execute the Debug -> Stop command (Shift+F5).
In more complex cases of a not so obvious problem source, the debugger allows the string-by-string
monitoring of the sequence of executing the statements and the contents of variables.
To solve the problem, it is necessary to ensure that, in the code, the element index always falls within
the range of 0-2, i.e., complies with the array size. Strictly speaking, we should have written some
additional statements checking the data entered for correctness (in our case, GreetingHour can only
take a value within the range of 0-23), and then either display a tip or fix it automatically in case of
violation of the conditions.
Within this introductory project, we will not go beyond a simple correction: We will improve the
expression that computes the element index so that its result always falls within the required range. For
this purpose, let's learn about one more operator – the modulus operator that only works for integers.
To denote this operation, we use symbol '%'. The result of the modulus operation is the remainder of
the integer division of dividend by the divisor. For example:

---

## Page 36

Part 1 . Introduction to MQL5 and development environment
36
1 .9 Error fixing and debugging
11 % 5 = 1
Here, with the integer division of 1 1  by 5, we would obtain 2, which corresponds with the largest factor
of 5 within 1 1 , which is 1 0. The remainder between 1 1  and 1 0 is exactly 1 .
To fix the error in function Greeting, suffice to preliminarily perform the modulus division of hour by 24,
which will ensure that the hour number will range within 0-23. Function Greeting will look as follows:
string Greeting(int hour)
{
  string messages[3] = {"Good morning", "Good afternoon", "Good evening"};
  return messages[hour % 24 / 8];
}
Although this correction will surely work well (we are going to check it in a minute), it does not concern
another problem that is left beyond our focus. The matter is that the GreetingHour parameter is of the
int 
type, i.e., it can take both positive and negative values. If we tried to enter - 8, for instance, or a
'more negative' number, then we would get the same runtime error, i.e., going beyond the array; just,
in this case, the index does not exceed the highest value (array size) but becomes smaller than the
lowest one (particularly, -8 leads to referring to the -1 st element, interestingly, the values from -7 to -
1  being displayed onto the 0th element and do not cause any error).
To fix this problem, we will replace the type of parameter GreetingHour with the unsigned integer: We
will use uint instead of int (we will tell about all available types in part two, and here it is uint that we
need). Guided by the limit for the non-negativity of values, built in at the compiler level for uint, MQL5
will independently ensure that neither the user (in the properties dialog) nor the program (in its
computation) "goes negative."
Let's save the new version of the script as GoodTime2, compile, and launch it. We enter the value of
1 00 for the GreetingHour parameter and make sure that, this time, the script is executed without any
errors, while the greeting "Good morning" is printed in the terminal log. It is the expected (correct)
behavior since we can use a calculator and check that the remainder of the modulus division of 1 00 by
24 gives 4, while the integer division of 4 by 8 is 0, which means morning, in our case. From the user's
point of view, of course, this behavior can be considered as unexpected. However, entering 1 00 as the
hour number was also an unexpected user action. The user probably thought that our program would go
down. But this did not happen, and this is a good point. Of course, with real programs, the values
entered must be validated and the user must be notified about bugs.
As an additional measure of preventing from entering a wrong number, we will also use a special MQL5
feature to give a more detailed and friendly name to the input parameter. For this purpose, we will use
a comment after the input parameter description in the same string. For example, like this:
input uint GreetingHour = 0; // Greeting Hour (0-23)
Please note that we have written the words from the variable name separately in the comment (it is not
an identifier in the code anymore, but a tip for the user in it). Moreover, we added the range of valid
values in parentheses. When launching the script, the previous GreetingHour will appear in the dialog to
enter the parameters as follows:
Greeting Hour (0-23)
Now we can be sure that, if 1 00 is entered as the hour, it is not our fault.
A careful reader may wonder why we have defined the Greeting function with the hour parameter and
send GreetingHour into it if we could use the input parameter in it directly. Function, as a discrete

---

## Page 37

Part 1 . Introduction to MQL5 and development environment
37
1 .9 Error fixing and debugging
logical fragment of a code, is formed for both dividing the program into visible and easy-to-understand
parts and reusing them subsequently. Functions are usually called from several parts of the program or
are part of a library that is connected to multiple different programs. Therefore, a properly written
function must be independent of the external context and can be moved among programs.
For instance, if we need to transfer our function Greeting into another script, it will stop being
compiled, since there won't be the GreetingHour parameter in it. It is not quite correct to require
adding it, because the other script can compute the time in another manner. In other words, when
writing a function, we should do our best to avoid unnecessary external dependencies. Instead, we
should declare the function parameters that can be filled out with the calling code.
1 .1 0 Data output
In the case of our script, data are output by simply recording the greeting into the log using the Print
function. Where necessary, MQL5 allows saving the results in files and databases, sending over the
Internet, and displaying as graphical series (in indicators) or objects on charts.
The simplest way to communicate some simple momentary information to the user without making him
or her looking into the log (which is a service tool for monitoring the operation of programs and may be
hidden from the screen) is provided by the MQL5 API function Comment. It can be used exactly as that
of Print. However, its execution results in displaying the text not in the log, but on the current chart, in
its upper left corner.
For instance, having replaced Print with Comment in the text script, we will obtain such a function
Greeting:
void OnStart()
{
  Comment(Greeting(GreetingHour), ", ", Symbol());
}
Having launched the changed script in the terminal, we will see the following:

---

## Page 38

Part 1 . Introduction to MQL5 and development environment
38
1 .1 0 Data output
Displaying text information on the chart using the Comment function
If we need both display the text for the user and draw their attention to a change in the environment,
related to the new information, it is better to use function Alert. It sends a notification into a separate
terminal window that pops up over the main window, accompanying it with a sound alert. It is useful, for
example, in case of a trade signal or non-routine events requiring the user's intervention.
The syntax of Alert is identical to that of Print and Comment.
The image below shows the result of the Alert function operation.
Displaying a notification using the Alert function

---

## Page 39

Part 1 . Introduction to MQL5 and development environment
39
1 .1 0 Data output
Script versions with functions Comment and Alert are not attached to this book for the reader to
independently try and edit GoodTime2.mq5 and reproduce the screenshots provided herein.
1 .1 1  Formatting, indentation, and spaces
MQL5 is among the so-called free-form languages, such as C-like and many other languages. This
means that placing service symbols, such as brackets or operators, and keywords may be random,
provided that syntactic rules are followed. The syntax only limits the mutual sequence of those symbols
and words, while the indentation size at each string start or the number of spaces between the
elements of the statement have no meaning for the compiler. In any place in the text, where a space
needs to be inserted to separate language elements from each other, such as a variable type keyword
and a variable identifier, a larger number of spaces can be used. Moreover, instead of spaces, it is
allowed to use other symbols that denote empty space, such as tabulation and line breaks.
If there is a separating symbol (we will learn more about them in Part 2) between some elements of the
statement, such as a comma ',' between function parameters, then there is no need for using any
spaces at all.
Changes in formatting the source code do not modify the executable code.
Basically, there are many non-free-form languages. In some of them, forming a code block, which is
performed using brace matching in MQL5, is based on equal indents from the left edge.
Due to free formatting, MQL5 allows programmers to use multiple different techniques to form the
source code in order to improve its readability, visibility, and easier internal navigation.
Let's consider some examples of how the source text of the Greeting function can be recorded from our
script, without changing its intent.
Here is the most 'packed' version without any excessive spaces or line breaks (a line break denoted
here with the symbol '\' is only added to comply with the restrictions on publishing source codes in this
book).
string Greeting(int hour){string messages[3]={"Good morning",\
"Good afternoon","Good evening"};return messages[hour%24/8];}
Here is the version, in which excessive spaces and line breaks are inserted.

---

## Page 40

Part 1 . Introduction to MQL5 and development environment
40
1 .1 1  Formatting, indentation, and spaces
string
Greeting ( int hour )
  {
    string messages [ 3 ]
            = {
                "Good morning" ,
                "Good afternoon" ,
                "Good evening"
              } ;
      
    return messages [ hour % 24 / 8 ] ;
  }
MetaEditor has a built-in code styler that allows automatically formatting the source code of the
current file in compliance with one of the styles supported. A specific style can be selected in dialog
Tools -> Settings -> Styler. A style is applied using Tools -> Styler command.
You should keep in mind that your spacing freedom is limited. In particular, you may not insert spaces
into identifiers, keywords, or numbers. Otherwise, the compiler won't be able to recognize them. For
example, if we insert just one space between digits 2 and 4 in the number 24, the compiler will return a
bunch of errors trying to compile the script.
Here is a knowingly incorrectly modified string:
return messages[hour % 2 4 / 8];
Here is the error log:
'GoodTime2.mq5'GoodTime2.mq51 1
'4' - some operator expectedGoodTime2.mq519 28
'[' - unbalanced left parenthesisGoodTime2.mq519 18
'8' - some operator expectedGoodTime2.mq519 32
']' - semicolon expectedGoodTime2.mq519 33
']' - unexpected tokenGoodTime2.mq519 33
5 errors, 0 warnings6 1
Compiler messages may not always appear clear. It should be considered that, even upon the very first
(in succession) error, there is a high probability that the internal representation of the program (as the
compiler perceived it in 'mid-sentence') differs considerably from what the programmer has suggested.
In particular, in this case, only the first and the second errors contain the key to understanding the
problem, while all other ones are propagated.
According to the first error, the compiler expected to find the symbol of an operation between 2 and 4
(as it perceives 2 and 4 as two different numbers and not as 24 separated by a space). Alternative
logic consists in the fact that a closing square bracket is omitted here, and the compiler displayed the
second error: "'[' - unbalanced left parenthesis." After that running through the expression gets
completely shattered, due to which the subsequent number 8 and closing bracket ']' appear
inappropriate to the compiler. But in fact, if we just delete the excessive space between 2 and 4, the
situation will become normal.
It is, of course, much easier to perform such an error analysis where we have intentionally added the
issue. We do not always understand in practice how to remedy one situation or another. Even in the
case above, supposing that you have received this broken code from another programmer and the
array elements do not contain such trivial information, another correction option is easy to suspect:

---

## Page 41

Part 1 . Introduction to MQL5 and development environment
41 
1 .1 1  Formatting, indentation, and spaces
Either 2 or 4 must be left, because the author has probably desired to replace one number with another
and not cleaned the 'footprints'.
1 .1 2 Mini summary
In Part 1 , we got familiar with the MetaEditor framework, created a script template using MQL Master,
and gradually filled the script with code to solve a simple problem. For this purpose, we used some
basic principles and syntactic structures of MQL5. Then we tried the debugger in practice, fixed some
issues, and came to a stable program operation.
Our script samples evolved as follows:
In the subsequent sections of this book, we will start to explore in detail these and many other features
of MQL5, the technical aspects of programming, and its applications for trading.

---

## Page 42

Part 2. Programming fundamentals
42
 
Part 2. MQL5 programming fundamentals
Like any other programming language, MQL5 is based on some fundamental concepts used to create
more complex structures and, eventually, programs as a whole. In this Part, we are going to learn most
of the concepts, such as data types, identifiers, variables, expressions, and operators, as well as the
techniques to combine various statements in the code for building the desired program operation logic.
The material assists our readers in progressing to the independent practical application of the
procedural programming, This is one of the very first programming trends to solve various problems. In
fact, it is the formation of a program from small steps (statements) to be executed in the required
sequence for data processing. The text script shown in Part 1  of this book is an example of such a
style.
This section covers a broad spectrum of fundamental concepts and tools essential for successful MQL5
programming, including the following subsections:
Identifiers:
·Identifiers form the foundation of any program code. This subsection discusses the purpose and
rules for naming identifiers in MQL5.
Built-in data types:
·MQL5 includes a variety of built-in data types, each designed to store and process specific types of
information. This section provides a comprehensive understanding of basic data types.
Variables:
Variables are used to store and manage data in a program. The "Variables" section teaches the basics
of working with variables and considers how to declare, initializing, and assign values to them.
Arrays:
·Arrays provide a structured way to store data. This section covers the basics of creating and using
arrays in MQL5.
Expressions:
·Expressions form the basis of calculations and program logic. From this subsection, you will learn
how to construct and evaluate expressions in MQL5.
Type conversion:
·Data type conversion is an integral part of programming. The "Type Conversion" section provides
an understanding of the process related of converting data between different types in MQL5.
Statements:
·Statements are commands that control program execution. In this section, we will look at various
types of statements and their applications.
Functions:
·Functions allow for code structuring and reuse. This section dives into the basics of creating and
calling functions in MQL5.
Preprocessor:
·The MQL5 preprocessor processes the source code before compilation. The "Preprocessor" section
describes the principles of using preprocessor directives and their impact on the code.

---

## Page 43

Part 2. Programming fundamentals
43
 
Procedural programming principles will act as the basis for the subsequent learning of a more powerful
paradigm, i.e., Object-Oriented Programming (OOP). It will be referred to in Part 3.
MQL5 Programming for Traders – Source Codes from the Book. Part 2
Examples from the book are also available in the public project \MQL5\Shared Projects\MQL5Book
2.1  Identifiers
As we are going to see soon, programs are built of multiple elements that must be referred to by unique
names to avoid confusion. These names are exactly what is called identifiers.
Identifier is a word composed by certain rules: Only Latin characters, underscore characters ('_'), and
digits may be used in it, and the first character may not be a digit. Letters can be small (lower-case)
and capital (upper-letter).
The maximum identifier length is 63 characters. The identifier may not coincide with any service words
of MQL5, such as type names. You can find the full list of service words in the Help. Violating any of the
identifier forming rules will cause a compilation error.
Here are some correct identifiers:
i             // single character
abc           // lower-case letters
ABC           // upper-case letters
Abc           // mixed-case letters
_abc          // underscore at the beginning
_a_b_c_       // underscore anywhere
step1         // digit
_1step        // underscore and digit
We have already seen in the script HelloChart how identifiers are used as names of variables and
functions.
It is recommended to provide identifiers with meaningful names, from which the purpose or content of
the relevant element becomes clear. In some cases, single-character identifiers are used, which we will
discuss in the section dealing with loops.
There are some common practices for composing identifiers. For instance, if we choose a name for a
variable that stores the value of profit factor, the following options will be good:
ProfitFactor   // "camel" style, all words start with a capital letter
profitFactor   // "camel" style, all words but the first one start with a capital letter
profit_factor  // "snake" style, the underscore is put between all words
In many programming languages, different styles are used to name different entities. For example, a
practice may be followed, in which variable names only start with a lower-case letter, while class names
(see Part 3) with upper-case letters. This helps the programmer analyze the source code when working
in a team or if they return to their own code fragment after a long break.
Along the above ones, there are other styles, some of which are used in special cases:

---

## Page 44

Part 2. Programming fundamentals
44
2.1  Identifiers
profitfactor   // "smooth" style, all letters are lower-case
PROFITFACTOR   // "smooth" style, all letters are upper-case
PROFIT_FACTOR  // "macro" style, all letters are upper-case with underscores between the words
All capitals are sometimes used in the names of constants.
"Macro" style is conventionally used in the names of preprocessor macro descriptions.
2.2 Built-In Data Types
The data type is a fundamental concept we comfortably use in our everyday life without even thinking
of its existence. It is implied based on the meaning of the information we exchange and on the
processing procedures admissible for it. For example, controlling our household assets, we add and
deduct numbers representing our revenues and expenses. Here, the 'number' describes a type, for
which we realize fully its possible values and arithmetic operations on them. In the trading context,
there is a similar value, the current account balance, in MetaTrader 5; therefore, MQL5 provides a
mechanism to create and manipulate numbers.
Unlike numbers, text information, such as the name of a trading instrument, conforms to other rules.
Here we can build a word of letters or a sentence of words, but it is impossible to compute the
progressive total or arithmetic mean of several lines. Thus, 'line' or 'string' is another data type, not a
numeric one.
Along with the purpose and a typical set of operations that are meaningful for each type, there is
another important thing that differs types from each other. It's their size. For instance, the week
number cannot exceed 52 within a year, while the number of seconds that have elapsed from the
beginning of the year represents an astronomical shape. Therefore, to efficiently store and process
such different values in the computer memory, differently sized segments can be singled out. This leads
us to understand that, in fact, the generalizing concept of a 'number' may hide different types.
MQL5 allows the used of some number types differing both in the sizes of memory cells allocated for
them and in some additional features. In particular, some numbers may take negative values, such as
floating profit in pips, while the other ones may not, such as account numbers. Moreover, some values
cannot have a fractional part and therefore, it is more cost-efficient to represent them with a stricter
type of 'integers', as opposed to those of random 'numbers with a decimal point'. For instance, an
account balance or the price of a trading instrument generally have values with a decimal point. At the
same time, the number of orders in history or, again, the account number is always an integer.
MQL5 supports a set of universal types similar to those available in the vast majority of programming
languages. The set includes integer types (different sizes), two types of real numbers (with a decimal
point) of different precision, strings, and single characters, as well as the logical type that only has two
possible values: true and false. Moreover, MQL5 provides its own, specific types operating with time and
color.
For the sake of completeness, let's note that MQL5 allows expanding the set of types, declaring applied
types in the code, i.e., structures, classes, and other entities typical of OOP; but we are going to
consider them later.
Since the size of the cell where the value is stored is an important type attribute, let's touch on
memory methodology.
The smallest unit of computer memory is a byte. In other words, a byte is the smallest size of a cell
that a program can allocate for a separate value. A byte consists of 8 smaller 'particles', bits, each

---

## Page 45

Part 2. Programming fundamentals
45
2.2 Built-in data types
being able to be in two states: Enabled (1 ) or disabled (0). All modern computers use such bits at the
lower level because such a binary representation of information is convenient to be embodied in
hardware(in random-access memory, in processors, or while transferring the data by network cables or
via WiFi).
Processing the values of different types is ensured due to the different interpretations of the bit states
in memory cells. The compiler deals with this. Programmers usually do not go as low as bits; however,
the language provides tools for that (see Bitwise operations).
There are special reserved words in MQL5 to describe data types. We have already known some of
them, such as void, int, and string, from Part 1 . A complete list of types is given below, each with a
quick reference and size in bytes.
By their purpose, they can be conditionally divided into numeric and character-coded data (marked in
the relevant columns), as well as other, specialized types, such as strings, logical (or boolean) types,
date/time, and color. Type void stands apart and indicates there is no value at all. In addition to scalar
types, MQL5 provides object types for operations with complex numbers, matrices, and vectors:
complex, vector, and matrix. These types are used to solve various problems in linear algebra,
mathematical modeling, machine learning, and other areas. We will study them in detail in Part 4 of the
book.
Type
Size
(bytes)
Number
Character
Note
char
1
+
+
Single-byte character or a
signed integer
uchar
1
+
+
Single-byte character or an
unsigned integer
short
2
+
+
Two-byte character or a
signed integer
ushort
2
+
+
Two-byte character or an
unsigned integer
int
4
+
Signed integer
uint
4
+
Unsigned integer
long
8
+
Signed integer
ulong
8
+
Unsigned integer
float
4
+
Signed floating-point
number
double
8
+
Signed floating-point
number
enum
4
(int)
Enumeration
datetime
8
(ulong)
Date and time
color
4
(uint)
Color

---

## Page 46

Part 2. Programming fundamentals
46
2.2 Built-in data types
Type
Size
(bytes)
Number
Character
Note
bool
1
(uchar)
Logical
string
1 0+
variable
String
void
0
Void
complex
1 6
+
Structure with two double-
type fields
vector
vector length x type size
+
One-dimensional array of
real or complex type
matrix
rows x columns x type size
+
Two-dimensional array of
real or complex type
Depending on its size, different value ranges may be stored in the numeric type. Along with the above,
the range may considerably vary for the integers and floating-point numbers of the same size, because
different internal representations are used for them. All these cobwebs will be considered in the
sections dealing with specific types.
A programmer is free to choose a numeric type based on the anticipated values, efficiency
considerations, or for reasons of economy. Particularly, the smaller type size allows fitting more values
of this type in memory, while integers are processed faster than floating-point numbers.
Please note that numeric and character-coded types are partly crossed. This happens because a
character is stored in memory as an integer, i.e., a code in the relevant table of characters: ANSI for
single-byte chars or Unicode for two-byte ones. ANSI is a standard named after an institute (American
National Standards Institute), while Unicode, you guessed it, means Universal Code (Character Set).
Unicode characters are used in MQL5 to make strings (type string). Single-byte characters are usually
required in integrating the programs with external data sources, such as those from the Internet.
As mentioned above, numeric types can be divided into integers and floating-point numbers. Let's
consider them in more detail.
2.2.1  Integers
Integer types are intended for storing numbers without decimal points. They should be chosen if the
applied sense of the value excludes fractions. For example, the numbers of bars on a chart or of open
positions are always integers.
MQL5 allows choosing integer types sized 1 -8 bytes using keywords char, short, int, and long,
respectively. They all are the signed types, i.e., they can contain both positive and negative values. If
necessary, integer types having the same sizes can be declared unsigned (their names starting with 'u'
for 'unsigned'): uchar, ushort, uint, and ulong.
Based on the type size and being signed/unsigned, the following table shows the ranges of potential
values.

---

## Page 47

Part 2. Programming fundamentals
47
2.2 Built-in data types
Type
min
max
char
-1 28
1 27
uchar
0
255
short
-32768
32767
ushort
0
65535
int
-21 47483648
21 47483647
uint
0
4294967295
long
-9223372036854775808
9223372036854775807
ulong
0
1 8446744073709551 61 5
There is no need to memorize the above limiting values for each integer. There are many predefined
named constants in MQL5, which can be used in a code instead of 'magic' numbers, including the
lowest/highest integers. This technology is considered in a section dealing with the preprocessor. Here,
we just list the relevant named constants: CHAR_MIN, CHAR_MAX, UCHAR_MAX, SHORT_MIN,
SHORT_MAX,USHORT_MAX, INT_MIN, INT_MAX, UINT_MAX, LONG_MIN, LONG_MAX, and
ULONG_MAX.
Let's explain how these values are obtained. This requires returning to bits and bytes.
The number of all possible combinations of different states of 8 bits, enabled and disabled, within one
byte, is 256. This produces the range of values 0-255 that can be stored in a byte. However,
interpreting them depends on the type, for which this byte is allocated. Different interpretations are
ensured by the compiler, according to the programmer's statements.
The low-order (rightmost) bit in a byte means 1 , the second 2, the third 4, and so on through the high-
order bit that means 1 28. It's plain to see that these numbers are equal to two raised to a power
equaling the bit number (numbering starts from 0). This is the effect of using the binary system.
Bits
high-order
low-order
Number
7
6
5
4
3
2
1
0
Value
1 28
64
32
1 6
 8
 4
 2
 1 
Where all bits are set, this produces the sum of all powers of two, i.e., 255 is the highest value for a
byte. If all bits are reset, we get zero. If a low-order bit is enabled, the number is odd.
In coding signed numbers, the high-order bit is used to mark negative values. Therefore, for a single-
byte integer within the positive range, 1 27 becomes the highest value. For negative values, there are
1 28 possible combinations, i.e., the lowest value is -1 28. Where all bits in a byte are set, it is
interpreted as -1 . If the lower-order bit is reset in such a number, we will get -2, etc. If only the higher-
order bit (sign) is set and all other bits are reset, we get -1 28.
This coding that may seem to be irrational is called "additional." It allows you to unify computations of
signed and unsigned numbers at the hardware level. Moreover, it allows you not to lose one value, which

---

## Page 48

Part 2. Programming fundamentals
48
2.2 Built-in data types
would happen if the positive and negative regions were coded identically: Then we would have got two
values for zero, i.e., a positive 0 and a negative 0. What is more, this would bring ambiguity.
Numbers with more bytes, i.e., 2, 4, or 8, have a similar consecutive numbering of bits and the
progression of their respective values. In all cases, a criterion for the number negativity is the set high-
order bit of the high-order byte.
Thus, we can use a byte to store an unsigned integer (uchar, i.e., unsigned character abbreviated)
within the range of 0-255. We can also write a signed integer into the byte (for which purpose we will
describe its type as char). In this case, the compiler will divide the available amount of combinations of
256 equally between positive and negative values, having displayed it onto the region from -1 28
through 1 27 (the 256th value is zero). It's plain to see that values 0-1 27 will be coded equally at the
bit level for signed and unsigned bytes. However, large absolute values, starting from 1 28, will turn into
negative ones (according to the scheme described in the insertion above). This "transformation" only
takes place at the moment of reading or performing any operations with the value stored, with the
identical internal data representation (state of bits).
We will consider this matter in more detail in the section dealing with typecasting.
In a similar manner as with single-byte integers, it is easy to calculate that the number of bit
combinations is 65536 for 2 bytes. Hence, the ranges are formed for the signed and unsigned two-byte
integer, short and ushort. Other types allow storing even larger values due to increasing their byte
sizes.
Please note that using an unsigned type with the same size allows doubling the highest positive value.
This may be necessary for storing potentially very large quantities, for which no negative values may
appear. For example, the order number in MetaTrader 5 is a value of the ulong type.
We have already encountered the integer description samples in Part 1 . In particular, input parameter
GreetingHour of type uint was defined there:
input uint GreetingHour = 0;
Except for the additional keyword, input, that makes the variable visible in the list of parameters of an
MQL program, other components, i.e., type, name, and optional initialization after the '=' sign, are
intrinsic to all variables.
Variable description syntax will be considered in detail in the Variables section. So far, please note the
method of recording the constants of integer type. In describing a variable, constants can be specified
as a default value (in the example above, it is 0). Moreover, constants can be used in expressions, for
instance, in a formula event.
It should be reminded that constants of any type, inserted in the source code, are named literals
(textually: "word-for-word"). Their name derives from the fact that they are introduced into the
program "as is" and used immediately at the point of description. Literals, unlike many other elements
of the language, particularly variables, have no names and cannot be referred to from other points of
the program.
For negative numbers, it is required to provide the minus sign '-' before the number; however, the plus
sign '+' can be omitted for positive numbers, i.e., forms +1 00 and just 1 00 are identical.
It should be noted that numeric values are usually recorded in the source code within our habitual
decimal notation. However, MQL5 allows using the other one, i.e., hexadecimal. It is convenient for
processing bit-level information (see Bitwise operations).

---

## Page 49

Part 2. Programming fundamentals
49
2.2 Built-in data types
Numbers from 0 through 9 are permitted in all digit order numbers in decimal constants, while for
hexadecimal ones, along with digits, Latin symbols from A through F or from a through f (that is, case
does not matter) are used additionally. "Hexadecimal digit" A corresponds with number 1 0 of decimal
notation, B – 1 1 , C – 1 2, etc., up through F equal to 1 5.  
A distinctive feature of a hexadecimal constant is the fact that it begins with prefix 0x or 0X, followed
by the significant digit orders of the number. For instance, number 1  is recorded as 0x1  in the
hexadecimal system, while 1 6 as 0x1 0 (an additional higher order digit is required because 1 6 is
greater than 1 5, that is, 0xF). Decimal 255 turns into 0xFF.
Let's give some more examples illustrating various situations of using integer types in describing
variables (attached in script MQL5/Scripts/MQL5Book/p2/TypeInt.mq5):
void OnStart()
{
  int x = -10;          // ok, signed integer x = -10
  uint y = -1;          // ok, but unsigned integer y = 4294967295
  int z = 1.23;         // warning: truncation of constant value, z = 1
  short h = 0x1000;     // ok, h = 4096 in decimal
  long p = 10000000000; // ok
  int w = 10000000000;  // warning, truncation..., w = 1410065408
}
Variable x is initialized correctly by the permitted negative value, -1 0.
Variable y is unsigned. Therefore, an attempt to record a negative value in it leads to an interesting
effect. Number -1  has a representation in bits, which is interpreted by the program in accordance with
the unsigned type, uint. Therefore, number 4294967295 is obtained (it is actually equal to
UINT_MAX).
Variable z is assigned with the floating-point number 1 .23 (they will be considered in the next section),
and the compiler warns about the truncation of the fractional part. As a result, integer 1  gets into the
variable.
Variable h is successfully initialized by a constant in the hexadecimal form (0x1 000 = 4096).
The large value 1 0000000000 is recorded in variables p and w, the former of which is of a long integer
type (long) and processed successfully, while the latter one of the normal type (int) and, therefore,
calls for the compiler warning. Since the constant exceeds the maximum value for int, compiler
truncates the excessive higher order digits (bits) and, in fact, 1 41 0065408 gets into w.
This behavior is one of the potential negative developments of type conversions that may or not may be
implied by the programmer. In the latter case, it is fraught with a potential error. Clearly, in this
particular example, wrong values were selected intentionally to demonstrate warnings. It is not always
that obvious in a real program, which values the program is attempting to save in the integer variable.
Therefore, you should look into the compiler warnings very carefully and try to make away with them,
having changed the type or explicitly specified the required typecast. This will be considered in the
section dealing with Typecasting.
For integer types, arithmetic, bitwise, and other types of operations are defined (see chapter
Expressions).

---

## Page 50

Part 2. Programming fundamentals
50
2.2 Built-in data types
2.2.2 Floating-point numbers
We use numbers with a decimal point, or real numbers, in everyday life just as often as integers. The
name 'real' itself indicates that using such numbers, you can express something tangible from the real
world, such as weight, length, body temperature, i.e., everything that can be measured by a non-
integer amount of units, but with "a little more."
We often use real numbers in trading, too. For instance, they are used to express symbol prices or
volumes in trading orders (normally permitting the fractional parts of a full-sized lot).
There are 2 real types provided in MQL5: float for normal accuracy and double for double accuracy.
In the source code, the constant values of types float and double are usually recorded as an integer
and a fractional part (each being a sequence of digits), separated by the character '.', such as 1 .23 or
-789.01 . There can be no integer or fraction (but not both at a time), but the point is mandatory. For
instance, .1 23 means 0.1 23, while 1 23. means 1 23.0. Simply 1 23 will create a constant of integer
type.
However, there is another form of recording real constants, the exponential one. In it, the integer and
fractional part are followed by 'E' or 'e' (case does not matter) and an integer representing the power,
to which 1 0 should be raised to obtain an additional factor. For instance, the following representations
display the same number, 0.57, in exponential form:
 .0057e2
0.057e1
.057e1
57e-2
When recording real constants, the latter ones are defined by default as type double (they consume 8
bytes). To set type float, suffix 'F' (or 'f') should be added to the constant on the right.
Types float and double differ by their sizes, ranges of values, and number representation accuracy. All
this is shown in the table below.
Type
Size (bytes)
Minimum
Maximum
Accuracy (digit orders)
float
4
±1 .1 8 * 1 0-38
±3.4 * 1 038
6-9, usually 7
double
8
±2.23 * 1 0-308
±1 .80 * 1 0308
1 5-1 8, usually 1 6
Range of values is shown for them in absolute terms: Minimum and maximum determine the amplitude
of permitted values in both positive and negative regions. Similar to integer types, there are embedded
named constants for these limiting values: FLT_MIN, FLT_MAX, DBL_MIN, DBL_MAX.
Please note that real numbers are always signed, that is, there are no unsigned analogs for them.
Accuracy shall mean the quantity of significant digits (decimal digits) the real number of the relevant
type is able to store undistorted.
Indeed, the numbers of real types are not as accurate as those of integer types. This is the price to be
paid for their universality and a much wider range of potential values. For instance, if an unsigned 4-
byte integer (uint) has the highest value of 4294967295, i.e., about 4 million, or 4.29*1 09, then the 4-
byte real one (float) has 3.4 * 1 038, which is by 29 orders of magnitude higher. For 8-byte types, the

---

## Page 51

Part 2. Programming fundamentals
51 
2.2 Built-in data types
difference is even more perceptible: ulong can house 1 8446744073709551 61 5 (1 8.44*1 018, or ~1 8
quintillion), while double can house 1 .80 * 1 0308, that is, by 289 orders of magnitude more. Insertion
provides more detail regarding accuracy.
Mantissa and Exponent
The internal representation of real numbers in memory (in the bytes allocated for them) is quite
tricky. The higher-order bit is used as a marker of the negative sign (we have also seen that in
integer types). All other bits are divided into two groups. The larger one contains the mantissa of
the number, i.e., significant digits (we mean binary digits, i.e., bits). The smaller one stores the
power (exponent), to which 1 0 must be raised to obtain the stored number upon multiplying it by
the mantissa. Particularly, for type float mantissa is sized 24 bits (FLT_MANT_DIG), while for
double it is 53 (DBL_MANT_DIG). In terms of conventional decimal places (digits), we will get the
same accuracy that has been shown in the table above: 6 (FLT_DIG) is the lowest quantity of
significant digits for float, while 1 5 (DBL_DIG) is that for double. However, depending on the
particular number, it can have "lucky" combinations of bits, corresponding to a greater quantity of
decimal digits. Sizes of the parameters are 8 and 1 1  bits for float and double, respectively.
Due to the exponent, real numbers get a much larger range of values. At the same time, with the
increase in the exponent, the "specific weight" of the low-order digit of mantissa increases, too.
This means that two neighboring real numbers that can be represented in the computer memory
are substantially different. For instance, for number 1 .0 the "specific weight" of the low-order bit is
1 .1 92092896e–07 (FLT_EPSILON) in case of float and 2.22044604925031 31 e-01 6
(DBL_EPSILON) in case of double. In other words, 1 .0 is indistinguishable from any number near it
if such a number is below 1 .1 92092896e–07. This may seem not very important or "not a big
deal," but this uncertainty region gets larger for larger numbers. If you store in float a number
about 1  billion (1 *1 09), the last 2 digits will stop being safely stored or restored from memory (see
the code sample below). However, basically, the problem is not the absolute value of a number, but
the maximum quantity of digits in it, which should be recalled without losses. Equally "well," we can
try to fit a number represented as 1 234.56789 (which is structurally much like the price of a
financial instrument) in float; and its two last digits will "float" due to the lack of accuracy in their
internal representation.
 
For double, a similar situation will start showing for much greater numbers (or for a much greater
quantity of significant digits), but it is still possible and often happens in practice. You should
consider this when operating very large or very small real numbers and write your programs with
additional checks for potential loss of accuracy. In particular, you should compare a real number
with zero in a special manner. We will deal with it in the section on comparison operators. 
It may seem to a careful reader that the sizes of mantissa and exponent above are specified
wrongly. Let's explain that exemplified by float. It is stored in the memory cell sized 4 bytes, that
is, consumes 32 bits. At the same time, the sizes of mantissa (24) and exponent (8) sum to 32
already. Then where is the signed bit? The matter is that IT professionals arranged to store
mantissa in the 'normalized' form. It will be easier to understand what it is if we consider the
exponential form of recording a normal decimal number first. Let's say number 1 23.0 could be
represented as 1 .23E2, 1 2.3E1 , or 0.1 23E3. A designation is considered to be the normalized
form, where only one significant digit (i.e., not zero) is placed before the point. For this number, it is
1 .23E2. By definition, digits from 1  through 9 are considered significant digits in decimal notation.
Now we are smoothly going to the binary notation. There is only one significant digit in it, 1 . It
appears that the normalized form in binary notation always starts with 1 , and it can be omitted (not
to spend memory on it). In this manner, one bit can be saved in the mantissa. In fact, it contains

---

## Page 52

Part 2. Programming fundamentals
52
2.2 Built-in data types
23 bits (one more higher-order unity is implicit and added automatically when reconstructing the
number and retrieving it from memory). Reducing mantissa by 1  bit makes room for the signed bit.
Predominantly, where the floating-point type should be used, we choose double as a more accurate
one. Type float is only used to save memory, such as when working with very large data arrays.
Some examples of using the constants of real types are shown in script
MQL5/Scripts/MQL5Book/p2/TypeFloat.mq5.
void OnStart()
{
  double a0 = 123;      // ok, a0 = 123.0
  double a1 = 123.0;    // ok, a1 = 123.0
  double a2 = 0.123E3;  // ok, a2 = 123.0
  double a3 = 12300E-2; // ok, a3 = 123.0
  double b = -.75;      // ok, b = -0.75
  double q = LONG_MAX;  // warning: truncation, q = 9.223372036854776e+18
                        //               LONG_MAX = 9223372036854775807
  double d = 9007199254740992; // ok, maximal stable long in double
  double z = 0.12345678901234567890123456789; // ok, but truncated
                           // to 16 digits: z = 0.1234567890123457
  double y1 = 1234.56789;  // ok, y1 = 1234.56789
  double y2 = 1234.56789f; // accuracy loss, y2 = 1234.56787109375
  float m = 1000000000.0;  // ok, stored as is
  float n =  999999975.0;  // warning: truncation, n = 1000000000.0
}
Variables a0, a1 , a2, and a3 contain the same numbers (1 23.0) written in different methods.
In the constant for variable b, the insignificant zero is omitted before the point. Moreover, here is the
demonstration of recording a negative number using the minus sign, '-'.
An attempt is made to store the greatest integer in variable q. At this place, the compiler gives a
warning, because double cannot represent LONG_MAX accurately: Instead of
9223372036854775807, there will be 9223372036854776000. It obviously demonstrates that,
even though the ranges of the double values exceed those of integers vastly, it is achieved due to losing
the low-order digits.
As a comparison, the maximum integer that the double type is able to store without any distortions is
given as the value of variable d. In the sequence of integers, it will be followed by sporadic skips, if we
use double for them.
Variable z reminds us again about the limitation on the maximum quantity of significant digits (1 6) — a
longer constant will be truncated.
Variables y1  and y2, in which the same number is recorded in different formats (double and float), allow
seeing the loss of accuracy due to the transition to float.
In fact, variables m and n will be equal, because 999999975.0 is roughly stored in the internal
representation and turns into 1 000000000.0.
Numeric types are often used to calculate using formulas; a wide set of operations is defined for them
(see Expressions).  

---

## Page 53

Part 2. Programming fundamentals
53
2.2 Built-in data types
Computations can sometimes lead to incorrect results, that is, they cannot be represented as a
number. For example, the root of a negative number or the logarithm of zero cannot be defined. In such
cases, real types can store a special value named NaN (Not A Number). In fact, there are several
different types of such values that allow, for instance, telling the difference between plus infinity and
minus infinity. MQL5 provides a special function, MathIsValidNumber, that checks whether the double
value is a number or one of NaN values.
2.2.3 Character types
Character data types are intended for storing particular characters (letters), of which strings are
formed (see Strings). MQL5 has 4 character types: Two sized 1  byte (char, uchar) and two sized 2
bytes (short, ushort). Types prefixed with 'u' are unsigned.
In fact, character types are integer ones, since they store an integer code of a character from the
relevant table: For char, it is the table of ASCII characters (codes 0-1 27); for uchar, it is extended
ASCII (codes 0-255); and for short/ushort, it is the Unicode table (up to 65535 characters in the
unsigned version). If it is of any interest to you, ASCII is the abbreviated American Standard Code for
Information Interchange.
For MQL5 strings, 2-byte chars ushort are used. 1 -byte uchar types are normally used to integrate with
external programs when transferring the arrays of random data that are packed and unpacked in other
types according to applied protocols, such as for connecting to a crypto platform.
Constants of characters are recorded as letters enclosed in single quotes. However, you can also use
the integer notation (see Integers) considered above. At the same time, the integer must be within the
range of values for 1 - or 2-byte format.
Additionally, we can use the notation of escape sequences. They use a backslash ('\') as the first
character followed by one of the predefined control characters and/or a numerical code. MQL5
supports the following escape sequences:
• \n – new line
• \r – carriage return
• \t – tabulation
• \\ – backslash
• \" – double quote
• \' – single quote
• \X or \x – prefix to subsequently specify a numerical code in hexadecimal format
• \0 – prefix to subsequently specify a numerical code in octal format
Basic methods of using the constants of character types are given in script
MQL5/Scripts/MQL5Book/p2/TypeChar.mq5.

---

## Page 54

Part 2. Programming fundamentals
54
2.2 Built-in data types
void OnStart()
{
  char a1 = 'a';  // ok, a1 = 97, English letter 'a' code
  char a2 = 97;   // ok, a2 = 'a' as well
  char b = '£';   // warning: truncation of constant value, b = -93
  uchar c = '£';  // ok, c = 163, pound symbol code
  short d = '£';  // ok
  short z = '\0';    // ok, 0
  short t = '\t';    // ok, 9
  short s1 = '\x5c'; // ok, backslash code 92
  short s2 = '\\';   // ok, backslash as is, code 92 as well
  short s3 = '\0134';// ok, backslash code in octal form
}
Variables a1  and a2 get the value of character 'a' (English letter) in two different ways.
There is an attempt to record '£' in variable b, but its code 1 63 is beyond the range char (1 27);
therefore it is "transformed" into the signed -93 (compiler gives a warning). The variables of types
uchar (c) and short (d) that follow it perceive this code as normal.
Other variables are initialized using escape sequences.
Characters can be processed with the same operations as integers (see Expressions).
2.2.4 String type
String type is intended for storing text-based information and is marked by keyword string. String is a
sequence of the ushort characters and supports the complete Unicode range, including multiple
national scripts. For instance, names of financial instruments and comments in trading orders are
strings.
By reason of the specific nature of strings, their size is a variable value that is equal to the doubled
length of the text (quantity of characters multiplied by the "width" of a character, i.e., 2 bytes) plus
one more character. This additional character is intended for the 'terminating zero' (a char coded as 0)
that denotes the end of the line. Moreover, MQL5 uses some space to store service information, i.e., a
reference to the place in memory where the string starts.
Unlike C++, no address of a string or any other variable can be obtained in MQL5. Direct memory
access is prohibited in MQL5.
A string literal is recorded in the source code as a sequence of characters embedded in double-quotes.
For example: "EURUSD" or "$". We should distinguish between strings consisting of one character, like
"$", and the same single characters, like '$'. These are different data types.
An empty string appears as "". Considering the implicit terminating zero, it consumes 2 bytes, apart
from service information.
Should it be necessary to use the double quote character inside the string, it must be preceded by the
backslash character, transforming into a control sequence, such as "Press \"OK\"".
String initialization examples are given in script MQL5/Scripts/MQL5Book/p2/TypeString.mq5.

---

## Page 55

Part 2. Programming fundamentals
55
2.2 Built-in data types
void OnStart()
{
   string h = "Hello";          // Hello
   string b = "Press \"OK\"";   // Press "OK"
   string z = "";               //
   string t = "New\nLine";      // New
                                // Line
   string n = "123";            // 123, text (not an integer value)
   string m = "very long message "
              "can be presented " 
              "by parts";
   // equivalent:
   // string m = "very long message can be presented by parts"; 
}
The string "Hello" is placed in variable h.
Text containing double quotes is written in variable b.
Variable z is initialized by an empty string. This is basically equivalent to describing z without
initialization, but there are some finer points here. Further, as the text goes, in the section of
Initialization of variables, we will get to know that uninitialized strings get a special value, NULL, unlike
"", for which, as previously stated, the memory is allocated for the terminating zero. This difference
affects the execution of string comparison operators and some others. As the story unfolds, we will
touch upon all such aspects.
Variable t will get a text that, when printed in the log using the Print function or displayed by other
methods, will be divided into 2 strings.
String "1 23" recorded in variable n is not a number, although it looks like that. There are some
functions in MQL5 to convert text into numbers and back (see section Data transformation). Moreover,
there is a separate set of functions for working with strings.
For convenience, long literals can be written in several strings, as for variable m. The general rule is as
follows: All literals up to the semicolon that marks the end of the variable description are merged by the
compiler. In such formatting, the key is not to forget to add an intervening space inside each fragment
of the string, if necessary (for instance, to separate the words in the message as in the example
above).
For strings, the summation (concatenation) operation is defined, denoted with the character '+'. We
will discuss it in the chapter dealing with expressions (see Arithmetic operations).
String characters can be read separately, referring to them as array elements (see Use of arrays): If s
is a string, then s[i] is the code of the ith character in it, type ushort.
2.2.5 Logic (Boolean) Type
Logic type is intended for storing features that only have 2 possible states: "enabled"/"disabled". Their
interface analogs are options in setup dialogs of many programs, including MetaTrader 5: Each flag may
be either enabled or disabled. Checking the states of such features allows branching the logic of the
program execution, thus the type name.

---

## Page 56

Part 2. Programming fundamentals
56
2.2 Built-in data types
Logic type is defined in MQL5 under the bool keyword and consumes 1  byte of memory. For this type,
two constants are reserved: true and false. Moreover, situations are permissible (and programmers
often make use of it), in which bool is the result of computations with integers and real numbers, value
0 being interpreted as false, and any others as true.
Back-interpretation of the bool type value as a number is supported, as well: true is considered as 1 
and false as 0.
Examples of logic type variables are given in file MQL5/Scripts/MQL5Book/p2/TypeBool.mq5.
void OnStart()
{
  bool t = true;          // true
  bool f = false;         // false
  bool x = 100;           // x = true
  bool y = 0;             // y = false
  int i = true;           // i = 1
  int j = false;          // j = 0
}
For logic type, a set of special logic operations is provided (see Logical (Boolean) Operations and
Comparison Operations).
2.2.6 Date and time
MQL5 provides a special type for storing time data datetime. As follows from its name, the values of
datetime include both the date and time. However, where necessary, they can contain only the date or
only the time of day.
Values of this type can be used in programs to monitor events, such as trading hours, news
publications, or timeouts for temporarily disabling the EA trading after bad transactions.
The datetime size in memory is 8 bytes. The internal representation of data is completely identical with
the ulong type, since the quantity of seconds elapsed since January 1 , 1 970, is stored inside. The
maximum date supported is December 31 , 3000.
The datetime constants are recorded as a literal string enclosed in single quotes, preceded by the
character 'D'. 6 fields are allocated inside the string, with the numbers for all components of date and
time in the following formats:
D'YYYY.MM.DD HH:mm:ss'
D'DD.MM.YYYY HH:mm:ss'
Here, YYYY means year, MM month, DD day, HH hours, mm minutes, and ss seconds. You can skip
either date or time. It is also possible not to specify seconds or minutes with seconds.
For the maximum permitted value of date, a special constant, DATETIME_MAX, is provided in MQL5,
equaling to the integer value 0x793406fff, which corresponds with  D"3000.1 2.31  23:59:59".
Examples of recording the values of the datetime type are shown in file
MQL5/Scripts/MQL5Book/p2/TypeDateTime.mq5.

---

## Page 57

Part 2. Programming fundamentals
57
2.2 Built-in data types
void OnStart()
{
  // WARNINGS: invalid date
  datetime blank = D'';           // blank = day of compilation
  datetime noday = D'15:45:00';   // noday = day of compilation + 15:45
  datetime feb30 = D'2021.02.30'; // feb30 = 2021.03.02 00:00:00
  datetime mon22 = D'2021.22.01'; // mon22 = 2022.10.01 00:00:00
  // OK
  datetime dt0 = 0;                      // 1970.01.01 00:00:00
  datetime all = D'2021.01.01 10:10:30'; // 2021.01.01 10:10:30
  datetime day = D'2025.12.12 12';       // 2025.12.12 12:00:00
}
The first four variables call the compiler warning about the incorrect date. In the case of blank, the
literal is completely empty. In the noday variable, there is no day. In both cases, the compiler
substitutes the compilation date in the constant. Variables feb30 and mon22 contain incorrect numbers
of the day and month. The compiler corrects them automatically, transferring the overflow into the
higher-order field (February 30 turns into March 2, while the 22nd month becomes the 1 0th month of
the subsequent year). However, it is always recommended to get rid of warnings.
Variable dt0 demonstrates the initialization of the datetime value with an integer.
Type datetime supports the set of operations inherent in integers (see Expressions). This, for instance,
allows adding a predefined quantity of seconds to the time (obtaining a moment in the future) or
computing the difference between dates.
2.2.7 Color
MQL5 has a special type for working with color. This allows the coloring of graphical objects.
To denote the type, the color keyword is used. For the color type value, 4 bytes of memory are
allocated. Its internal representation is an unsigned integer containing a color in the RGB (Red, Green,
Blue) format, that is, with separate intensity levels for red, green, and blue colors. Mixing these three
components allows getting any visible color shade. Green and red will produce yellow, red and blue will
do purple, etc.
1  byte is allocated for each component, that is, it can take values from 0 through 255. For instance,
three zeros in all components produce a black color, while three maximum values of 255 are blended
into white.
If we present color as uint in the hexadecimal notation, then the colors are distributed as follows:
0x00BBGGRR, where RR, GG, and BB are single-byte unsigned integers.
For its user's convenience, MQL5 supports a special form of literals to record color constants. Literal
represents a triplet of numbers separated by commas and enclosed in single quotes. Character 'C' is
placed before the literal. For instance, C'0,1 28,255' means a color with 0 for its red component, 1 28
for the green one, and 255 for the blue one. Hexadecimal notation of numbers can also be used:
C'0x00,0x80,0xFF'.
Besides, a long list of predefined color shades is embedded in MQL5, all starting with clr. For example,
clrMagenta, clrLightCyan, and clrYellow. They also include the primaries, of course: clrRed, clrGreen,
and clrBlue. The full list can be found in the MetaEditor Help.

---

## Page 58

Part 2. Programming fundamentals
58
2.2 Built-in data types
Below are some examples of setting colors (also available in file
MQL5/Scripts/MQL5Book/p2/TypeColor.mq5):
void OnStart()
{
  color y = clrYellow;         // clrYellow
  color m = C'255,0,255';      // clrFuchsia
  color x = C'0x88,0x55,0x01'; // x = 136,85,1 (no such predefined color)
  color n = 0x808080;          // clrGray
}
2.2.8 Enumerations
Enumerations are a group of types built in MQL5, each containing a set of named constants to describe
related concepts or properties. These constants are also referred to as enumeration elements.
For example, enumeration ENUM_DAY_OF_WEEK contains constants for all days of the week:
Identifier (ID)
Description
Value
SUNDAY
Sunday
0
MONDAY
Monday
1
TUESDAY
Tuesday
2
WEDNESDAY
Wednesday
3
THURSDAY
Thursday
4
FRIDAY
Friday
5
SATURDAY
Saturday
6
Enumeration ENUM_ORDER_TYPE describes all the order types supported in MetaTrader 5:

---

## Page 59

Part 2. Programming fundamentals
59
2.2 Built-in data types
Identifier (ID)
Description
Value
ORDER_TYPE_BUY
Market buy order
0
ORDER_TYPE_SELL
Market sell order
1
ORDER_TYPE_BUY_LIMIT
Buy Limit pending order
2
ORDER_TYPE_SELL_LIMIT
Sell Limit pending order
3
ORDER_TYPE_BUY_STOP
Buy Stop pending order
4
ORDER_TYPE_SELL_STOP
Sell Stop pending order
5
ORDER_TYPE_BUY_STOP_LIMIT
Upon reaching the order price, Buy
Limit pending order is placed at
the StopLimit price
6
ORDER_TYPE_SELL_STOP_LIMIT
Upon reaching the order price, Sell
Limit pending order is placed at
the StopLimit price
7
ORDER_TYPE_CLOSE_BY
Order for closing a position by an
opposite one
8
There are a few dozens of various enumerations. Their names are prefixed with "ENUM_". We are going
to learn them as we move through the relevant domain areas.
Each enumeration is an independent type. However, their internal representation is identical, i.e., four-
byte integer (int). Each enumeration constant is coded with one number or another, but in most cases,
the programmer does not need to remember these numbers, since the whole point of using
enumeration is exactly to replace internal representations with evident identifiers.
The compiler ensures that the enumeration value is always one of the redefined constants. Otherwise, a
warning or compilation error will occur (contextually, see the example).
This is how the ENUM_DAY_OF_WEEK enumeration appears "underneath" (script
MQL5/Scripts/MQL5Book/p2/TypeEnum.mq5).

---

## Page 60

Part 2. Programming fundamentals
60
2.2 Built-in data types
void OnStart()
{
  ENUM_DAY_OF_WEEK sun = SUNDAY;     // sun = 0
  ENUM_DAY_OF_WEEK mon = MONDAY;     // mon = 1
  ENUM_DAY_OF_WEEK tue = TUESDAY;    // tue = 2
  ENUM_DAY_OF_WEEK wed = WEDNESDAY;  // wed = 3
  ENUM_DAY_OF_WEEK thu = THURSDAY;   // thu = 4
  ENUM_DAY_OF_WEEK fri = FRIDAY;     // fri = 5
  ENUM_DAY_OF_WEEK sat = SATURDAY;   // sat = 6
  
  int i = 0;
  ENUM_DAY_OF_WEEK x = i; // warning: implicit enum conversion
  ENUM_DAY_OF_WEEK y = 1; // ok, equals to MONDAY
  ENUM_ORDER_TYPE buy = ORDER_TYPE_BUY;   // buy = 0
  ENUM_ORDER_TYPE sell = ORDER_TYPE_SELL; // sell = 1
  // ...
  
  // warning: implicit conversion
  //          from 'enum ENUM_DAY_OF_WEEK' to 'enum ENUM_ORDER_TYPE'
  //          'ENUM_ORDER_TYPE::ORDER_TYPE_SELL' will be used
  //          instead of 'ENUM_DAY_OF_WEEK::MONDAY'
  ENUM_ORDER_TYPE type = MONDAY;
  // compilation error: uncomment to reproduce
  // ENUM_DAY_OF_WEEK day = ORDER_TYPE_CLOSE_BY; // cannot convert enum
  // ENUM_DAY_OF_WEEK z = 10; // '10' - cannot convert enum
}
All constants of the days of the week are coded with numbers from 0 through 6, Sunday being the
starting point. Basically, constants should not necessarily have consecutive numbers or start with 0.
There are enumerations where this is not the case.
Please note that the same constants can mean different things in different enumeration types. For
instance, for orders ORDER_TYPE_BUY and ORDER_TYPE_SELL in the ENUM_ORDER_TYPE
enumeration, the same values (0 and 1 ) are used as for the days of week SUNDAY and MONDAY in
ENUM_DAY_OF_WEEK.
When copying the value from a simple integer variable i into the enumeration variable x, the compiler
gives a warning, since there can be a value other than the permitted constants in variable i at the
program execution stage.
In variable y, we record number 1  which means MONDAY, and the compiler considers this to be a
correct operation.
An attempt to write the constant of one enumeration into the variable of another enumeration (as
MONDAY for variable type in the example above) may cause a warning about an implicit type
conversion. This happens if the constant being written has the same value as one of the target
enumeration elements. In other words, each of the two enumerations has its own element with the
relevant value. Then the compiler performs an implicit conversion in the programmer's place
automatically, but it uses a warning to "ask" the programmer to check whether everything is going as
intended: The fact that MONDAY will be replaced with ORDER_TYPE_SELL is weird, indeed; however, we
did that intentionally here for illustrative purposes.

---

## Page 61

Part 2. Programming fundamentals
61 
2.2 Built-in data types
If the element being copied does not match by its value with any element of another enumeration, a
compilation error is generated, since an implicit conversion is impossible, such as when writing
ORDER_TYPE_CLOSE_BY in variable day.
The commented string with variable z causes a compilation error, too, since the value 1 0 does not
belong to ENUM_DAY_OF_WEEK. If the programmer is sure that, in an exotic case, there is still a need
for recording a random value in the enumeration type variable, they can use explicit typecasting.
Explicit and implicit typecasting will be discussed in the section entitled Typecasting.
MQL5 allows a programmer to declare their own applied enumerations using the keyword, enum. This
feature is described in the next section, Custom Enumerations (enum).
2.2.9 Custom enumerations
Custom enumerations are structurally based on the int type, and the principles of using them
completely coincide with what has been discussed above in the preceding section dealing with
embedded enumerations. Therefore, we are describing custom enumerations here, although, strictly
speaking, they are not embedded.
To describe your own enumeration in the MQL5 code, you will use the keyword enum. The simplest
description form is as follows:
enum name
{
  element1,
  element2,
  element3
};
This description registers in the program an enumeration type named name with brace-enclosed
comma-separated elements (their amount is only limited by the highest int value, which can be
considered as no limitations in terms of practical tasks). Identifiers element1 , element2, and element3
can be then used in the program within the context, in which they have been defined: Globally (i.e.,
outside of all functions) or inside of a function (see section Context, visibility, and lifetime of variables).
Please consider the semicolon following the closing brace. It is needed since the enumeration
description is a separate statement, and semicolons must be placed after any MQL5 statement.
By default, identifiers take constant values, starting with 0, each subsequent being 1  greater than the
preceding one. If necessary, the programmer may define a specific value for each element, after '=' to
the right of the identifier. For instance, the entry above is equivalent to this one:
enum name
{
  element1 = 0,
  element2 = 1,
  element3 = 2
};
It is permitted to specify as value only constants or expressions the compiler can compute at the
compilation stage (for more details, please see the example below).

---

## Page 62

Part 2. Programming fundamentals
62
2.2 Built-in data types
If the values are not defined for all elements, the skipped values are computed automatically based on
the nearest known (preceding) ones by adding 1 . For example,
enum name
{
  element1 = 1,
  element2,
  element3 = 10,
  element4,
  element5
};
Here, the first two elements take values 1  and 2 (computed), while those starting with the third one
take 1 0 (specified explicitly), 1 1 , and 1 2 (the last two ones are computed based on 1 0).
In script TypeUserEnum.mq5, there are some examples of describing custom enumerations.

---

## Page 63

Part 2. Programming fundamentals
63
2.2 Built-in data types
const int zero = 0; // runtime value is not known at compile time
enum
{
  MILLION = 1000000
};
enum RISK
{
  // OFF      = zero, // error: constant expression required
  LOW      = -1,
  MODERATE = -2,
  HIGH     = -3,
};
enum INCOME
{
  LOW      = 1,
  MODERATE = 2,
  HIGH     = 3,
  ENORMOUS = MILLION,
};
void OnStart()
{
  enum INTERNAL
  {
    ON,
    OFF,
  };
  // int x = LOW; // ambiguous access, can be one of
  int x = RISK::LOW;
  int y = INCOME::LOW;
}
Enumeration INTERNAL shows the possibility of describing it inside of the function and, in doing so,
limits the visibility/availability region of this type, which is useful in terms of name collisions.
Enumeration RISK shows that elements may be assigned with negative values. Commented element
OFF cannot be described due to the attempt to initialize it with a non-constant expression: In this case,
variable zero is specified there, the value of which cannot be computed by the compiler.
In enumeration INCOME, element ENORMOUS is initialized successfully by the value from the MILLION
element of the other enumeration defined above. Enumerations are created at the moment of compiling
and therefore, they are available in initialization expressions.
Enumeration with MILLION has no name, such enumerations are called anonymous. Their basic
application is to declare constants. However, named enumerations are used more often for constants,
since they allow grouping elements by their meanings.
Since there 2 enumerations defined in the example, both having elements with identical names,
specifying the LOW identifier when declaring variable x leads to the "ambiguous access" compilation

---

## Page 64

Part 2. Programming fundamentals
64
2.2 Built-in data types
error, because it is not clear the element of which enumeration is meant. Please note that identifiers
may have (and they do, in this case) different values.
To solve this issue, there is a special context operator: Two colons, "::". They help form the complete
identifier of the language element, i.e., the enumeration element, in our case: First, the enumeration
name is specified, then operator "::", and after that the element identifier. Example: RISK::LOW and
INCOME::LOW. We will get to know about all operators in the relevant section.
2.2.1 0 Void type
Type void is a special type. It means emptiness (no type) and does not consume any memory. It is only
used to describe functions that do not return any values or have any parameters. We learned an
example of such a function: OnStart in the HelloChart script in Part 1 . This will be discussed in more
detail in section Functions.
It is impossible to use type void to describe variables; however, it is the basic type in describing
references to the random objects of classes. This possibility is described in Part 3 dealing with object-
oriented programming.
2.3 Variables
In this chapter, we will learn the basic principles of working with variables in MQL5, namely those
relating to embedded data types. In particular, we will consider the declaration and definition of
variables, special features of initialization as the context requires, lifetime, and basic modifiers changing
the properties of variables. Later on, relying on this knowledge, we will extend the abilities of variables
with new custom types (unions, custom enumerations, and aliases), classes, pointers, and references.
Variables in MQL5 provide a mechanism for storing data of various types, playing an important role in
organizing program logic and operations with market information. This section includes the following
subsections:
Declaration and definition of variables:
·Variable declaration is the step of creating them in a program. In this section, we look at how to
declare and define variables, as well as how to specify their types.
Context, scope, and lifetime of variables:
·Variables can exist in different contexts and scopes, which affects their availability and lifetime.
This subsection covers these aspects, helping you understand how variables interact with your
code.
Initialization:
·Initialization of variables involves assigning them initial values. We study methods of initialization,
helping to avoid undefined program behavior.
Static variables:
·Static variables retain their values between function calls. This section explains how to use static
variables to store information between different code executions.
Constant variables:

---

## Page 65

Part 2. Programming fundamentals
65
2.3 Variables
·Constant variables represent values that do not change during program execution. This section
describes their usage and characteristics.
Input variables:
·Input variables are used in trading robots to configure strategy parameters. We will see how to use
them to create flexible and customizable trading systems.
External variables:
·External variables allow users to interact with the program as their values can be changed without
the need to modify the code. This section explains how external variables work.
2.3.1  Declaration and definition of variables
A variable is a named memory cell for storing the data of a specific type. For the program to be able to
operate a variable, the programmer must declare and/or define it in the source code. In the general
case, the terms declaration and definition mean different things regarding the program elements, while
they practically always coincide for variables. These intricacies will be covered when we get to know
about functions, classes, and special (external) variables. Here we are going to use both terms
interchangeably, along with the 'description' as a generalizing one.
It would be safe to assume that a declaration contains a description of a program element with all its
attributes necessary for being used in the program. Definition, however, contains the specific
implementation of this element, corresponding with the declaration.
Declarations allow the compiler to interconnect all the elements of the program. Based on definitions,
the compiler generates an executable code.
In the case of variables, their declaration practically always acts as their definition, since it ensures
allocating memory and interpreting their contents in accordance with their types (this is exactly an
implementation of a variable). The only exception is the declaration of variables with the word
'extern' (for more details, see section External Variables).
Only upon the description of a variable, you can use special statements to enter values into it, read
them, and refer to the variable name to move it from one part of the program into another.
In the simplest case, a statement describing a variable appears as follows:
type name;
Here, name must meet the requirements of constructing identifiers. As a type, you can specify any of
the embedded types that we have considered in the preceding section or some other custom types —
we will learn a bit later how to create them. For example, integer variable i is declared as follows:
int i;
If necessary, you can describe several variables of the same type simultaneously. In this case, their
names are specified in the statement, separated by commas.
int i, j, k;
An important factor is the place in the program, where the statement is located, which contains the
variable description. This affects the lifetime of the variable and its accessibility from various parts of
the program.

---

## Page 66

Part 2. Programming fundamentals
66
2.3 Variables
2.3.2 Context, scope, and Lifetime of variables
MQL5 belongs to programming languages that use braces to group statements into code blocks.
Recall that a program consists of blocks with statements, and one block must exist definitely. In the
script samples from Part 1 , we saw the OnStart function. The body of this function (the brace-enclosed
text following the function name) is exactly such a necessary code block.
Inside each block, the local context is formed, i.e., a region that limits the visibility and lifetime of
variables described inside it. So far we have only encountered examples where braces define the body
of functions. However, they can also be used to form compound operators, in the syntax of the
description of classes and namespaces. All these methods also define visibility regions and will be
considered in the relevant sections. At this stage, we only consider one type of local blocks, namely
those inside of functions.
Along local regions, every program also has one global context, i.e., a region with the definitions of
variables, functions, and other entities made beyond other blocks.
On the simple script side, in which the MQL Wizard has created the only void function OnStart, then
there will only be 2 regions in it: A global one and a local one (inside the OnStart function body,
although it is empty). The script below illustrates this with comments.
// GLOBAL SCOPE
void OnStart()
{
  // LOCAL SCOPE "OnStart"
}
// GLOBAL SCOPE
Please note that the global region stretches everywhere apart from function OnStart (both before and
after it). Basically, it includes everything beyond any functions (if there were many), but there is
nothing in this script, apart from OnStart.
We can describe variables, such as i, j , k, on the top of the file, and they will become global.
// GLOBAL SCOPE
int i, j, k;
void OnStart()
{
  // LOCAL SCOPE "OnStart"
}
// GLOBAL SCOPE
Global variables are created immediately upon starting an MQL program in the terminal and exist for
the entire period of program execution.
The programmer can record and read the contents of global variables from any place in the program.
It is basically recommended to describe global variables just at the top, but it is necessary. If we move
the declaration below the entire function OnStart, nothing will change basically. It will just be difficult
for other programmers to immediately make sense of the code with variables, the definitions of which
one has still to get to.
Interestingly, the OnStart function itself is declared in the global context, too. If we add another
function, it will also be declared in the global context. Recall how we created the Greeting function in

---

## Page 67

Part 2. Programming fundamentals
67
2.3 Variables
Part 1  and called it from the OnStart function. This is the effect of the function name and the method
of referencing to it (how to execute it) being known throughout the source code. Namespaces add
some niceties to it; however, we will learn them later.
A local region inside each function only belongs to it: One local region is inside OnStart, and another is
inside Greeting, which is its own and differs from both the local region of OnStart and the global one.
Variables described in the function body are called local. They are created according to their
descriptions as of calling the relevant function during the program execution. Local variables can be
only used inside the block that contains them. They are not visible or accessible from the outside.
When leaving the function, local variables are destroyed.
Example of describing local variables x, y, z inside function OnStart:
// GLOBAL SCOPE
int i, j, k;
void OnStart()
{
  // LOCAL SCOPE "OnStart"
  int x, y, z;
}
// GLOBAL SCOPE
It should be noted that pairs of braces can be used in both describing the function and other
statements and as themselves to form the internal code block. Unit nesting is unlimited.
Nested blocks are usually added to minimize the scope of variables used in a logically isolated small
code location (if it is not set by a function for one reason or another). This allows the reduction of the
probability of a false modification of the variable where it was not provided for or some undesired side
effects due to the attempt to re-purpose the same variable for various needs (it is not a good practice).
Below is a sample function where unit nesting level is 2 (if we consider the block with the function body
to be the first level), and 2 such blocks are created and will be executed consecutively.

---

## Page 68

Part 2. Programming fundamentals
68
2.3 Variables
void OnStart()
{
  // LOCAL SCOPE "OnStart"
  int x, y, z;
  
  { 
    // LOCAL SUBSCOPE 1
    int p;
    // ... use p for task 1
  }
  
  { 
    // LOCAL SUBSCOPE 2
    // y = p; // error: 'p' - undeclared identifier
    int p;    // from now 'p' is declared
    // ... use p for task 2
  }
  
  // p = x; // error: 'p' - undeclared identifier
}
Inside both blocks, variable p is described, which is used for various purposes in them. In fact, these
are two different variables, although having the same name visible inside each block.
If the variable were taken out to the initial list of the local variables of the function, it could contain
some remaining value upon exiting from the first block, thus breaking the operation of the second
block. Moreover, the programmer could occasionally involve p in something else at the very beginning
of the function, and then the side effects could take place in the first block.
Beyond either of the two nested blocks, variable p is unknown and therefore, an attempt to refer to it
from the common block of the function leads to a compilation error ("undeclared identifier").
It should also be noted that a variable can be described not at the very beginning of the block, but in its
middle or even closer to the end. Then it is defined not throughout the block, but only below its
definition. Therefore, when referring to the variable above its description, the same error will occur.
Thus, the variable scope region may differ from the context (the entire block).
Both versions of the problem are illustrated in an example: Try to include any of the strings with
statements p = x and y = p and compile the source code.
Memory is allocated for all the local variables of the function as soon as the control is passed inside the
function. However, this is not the end of their creation. Then they are initialized (initial values are set),
initialization being defined explicitly by the programmer or implicitly by the default values of the
compiler. At the same time, context is of the essence, in which the variables are described.
2.3.3 Initialization
In describing variables, there is a possibility to set the initial value; it is specified following the variable
name and symbol '=' and must correspond with the variable type or be cast to it (typecasting can be
found in the relevant section).

---

## Page 69

Part 2. Programming fundamentals
69
2.3 Variables
int i = 3, j, k = 10;
Here i and k are initialized explicitly, while j is not.
Both a constant (literal of the relevant type) and an expression (a kind of formula for calculations) can
be specified as the initial value. We will set out expressions separately. In the meantime, a simple
example:
int i = 3, j = i, k = i + j;
Here, variable j takes the same value as variable i, while variable k takes the sum of i and j. Strictly
speaking, in all three cases, we see expressions here. However, constant (3) is a special, degenerate
expression option. In the second case, the only variable name is an expression, i.e., the expression
result will be the value of this variable without any transformations. In the third case, two variables, i
and j, are accessed in the expression, the addition operation is executed with their values, and after
that, the result gets into variable k.
Since the statement containing the description of several variables is processed from left to right, the
compiler already knows the names of previous variables when analyzing yet another description.
A program usually contains many statements with variable descriptions. They are read by the compiler
in a natural top-down manner. In later initializations, names can be used taken from earlier
descriptions. Here are the same variables described by two separate statements.
int i = 3, j = i;
int k = i + j;
Variables without an explicit initialization also get some initial values, but they depend on the place
where the variable was described, i.e., on its context.
Where there is no initialization, local variables take random values at the moment of their generation:
The compiler just allocates memory for them according to the type size, while it is unknown what will
be at a specific address (various computer memory areas are often re-allocated to be used in different
programs after they have become unnecessary for those executed earlier).
It is usually suggested that working values will be entered in local variables without initialization
somewhere later in the algorithm code, such as using assignment operations we will talk about later on.
Syntactically, it is similar to initialization, since it also uses the equal sign, '=', to transfer the value
from the "structure" placed on the right of it (it can be a constant, variable, expression, or function
call, into the variable on the left. Only a variable can be to the left of '='.
The programmer should ensure that reading from the uninitialized variable only takes place upon a
meaningful value is assigned to it. Compiler gives a warning if this is not the case ("possible use of
uninitialized variable").
Everything is different with global variables.
An example of global variables is the GreetingHour input parameter of the GoodTime2 script from Part
2. The fact that the variable was described with keyword input does not affect its other properties as a
variable. We could exclude its initialization and describe it as follows:
input uint GreetingHour;
This would not change anything in the program, because global variables are implicitly initialized by the
compiler using zero if there is no explicit initialization (while we also had explicit initialization with zero
before).

---

## Page 70

Part 2. Programming fundamentals
70
2.3 Variables
Whatever the variable type is, implicit initialization is always performed by a value equivalent to zero.
For example, for a bool variable, false will be set, while for a datetime variable there will be
D'1 970.01 .01  00:00:00'. There is a special value, NULL, for strings. It is, if you like, an even
"emptier" string than empty quotes "" because there is still some memory allocated for them, where
the only terminal null character is placed.
Along with local and global variables, there is another type, i.e., static variables. The compiler initializes
them with zero implicitly, too, if the programmer has not written an explicitly initial value. They will be
considered in the next section.
Let's create a new script, VariableScopes.mq5, with examples of describing local and global variables
(MQL5/Scripts/MQL5Book/VariableScopes.mq5).
// global variables
int i, j, k;    // all are 0s
int m = 1;      // m = 1                (place breakpoint on this line)
int n = i + m;  // n = 1
void OnStart()
{
  // local variables
  int x, y, z;
  int k = m; // warning: declaration of 'k' hides global variable
  int j = j; // warning: declaration of 'j' hides global variable
  // use variables in assignment statements  
  x = n;     // ok, 1
  z = y;     // warning: possible use of uninitialized variable 'y'
  j = 10;    // change local j, global j is still 0
}
// compilation error
// int bad = x; // 'x' - undeclared identifier
It should be remembered that, at launching an MQL program, the terminal first initializes all global
variables and then calls a function that is the starting point for the programs of a relevant type. In this
case, it is OnStart for scripts.
Here, only variables i, j , k, m, n are global since they are described outside the function (in our case, we
only have one function, OnStart, which is necessary for scripts). i, j , k take the value of 0 implicitly. m
and n contain 1 .
You can run the script in the debugging mode on a step-by-step basis and make sure that the values of
variables change exactly in this manner. For this purpose, you should preliminarily set a breakpoint onto
the string with the initialization of one of the global variables, such as m. Put the text cursor onto this
string and execute Debug -> Toggle Breakpoint (F9), and the string will be highlighted with a blue sign in
the left field, which signals that the program execution will stop here if it starts working on the
debugger.
Then you should actually run the program for debugging, for which purpose execute command Debug ->
Start on real data (F5). At this moment, a new chart will open in the terminal, in which this script starts
being executed (caption "VariableScopes (Debugging)" in the upper right corner), but it suspends
immediately, and we get back to MetaEditor. We should see a picture in it as follows.

---

## Page 71

Part 2. Programming fundamentals
71 
2.3 Variables
Step-by-step debugging and viewing variables in MetaEditor
A string containing a breakpoint is now marked with an arrow sign – it is the current statement the
program is preparing to execute but has not executed yet. The current stack of the program is shown
lower left, which consists so far of only one entry: @global_initializations. You can enter expressions
lower right to monitor their real-time values. We are interested in the values of variables; therefore,
let's consecutively enter i, j , k, m, n, x, y, z (each in a separate string).
You will see further that MetaEditor automatically adds variables from the current context for viewing
(for instance, local variables and the function inputs, where statements are executed inside the
function). But now, we are going to add x, y, and z manually and in advance, just to show that they are
not defined outside the function.
Please note that, for local variables, it is written "Unknown identifier" instead of a value, because there
has not been the OnStart function block yet, where they are located. Global variables i and j will first
have zero values. Global variable k is not used anywhere and, therefore, it is excluded by the compiler.

---

## Page 72

Part 2. Programming fundamentals
72
2.3 Variables
If we execute one step of the program execution (execute the statement on the current code line)
using commands Step Into (F1 1 ) or Step Over (F1 0), we will see how variable m takes value 1 . Another
step will continue initialization for variable n, and it will also become 1 .
Here, the descriptions of global variables end and, as we know, terminal calls function OnStart upon
completion of the initialization of global variables. In this case, to step into function OnStart in the
stepwise mode, press F1 1  once again (or you can set another breakpoint in the beginning of the
OnStart function).
Local variables are initialized when the execution of the program statements reaches the code block
where they have been defined. Therefore, variables x, y, z are only created upon stepping into the
OnStart function.
When the debugger gets inside the OnStart function, with a little luck, you will be able to see that there
are really initially random values in x, y, and z. "Luck" here consists in the fact that these random
values may well be zero ones. Then it will be impossible to differ them from the implicit initialization
with zero, compiler performs for global variables. If the script is launched repeatedly, the "garbage" in
local variables will likely be different and more illustrative. They are not initialized explicitly and,
therefore, their contents may be of any kind.
In the sequence of images below, you can see the evolution of variables using the step-by-step mode of
the debugger. The current string to be executed (but not executed yet) is marked with a green arrow
on the fields with enumeration.
Step-by-step debugging and viewing variables in MetaEditor (string 23)

---

## Page 73

Part 2. Programming fundamentals
73
2.3 Variables
Step-by-step debugging and viewing variables in MetaEditor (string 24)
It is demonstrated further in the code how these variables could be used in the simplest manner in
assignment operators. The value of the global variable n is copied into the local x without any problems
since n has been initialized. However, in the string where the contents of variable y are copied to
variable z, a warning from the compiler appears, because y is local and, as of this moment, nothing has
been written in it; i.e., there is not an explicit initialization, as well as other operators that can set its
value.
Inside a function, it is permitted to describe variables with the same names as already used for global
variables. A similar situation may occur in nested local blocks if a variable is created in an internal block
with the name existing in an external block. However, this practice is not recommended, since it may
lead to logical errors. In such cases, the compiler gives a warning ("declaration hides global/local
variable").
Due to such redefining, a local variable, such as k in the example above, overlaps the homonym global
one inside the function. Although they have the same name, these are two different variables. Local k is
known inside OnStart, while global k is known everywhere apart from OnStart. In other words, any
inside-the-block operations with variable k will only affect the local variable. Therefore, upon exiting
function OnStart (as if it were not the only and core function of the script), we would discover that
global variable k is still equal to zero.
Local variable j does not only overlap global variable j but is also initialized by the value of the latter
one. In the string containing the description of j inside OnStart, the local version of j is still being
created when the initial value for it is read from the global version of j. Upon a successful definition of
local j, this name overlaps the global version, and it is the local version, to which the subsequent
changes in j belong.

---

## Page 74

Part 2. Programming fundamentals
74
2.3 Variables
At the end of the source code, we have commented on the attempt to declare one more global
variable, bad, in the initialization of which the value of variable x is called. This string causes a compiler
error since variable x is unknown beyond the OnStart function, in which it has been defined.
2.3.4 Static variables
It is sometimes necessary to describe a variable inside a function, ensuring its existence for the entire
duration of the program execution. For example, we want to count how many times this function has
been called.
Such a variable cannot be local, because then it will lose its "long memory," since it will be created
every time at calling the function and removed at exiting it. Technically, it could be described globally;
however, if the variable is only used in this function, this approach is wrong in terms of program design.
First, a global variable can accidentally be changed from any place in the program.
Second, imagine what "zoo" of variables would be made in the global region of the program if we
declare a global variable at the slightest pretext. Instead, it is recommended to declare variables in the
smallest block (if there are several nested ones), in which they are used.
Therefore, the counter of function executions should be described inside the function. This is where the
new attribute of variables helps, their static nature.
A special keyword (modifier), static, placed before the variable type in its declaration allows prolonging
its lifetime up to the entire duration of program execution, that is, makes it similar to global ones. As a
rule, a static variable is only defined locally, in one of the functions. Therefore, its visibility is limited by
the relevant code block, as in a normal local variable.
Static variables can also be described at a global level, but do not differ from the normal global ones in
any way (at least, as of writing this book). It varies from their behavior in C++: There, their visibility is
limited by the file they are described in. In MQL5, a program is assembled based on one main mq5 file
and, perhaps, some header files (see directive #include); therefore, both static and normal global
variables are available from all source files of the program.
A local static variable is created only once – at the moment when the program first steps into the
function where this variable is described. Such a variable will only be removed at unloading the
program. If a function has never been called, the local static variables described in it, if any, will never
be created.
As an example, let's modify the Greeting function from Part 1  so that it gives different greetings at
each call. Let's name the new script GoodTimes.mq5.
We will remove the input of the script GreetingHour and the parameter of the Greeting function. Inside
the Greeting function, we will describe a new static variable, counter, of integer type, with the initial
value of 0. It should be reminded that it is exactly initialization, and it will be executed only once
because the variable is static.

---

## Page 75

Part 2. Programming fundamentals
75
2.3 Variables
string Greeting() 
{
  static int counter = 0;
  static string messages[3] =
  {
    "Good morning", "Good day", "Good evening"
  };
  return messages[counter++ % 3];
}
Since we know modifier static now, it is reasonable to also use it for array messages. The matter is that
it was declared as local before, and it would be re-created every time at multiple calls of function
Greeting (and removed at exit). This is not efficient.
It should be reminded that an array is a named set of several values of the same type, available by
index specified in square brackets after the name. Much of what has been said about variables applies
directly to arrays. Further nuances of working with arrays will be covered in section Arrays.
But let's get back to our current problem. An option is chosen from the array based on the value of the
counter variable in the return statement and so far appears quite cabbalistically:
  return messages[counter++ % 3];
We have already mentioned casually the modulus operation performed using character '%' in Part 1 .
With it, we guarantee that the element index will not be able to exceed the array size: Whatever be
counter, its division modulo by 3 will either be 0 or 1 , or 2.
The same applies to structure counter++, it means adding 1  to the variable value (single increment).
It is important to note that, in this notation, incrementation will take place upon having computed the
entire expression, in this case, upon division counter % 3. This means that counting will start from zero,
i.e., initial value. There is a possibility to make an increment before computing the expression, having
written: ++counter % 3. Then counting would start from 1 . We will consider the operations of this type
in section Increment and Decrement.
Let's call the Greeting function from OnStart 3 consecutive times.
void OnStart()
{
  Print(Greeting(), ", ", Symbol());
  Print(Greeting(), ", ", Symbol());
  Print(Greeting(), ", ", Symbol());
  // Print(counter); // error: 'counter' - undeclared identifier
}
As a result, we will see the anticipated three strings with all greetings one after another in the log.
GoodTimes (EURUSD,H1)Good morning, EURUSD
GoodTimes (EURUSD,H1)Good afternoon, EURUSD
GoodTimes (EURUSD,H1)Good evening, EURUSD
If we continue calling the function, the counter will increase, and the messages will rotate.

---

## Page 76

Part 2. Programming fundamentals
76
2.3 Variables
An attempt to refer to the counter variable at the end of OnStart (commented) will not allow the code
to be compiled, since the static variable, although it continues to exist, is only available inside function
Greeting.
Please note that braces are used for both forming the code blocks and initializing arrays. You should
distinguish among their applications. Arrays will be considered in detail in the relevant section.
However, these are not all applications of braces: Using them, we will later learn how to define custom
types, structures, and classes. Static variables can also be defined inside structures and classes.
2.3.5 Constant variables
However paradoxically this appears, most programming languages support the concept of constant
variables. In MQL5, they are described by adding modifier const. It is placed in the variable description,
preceding its type, and means that the variable value cannot be changed in any way upon its
initialization by the initial value. During its entire lifetime, the variable will have the same value, i.e., a
constant.
The compiler will just prevent assigning the constant with a value: The error "constant cannot be
modified" will appear in the relevant string.
Modifier const is aimed at explicitly showing the programmer's intention not to change the relevant
variable, if a commonly known fixed value, such as the EUR index to compute the USD index, the
number of weeks in a year, etc. It is recommended to always use modifier const if you are not going to
change the variable. This helps avoid potential errors later, if the programmer themselves or somebody
from among their colleagues accidentally tries to write something else into the constant.  
For example, we can add modifier const for the messages array in the Greeting function. This does not
appear plainly useful for such a small program. However, since programs tend to grow out, any string
may sooner or later "find itself" in a much more complex software environment, such as added
statements, operation modes, etc. Therefore, it makes sense to have a plan B; particularly as it is so
simple.
string Greeting() 
{
  static int counter = 0;
  static const string messages[3] =
  {
    "Good morning", "Good day", "Good evening"
  };
  // error demo: 'messages' - constant cannot be modified
  // messages[0] = "Good night";
  return messages[counter++ % 3];
}
In the commented string, we test recording the "Good night" string into the first element of the array
(remember that numbering starts from 0). In this case, the sense of this action is just to make sure
that the compiler prevents from doing that.
As is easily seen, modifiers static and const can be combined. The order of recording them is not
important.
By the way, in MQL5, variables become constants in both using modifier const and declaring them with
the input variables of the program.

---

## Page 77

Part 2. Programming fundamentals
77
2.3 Variables
2.3.6 Input variables
When launched, all programs in MQL5 can inquire parameters from the user. The only exception is
libraries that are not executed independently, but as parts of another program (see the relevant section
to know more about Libraries).
Input parameters of MQL programs are global variables described in the code having a special modifier
of input or sinput. They become available in the dialog of program properties for the user to enter
values. We saw a description of the GreetingHour input variable in the scripts of Part 1 .
A special feature of input variables is the fact that their value cannot be changed in the program code,
i.e., it behaves like a constant.
Input variables can only be of simple built-in types or enumerations. For enumerations, you enter the
values via a drop-down list; while you use input fields in all other cases. It is not permitted to describe
as input: Arrays, structures or unions, and classes.
The developer can set the input parameter name other than the variable identifier. This name will be
shown to the user in the program properties dialog. A detailed description should be added as a sing-
string comment upon the definition of the input parameter.
input int HourStart = 0; // Start of trading (hour, including):
input int HourStop = 0;  // End of trading (hour, excluding):
This allows making the interface user-friendlier, detailed, and free of syntactic constraints imposed by
MQL5 on identifiers. Moreover, names (as well as comments) can be in your native language.
For example, MetaTrader 5 comes with the source code of indicator MQL5/Indicators/Examples/Custom
Moving Average.mq5 with input variables:
input int            InpMAPeriod = 13;        // Period
input int            InpMAShift  = 0;         // Shift
input ENUM_MA_METHOD InpMAMethod = MODE_SMMA; // Method
This description generates the properties dialog below.
Sample dialog of the MQL program properties

---

## Page 78

Part 2. Programming fundamentals
78
2.3 Variables
The maximum length of the text representation of an input variable as an identifier=value pair, including
character "=", may not exceed 255 characters (This constraint is imposed by the internal data
exchange protocols of the terminal and testing agents). This limit is especially important for string
variables since the values of other types never go beyond it. As we know, the length of an identifier is
limited to 63 characters; therefore, depending on the identifier length, 1 91 -253 characters are left for
the value of the input string variable. The entire text exceeding the combined threshold of 255 chars
may be cropped when being transferred to the tester. If a longer string has to be entered into your
MQL program, use multiple input fields (to be continued) or allow the user to specify the name of the
file, from which the text should be read.
For convenience in operating MQL programs, inputs can be combined in named blocks using keyword
group (semicolon in the group string end is not necessary).
input group "group_name"
input type identifier = value;
...
All variables with modifier input following the group description (up to the description of another group
or to the file end) are visually displayed as a nested list under the group header in the properties dialog
of the MQL program. Moreover, groups of parameters can be deployed or collapsed by a mouse click in
the strategy tester applicable to both indicators and EAs.
The sinput keyword is the abbreviation of static input, both forms being equivalent.
Variables described with modifiers sinput and static input cannot be involved in optimization. It only
makes sense to use them in Expert Advisors being the only MQL program type supporting optimization.
For more details, see the section dealing with Testing and optimizing Expert Advisors.
2.3.7 External variables
The material in this section is simultaneously complex and optional. It requires the knowledge of the
concepts that are based on the analogy to C++ and those considered hereinbelow. At the same
time, the effect of the language structure described can be achieved in another manner, while its
flexibility is a potential source of errors.
MQL5 allows describing variables as external ones. This is made using the extern keyword and is only
permitted in the global context.
For an external variable, syntax basically repeats a normal description but it additionally has the
'extern' keyword while initialization is prohibited:
extern type identifier;
Describing a variable as external means that its description is delayed and must occur later in the
source code, usually in another file (connecting files using the #include directive will be considered in
the chapter dealing with the preprocessor). Several different source files can have a description of the
same external variable, that is, those having identical types and identifiers. All such descriptions refer
to the same variable.
It is assumed that this variable will be completely described in one of the files. If the variable is not
defined anywhere in the code without the extern keyword, the "unresolved extern variable" compilation
error is returned (similar to a linker error in C++ in such cases).

---

## Page 79

Part 2. Programming fundamentals
79
2.3 Variables
Describing an external variable allows using it efficiently in the source code of a particular file. In other
words, it enables compiling a given module, although the variable is not created in this module.
Using extern in MQL5 is not so insistent as in C++ and in most cases, may be replaced by enabling a
header file with general descriptions of the variables to be declared as extern. It is sufficient to perform
these definitions conventionally. The compiler ensures adding each attached file to the source code
only once. Considering that in MQL5 a program always consists of one compilable unit mq5, there is no
C++ problem here, with the potential error of the multiple definitions of the same variable due to
enabling the header in different units.
Even an additional mq5 (not mqh) file is attached in the #include directive, it does not equally compete
with the main unit, for which compilation is launched; instead, it is considered as one of the headers.
Unlike C++, MQL5 does not allow specifying an initial value for an external variable (initialization in C++
leads to ignoring the word extern). If you try to set an initial value, you will get a compilation error
"extern variable initialization is not allowed".
Generally, describing a variable as external can be considered a kind of "soft" description: It ensures
the appearance of the variable and excludes the overriding error that would occur if the variable is
described in several files without the extern modifier.
However, this can be a source of errors. If in different header files, by coincidence, identical variables
are described for different purposes, then no keyword extern allows identifying a collision, while with
extern, the variables will become one, and the program operation logic will most likely be broken.
As external, both variables and functions can be described (they will be considered below). For
functions, describing them with the attribute as external is a rudiment (i.e., it is compiled, but does not
make any changes). The following two declarations of a function are equivalent:
extern return_type name([parameters]);
      return_type name([parameters]);
In this sense, the presence/absence of extern can only be used to stylistically distinguish between a
forward description of a function from the current unit (no extern) or from an external one (extern is
present).
You can use extern in both the mq5 unit to be compiled and header files to be attached.
Let's consider some options for using extern: They are entered in different files, i.e., main script
ExternMain.mq5 and 3 attachable files: ExternHeader1 .mqh, ExternHeader2.mqh, and
ExternCommon.mqh.
In the main file, only ExternHeader1 .mqh and ExternHeader2.mqh are attached, while we will need
ExternCommon.mqh a bit later.
// source code from mqh files will be substituted implicitly
// in the main mq5 file, instead of these directives
#include "ExternHeader1.mqh"
#include "ExternHeader2.mqh"
In header files, two conditionally useful functions are defined: In the first one, function inc for the x
variable increment, while in the second, function dec for the x variable decrement. It is variable x that is
described in both files as external:

---

## Page 80

Part 2. Programming fundamentals
80
2.3 Variables
// ExternHeader1.mqh
extern int x;
void inc()
{
   x++;
}
// -----------------
// ExternHeader2.mqh
extern int x;
void dec()
{
   x--;
}
Due to this description, each of the mqh files is compiled in a regular way. When they are included in an
mq5 file together, the entire program is compiled, too.
If the variable were defined in each file without the word extern, the re-defining error would occur in
compiling the program as a whole. If we had transferred the definition of x from header files into the
main unit, header files would have stopped being compiled (it is not a problem for somebody, perhaps;
however, in larger programs, developers like checking the compilation ability of immediate corrections
without compiling the entire project).
In the main script, we define a variable (in this case, with an initial value of 2, while if we do not specify
the value, the default 0 will be used) and call the conditionally useful functions, as well as print the x
value.
int x = 2;
   
void OnStart()
{
   inc();  // uses x
   dec();  // uses x
   Print(x); // 2
   ...
}
In file ExternHeader1 .mqh, there is the description of variable short z (without extern). A similar
description is commented upon in the main script. If we make this string active, we will get the error
mentioned before ("variable already defined"). This is done to illustrate the potential problem.
In ExternHeader1 .mqh, extern long y is described, too. At the same time, in file ExternHeader2.mqh, the
homonym external variable has another type: extern short y. If the latter description were not "moved"
into a comment preemptively, the types incompatibility error ("variable 'y' already defined with
different type") would occur here. Summary: Either types must coincide or variables must not be
external. If both options are not good, it means that there is a mistype in the name of one of the
variables.
Moreover, it should be noted that variable y is not explicitly initialized. However, the main script calls it
successfully and prints 0 in the log:

---

## Page 81

Part 2. Programming fundamentals
81 
2.3 Variables
long y;
   
void OnStart()
{
   ...
   Print(y); // 0
}
Finally, there is a possibility provided in the script to try an alternative of the external twin variables,
exemplified by the already known variable x. Instead of describing extern int x, each of the files
ExternHeader1 .mqh and ExternHeader2.mqh can include another common header, ExternCommon.mqh,
in which there is the description of int x (without extern). It becomes the only description of x in the
project.
This alternative mode of assembling the program is enabled when activating macro
USE_INCLUDE_WORKAROUND: It is in the comment at the beginning of the script:
#define USE_INCLUDE_WORKAROUND // this string was in the comment
#include "ExternHeader1.mqh"
#include "ExternHeader2.mqh"
In this configuration, particular include files will still be compilable, as well as the entire project. In a
real project, without using this method, the common mqh file would be included in ExternHeader1 .mqh
and ExternHeader2.mqh unconditionally (no USE_INCLUDE_WORKAROUND conditions). In this example,
switching between the two threads of instructions is based on USE_INCLUDE_WORKAROUND is only
needed to demonstrate both modes. For example, the simplified version of ExternHeader2.mqh should
appear as follows:
// ExternHeader2.mqh
#include "ExternCommon.mqh" // int x; now here
void dec()
{
   x--;
}
We can check in the MetaEditor log that file ExternCommon.mqh loaded only once, although it is
referenced in both ExternHeader1 .mqh and ExternHeader2.mqh.
'ExternMain.mq5'
'ExternHeader1.mqh'
'ExternCommon.mqh'
'ExternHeader2.mqh'
code generated
If the x variable is "registered" in ExternCommon.mqh, we shall not re-define it (without extern) in the
main unit since this would cause a compilation error, but we can simply assign to it the desired value at
the beginning of the algorithm.
2.4 Arrays
An array is a tool for cluster-based storing and processing the data of random types. They are
supported practically in any programming language. They are especially important in MQL5 because

---

## Page 82

Part 2. Programming fundamentals
82
2.4 Arrays
they represent a convenient method of arranging serial data relevant to trading tasks. Quotes, readings
of indicators, account trading history with orders and transactions, and news are all examples of serial
data, that is, the sequences of time-varying values.
The array can be considered a container variable: It can contain a predefined quantity of values of the
same type, which are identified by both their name and index (position number).
In this section, we are going to consider the common syntax of describing arrays and calling them,
exemplified by embedded data types. In the subsequent parts of this book, with acquiring information
on how to extend the system of types due to the object-oriented technology, we will use arrays in
conjugation with them to get new opportunities.
2.4.1  Array characteristics
Before giving an account of the syntactic particulars of declaring arrays in MQL5 and practices of
working with them, let's consider some basic concepts of constructing the arrays.
The core characteristic of an array is the number of dimensions. In a one-dimension array, its elements
are placed one by one, like a row of soldiers, and just one number (index) is sufficient to refer to them.
Bar-by-bar prices of opening a financial instrument to the given history depth can be saved in such an
array.
In a two-dimensional array, its elements diverge in two logically perpendicular directions, forming a kind
of a square (or rectangular, in a general case), two indices being required for each element, i.e., one in
each dimension. Such an array could be used to store price quads (Open, High, Low, and Close) for
each history bar. Bar numbers would be counted with the first dimension, while the second one is used
for numbers from 0 through 3, denoting one of the price types.
A three-dimensional array is the equivalent of a cube (or, more strictly in terms of geometry, right-
angled parallelepiped) with three axes. Continuing the example with the array of bar-by-bar prices, we
could add to it the third dimension responsible for iterating financial instruments from the Market
Watch.
For each dimension, the array has a certain length (size) setting the range of possible indexes. If
history is supposed to be loaded for 1 ,000 bars and 1 0 instruments, we would get an array sized 1 ,000
elements in the first dimension, 4 elements in the second one (OHLC), and 1 0 in the third one.
The product of sizes in all dimensions provides the total number of the array elements; in our case, it is
40,000. In MQL5, it may not exceed 21 47483647 (maximum for int).
It is already difficult to imagine a solid shape for a 4-dimensional array because we live in a 3D world.
However, MQL5 permits the creation of arrays having up to four dimensions.
It should be noted that you can always use a one-dimensional array instead of a multidimensional one
with a random number of dimensions, including more than 4. This is just a matter of arranging the
recomputing of several indexes into a continuous one. For example, if a two-dimensional array has 1 0
columns (dimension 1 , axis X) and 5 rows (dimension 2, axis Y), it can be transformed into a one-
dimensional array with the same quantity of elements, i.e., 50. In this case, the element index will be
obtained by the following formula:
index = Y * N + X
Here, N is the number of elements in the first dimension, in our case, 1 0; it is the size of each row; Y is
the row number (0..4); and X is the column number (0..9) in the row.

---

## Page 83

Part 2. Programming fundamentals
83
2.4 Arrays
Sizes across dimensions are another characteristic that separates an array from a variable. Thus, the
number of dimensions and size in each dimension must be specified in some manner in the description,
along with the array name and data type (see the following section).
You should distinguish between the size of a variable (array element) in bytes and that of an array as
the number of elements in it. Theoretically, the full array size in terms of memory it consumes must be
the product of the size of one element (depending on the data type) and the number of elements.
However, this formula does not always work in practice. Particularly, since strings may have different
lengths, it is quite difficult to evaluate the memory volume consumed by a string array.
According to the memory allocation method, arrays can be dynamic or fixed-size.
A fixed-size array is described in the code with exact sizes in all dimensions. It is impossible to resize it
later. However, practical tasks often occur, in which the amount of data to be processed is contingent
and therefore, it is desirable to resize the array during the algorithm operation. Dynamic arrays exist
for this particular purpose. As we will see further, they are described without specifying the first-
dimension size and can then be "stretched" or "compacted" using the special MQL5 API functions.
MQL5 Documentation uses ambiguous terminology that names fixed-size array static. This concept is
also used for the 'static' modifier that can be applied to the array. If such an array is declared
dynamic, then it is simultaneously non-static in terms of memory allocation and static in terms of the
'static' modifier. To exclude ambiguousness, the static character in this book will only mean the
declaration attribute.
Along with dynamic and fixed-size arrays, there are special arrays in MQL5 to store quotes and the
buffers of technical indicators. Such arrays are named timeseries arrays since their indexes correspond
with timing. In fact, these arrays are one-dimensional and dynamic. However, unlike other dynamic
arrays, the terminal itself allocates memory for them. We will consider them in the sections dealing
with timeseries and indicators.
2.4.2 Description of arrays
Array description inherits some features of variable descriptions. To start with, we should note that
arrays may be global and local, based on the place of their declaration. Similarly to variables, modifiers
const and static can also be used in describing an array. For a one-dimension fixed-size array, the
declaration syntax appears as follows:
type static1D[size];
Here, type and static1 D denote the type name of elements and the array identifier, respectively, while
size in square brackets is a size-defining integer constant.
For multidimensional arrays, several sizes must be specified, according to the quantity of dimensions:
type static2D[size1][size2];
type static3D[size1][size2][size3];
type static4D[size1][size2][size3][size4];
Dynamic arrays are described in a similar manner, except that a skip is made in the first square
brackets (before using such an array, the required memory volume must be allocated for it using the
ArrayResize function, see the section dealing with dynamic arrays).

---

## Page 84

Part 2. Programming fundamentals
84
2.4 Arrays
type dynamic1D[];
type dynamic2D[][size2];
type dynamic3D[][size2][size3];
type dynamic4D[][size2][size3][size4];
For fixed-size arrays, initialization is permitted: Initial values are specified for the elements after the
equal sign, as a comma-separated list, the entire list being enclosed in braces. For example:
int array1D[3] = {10, 20, 30};
Here, a 3-sized integer array takes the values of 1 0, 20, and 30.
With an initialization list, there is no need to specify the array size in square brackets (for the first
dimension). The compiler will assess the size automatically by the list length. For example:
int array1D[] = {10, 20, 30};
Initial values can be both constants and the constant expressions, i.e., formulas the compiler can
compute during compilation. For example, the following array is filled with the number of seconds in a
minute, hour, day, and week (representation as formulas is more illustrative than 86400 or 604800):
int seconds[] = {60, 60 * 60, 60 * 60 * 24, 60 * 60 * 24 * 7};
Such values are usually designed as a preprocessor macro in the code beginning, and then the name of
this macro is inserted everywhere where it is necessary in the text. This option is described in the
section related to the Preprocessor.
The number of initializing elements may not exceed the array size. Otherwise, the compiler will give the
error message, "too many initializers". If the quantity of values is smaller than the array size, the
resting elements are initialized by zero. Therefore, there is a brief notation to initialize the entire array
by zeros:
int array2D[2][3] = {0};
Or just empty braces:
int array2D[2][3] = {};
It works regardless of the number of dimensions.
To initialize multidimensional arrays, the lists must be nested. For example:
int array2D[3][2] = {{1, 2}, {3, 4}, {5, 6}};
Here, the first-dimension size of the array is 3; therefore, two commas frame 3 elements inside the
external braces. However, since the array is two-dimensional, each of its elements is an array, in turn,
the size of each being 2. This is why each element represents a list in braces, each list containing 2
values.
Supposing, we need a transposed array (the first size is 2, and the second one is 3), then its
initialization will change:
int array2D[2][3] = {{1, 3, 5}, {2, 4, 6}};
We can skip one or more values in the initialization list, if necessary, having marked their places with
commas. All skipped elements will also be initialized by zero.

---

## Page 85

Part 2. Programming fundamentals
85
2.4 Arrays
int array1D[3] = {, , 30};
Here, the first elements will be equal to 0.
The language syntax permits placing a comma after the last element:
string messages[] =
{
  "undefined",
  "success",
  "error",
};
This simplifies adding new elements, especially for multi-string entries. Particularly, if we forget to
enter a comma before the newly added element in a string array, the old and the new strings will turn
out to be fused within one element (with the same index), while no new element will appear. Moreover,
some arrays may be generated automatically (by another program or by macros). Therefore, the
unified appearance of all elements is natural.
"Heap" and "Stack"
 With arrays that can potentially be large, it is important to make the distinction between global
and local location in memory. 
Memory for global variables and arrays is distributed within the 'heap', i.e., free memory available
to the program. This memory is not practically limited by anything, apart from the physical
characteristics of your computer and operating system. The name of 'heap' is explained by the fact
that differently sized memory areas are always either allocated or deallocated by the program,
which results in the free areas being randomly scattered within the entire bulk. 
Local variables and arrays are located in the stack, i.e., a limited memory area preliminarily
allocated for the program, especially for local elements. The name of 'stack' derives from the fact
that, during the algorithm execution, the nested calls of functions take place, which accumulate
their internal data according to the "piled-up" principle: For instance, OnStart is called by the
terminal, a function from your applied code is called from OnStart, then your other function is called
from the previous one, etc. At the same time, when entering each function, its local variables are
created that continue being there when the nested function is called. It creates local variables, too,
which get onto the stack somewhat over the preceding ones. As a result, a stack usually contains
some layers of the local data from all functions that had been activated on the path to the current
code string. Not until the function being on the top of the stack is completed, its local data will be
removed from there. Generally, the stack is a storage that works according to the FILO/LIFO (First
In Last Out, Last In First Out) principle.
 
Since the stack size is limited, it is recommended to create only local variables in it. However,
arrays can be quite large to exhaust the entire stack very soon. At the same time, the program
execution is completed with an error. Therefore, we should describe arrays at a global level as
static (static) or allocate memory for them dynamically (this is also done from the heap).
2.4.3 Using arrays
Values are written to and read from the array elements using a similar syntax and specifying the
required indices in square brackets. To put a value into an element, we will use the assignment
operation '='. For example, to replace the value of the 0th element of a one-dimensional array:

---

## Page 86

Part 2. Programming fundamentals
86
2.4 Arrays
array1D[0] = 11;
Indexing starts with 0. The index of the last element is equal to the quantity of elements minus 1 . Of
course, we can use as an index both a constant and any other expression that can be reduced to the
integer type (for more details on expressions, see the following chapter), such as an integer variable, a
function call, or an element of another array with integers (the indirect addressing).
int index;
// ... 
// index = ... // assign an index somehow
// ...
array1D[index] = 11;
For multidimensional arrays, indexes must be specified for all dimensions.
array2D[index1][index2] = 12;
Permitted integer types exclude long and ulong for indices. If we try to use the value of a "long integer"
as an index, it will be implicitly converted into int, wherefore the compiler gives the warning "possible
loss of data due to type conversion."
Reading access to the array elements is arranged according to the same principle. For example, this is
how an array element can be printed in the log:
Print(array2D[1][2]);
In script GoodTimes, we have already seen the description of the local static array messages with the
strings of greetings (inside the Greeting function) and the use of its elements in the return operator.
string Greeting() 
{
  static int counter = 0;
  static const string messages[3] = // description
  {
    "Good morning", "Good day", "Good evening" // initialization
  };
  return messages[counter++ % 3];   // using
}
When executing return, we read the element that has the index defined by the expression: counter++
% 3. Division modulo 3 (denoted as '%') ensures that counter increased every time increased by 1  will
be forced to the range of the correct values of indices: 0, 1 , or 2. If there were not modulo divisions,
the index of the requested element would exceed the array size, starting from the 4th call of this
function. In such cases, the program execution time error occurs ("array out of range"), and it is
unloaded from the chart.
MQL5 API includes universal functions for many operations with arrays: Allocating memory (for
dynamic arrays), filling, copying, sorting, and searching in arrays are all considered in the section
Working with Arrays. However, we are presenting one of them now: ArrayPrint allows the printing of the
array elements in the log in a convenient format (considering dimensions).
Script Arrays.mq5 demonstrates some examples of describing arrays, and the results are printed in the
log. We will consider manipulations with the elements of arrays later, upon having studied loops and
expressions.

---

## Page 87

Part 2. Programming fundamentals
87
2.4 Arrays
void OnStart()
{
  char array[100];      // without initialization
  int array2D[3][2] =
  {
    {1, 2},             // illustrative formatting
    {3, 4},
    {5, 6}
  };
  int array2Dt[2][3] =
  {
    {1, 3, 5},
    {2, 4, 6}
  };
  ENUM_APPLIED_PRICE prices[] =
  {
    PRICE_OPEN, PRICE_HIGH, PRICE_LOW, PRICE_CLOSE
  };
  // double d[5] = {1, 2, 3, 4, 5, 6}; // error: too many initializers
  ArrayPrint(array);    // printing random "garbage" values
  ArrayPrint(array2D);  // showing the 2D array in the log
  ArrayPrint(array2Dt); // a "transposed" appearance of the same data 2D
  ArrayPrint(prices);   // getting to know the values of the price enumeration elements
}
One of the log entry options is represented below.
[ 0]   0   0   0   0   0   0   0   0   0   0   0   0 -87 105  82 119   0
       0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0
[34]   0   0   0 -32  -3  -1  -1   7   0   0   2   0   0   0   0   0   0
       0   2   0   0   0   0   0   0   0 -96 104  82 119   0   0   0   0
[68]   0   0   3   0   0   0   0   0  -1  -1  -1  -1   0   0   0   0 100
      48   0   0   0   0   0   0   0   0   0   0   0   0   0   0
    [,0][,1]
[0,]   1   2
[1,]   3   4
[2,]   5   6
    [,0][,1][,2]
[0,]   1   3   5
[1,]   2   4   6
2 3 4 1
The array named array does not have any initialization and therefore, memory allocated for it may
contain random values. Values will change at each script run. It is recommended to always initialize
local arrays, just in case.
Arrays array2D and array2Dt are printed in the log in an illustrative form, as matrices. It is in no way
linked to the fact that we have formatted the initialization lists in the source code in the same manner.
The prices array has the type of the embedded enumeration ENUM_APPLIED_PRICE. Basically, arrays
can be of any type, including structures, function pointers, and other things that we are going to
consider. Since enumerations are based on the int type, the values are displayed by digits, not by the

---

## Page 88

Part 2. Programming fundamentals
88
2.4 Arrays
names of elements (to obtain the name of a specific element of the enumeration, there is the function
EnumToString, but its mode is not supported in ArrayPrint).
The string with the d array description contains an error: Entity of initial values exceeds the array size.
2.5 Expressions
Expressions are essential elements of any programming language. Whatever applied idea underlies an
algorithm, it is eventually reduced to data processing, that is, to computations. The expression
describes computing some result from one or more predefined values. The values are called operands,
while the actions performed with them are denoted by operations or operators.
As operators that allow manipulating with operands, independent characters or their sequences are
used in expressions, such as '+' for addition or '*' for multiplication. They all form several groups, such
as arithmetic, bitwise, comparison, logic, and some specialized ones.
We have already used expressions in the previous sections of this book, such as to initialize variables. In
the simplest case, the expression is a constant (literal) that is the only operand, while the computation
result is equal to the operand value. However, operands can also be variables, array elements, function
call results (for which the function is called directly from the expression), nested expressions, and other
entities.
All operators substitute (return) their result into the parent expression, directly into the place where
there were operands, which allows combining them making quite complex hierarchic structures. For
example, in the following expression, the result of multiplying variables b by c is added to the value of
variable a, and then the value obtained will be stored in variable v:
v = a + b * c;
In this section, we consider the general principles of constructing and computing various expressions,
as well as the standard set of operators supported in MQL5 for the built-in types. Later on, in the part
dealing with OOP, we will know how operators can be reloaded (redefined) for custom types, i.e.,
structures and classes, which will allow us to use objects in expressions and perform nonstandard
actions with them.
2.5.1  Basic concepts
Before proceeding to the specific groups of operators, we should introduce some basic concepts that
are inherent in all operators and affect their applicability and behavior in a particular context.
First of all, by the quantity of operands required, operators can be unary and binary. As is clear from
the names, unary ones process one operand, while binary operators process two. In the case of binary,
the operator is always placed between operands. Among unary ones, there are operators that must be
put before the operand and those to be placed after it. For example, the unary minus ('-') operator
allows reversing the sign of the value:
int x = 10;
int y = -x;  // -10
At the same time, there is a binary operator for subtraction using the same character, '-'.

---

## Page 89

Part 2. Programming fundamentals
89
2.5 Expressions
int z = x - y; // 10 - -10 -> 20
Choosing a correct operator (action) by the compiler in a specific context is determined by the context
of using it in the expression.
Each operator is assigned priority. It determines the order, in which operators will be computed in
complex expressions where there are multiple operators. Higher-priority operators are computed as the
first, while the lowest-priority ones as the last. For instance, in the expression 1  + 2 * 3 there are two
operations (addition and multiplication) and three operands. Since multiplication has a priority higher
than that of addition, the product of 2 * 3 will be found first, and then it will be added to one.
Later we will provide the full table of operations with priorities.
Additionally, each operator is characterized by the associativity. It can be left or right and determines
the order, in which the successive operators having the same priority are executed. For example,
expression 1 0 - 7 - 1  can purely theoretically be computed in two ways:
• Subtract 7 from 1 0 and then subtract 1  from the resulting 3, which gives 2; or
• Subtract 1  from 7, which gives 6, and then subtract 6 from 1 0, resulting in 4.
In the first case, computations were performed from left to right, which corresponds with the left
associativity; since the subtraction operation is left-associative, indeed, the first answer is correct.
The second option of computations corresponds with the right associativity and won't be used.
Let's consider another example where there are priority and associativity involved simultaneously: 1 1  +
5 * 4 / 2 + 3. Both types of operations, i.e., addition and multiplication, are executed from left to right.
If the priorities were not different, we would get 35, although 24 is the correct answer. Changing
associativity for the right would give us 1 4.
To explicitly redefine priorities in expressions, parentheses can be used, for instance: (1 1  + 5) * 4 / (2 +
3). What is enclosed in parentheses is computed earlier, and the intermediate result is substituted in
the expression to be used in other operations. Groups in parentheses can be nested. For more details,
please see section Grouping with Parentheses.
A right-associative operator can be exemplified by the unary operator of logic negation, '!'. Essentially,
its task is to make true from false, and vice versa. Like with other unary operators, associativity means
in this context, what side of the operator the operand must be placed. Symbol '!' is placed before the
operand, i.e., the operand is to the right.
int x = 10;
int on_off = !!x;  // 1
In this case, logic negation is performed twice: first time regarding variable x (right '!') and the second
time regarding the result of the preceding negation (left '!'). Such double negation allows transforming
any nonzero value into 1  due to converting into bool and back.
The final table of operations will also show associativity.
Finally, the last but not the least fine point in processing expressions is the order of computing the
operands. It should be distinguished from the priority that belongs to the operation, not operands. The
order of computing the operands of binary operations is not defined explicitly, which gives the compiler
space to optimize the code and enhance its efficiency. The compiler only guarantees that operands will
be computed before executing the operation.

---

## Page 90

Part 2. Programming fundamentals
90
2.5 Expressions
There is a limited set of operations, for which the operand evaluation order is defined. Particularly, for
logic AND ('&&') and OR ('| | ') it is from left to right, and the right part may be omitted if it does not
affect anything due to the value of the left part. But as far as the ternary conditional operator '?:' goes,
the order is even more intricate, since either one or another branch will be calculated upon computing
the first conditions, depending on its trueness. See further sections for more details.
Operand evaluation order is illustrated by the situation where there are several function calls in the
expression. For instance, let 4 functions be used in the expression:
a() + b() * c() - d()
Priority and associativity rules will only be used for the intermediate results of calling these functions,
while the calls themselves can be generated by the compiler in any order it "considers to be necessary"
based on the source code features and compiler settings. For example, functions b and c involved in
multiplication may be called in the order of [b(), c()] or, vice versa, [c(), b()]. If the functions during
being executed may affect the same data, their state will be ambiguous upon the expression
computation.
A similar problem can be seen when working with arrays and increment operators (see Increment and
Decrement).
int i = 0;
int a[5] = {0, 1, 2, 3, 4};
int w = a[++i] - a[++i];
Depending on whether the left or the right difference operand will be computed as the first, we can get
-1  (a[1 ] - a[2]) or +1  (a[2] - a[1 ]). Since the MQL5 compiler is ever-improving, there is no guarantee
that the current result (-1 ) will be retained in the future.
To avoid potential issues, it is recommended not to use an operand repeatedly, if it has already been
modified in the same expression.
In all expressions, there can usually be operands of different types. This leads to the need to cast them
to a certain common type, before performing any actions with them. If there are no explicit typecasts,
MQL5 performs the implicit conversion where necessary. Besides, conversion rules are different for
different type combinations. Explicit and implicit typecasting is discussed in the relevant section.
2.5.2 Assignment operation
Expression calculation results must usually be stored somewhere. The assignment operator denoted by
'=' is intended for this purpose in the language. The name of a variable or an array element is placed to
the left of it, in which the result must be stored, while the expression (in fact, the formula for
computation) is to the right.
We have already used this operator for the initialization of variables, which is executed only once,
during creating them. However, assignment allows changing the values of variables in the course of the
algorithm for an arbitrary number of times. For example:

---

## Page 91

Part 2. Programming fundamentals
91 
2.5 Expressions
int z;
int x = 1, y = 2;
z = x;
x = y;
y = z;
Variables x and y were initialized by values 1  and 2, whereupon the auxiliary third variable z and three
assignments were used to exchange values x and y.
The assignment operator, like all operators, returns its result into the expression. This enables writing
the assignments in a sequence.
int x, y, z;
x = y = z = 1;
Here, 1  will first be assigned to variable z, then to variable y, and finally to variable x. Obviously, this
operator is right-associative, because the value being assigned drifts from right to left in the expression.
We can use the assignment as a part of an expression. But, since its priority is lower than those of all
other operators (except for the "comma" one, see Priorities of Operations), it must be enclosed in
parentheses (for more details, please see the section on Grouping with parentheses). This aspect
enables situations where mistypes, such as '=' instead of '==', in expressions lead to not executing the
statements as intended. See the example of such behavior in the section dealing with statement if.
The assignment operator imposes certain limitations on what can be to the left of '=' and what to the
right of it. In programming, these entities aiming to simplify storing are entitled precisely: LValue and
RValue (based on Left and Right).
LValue and RValue
 LValue represents an entity, for which memory is allocated and, therefore, a value can be written
in it. Variable and array elements are the known examples of LValue. Upon having studied OOP, we
will get to know another representative of this category: Object, in which the assignment operator
can be reloaded. A mandatory element of LValue is the presence of an identifier.
 
It should be considered that variables and arrays may be described with the keyword const, and
then they cannot act as LValue, because the modification of constants is prohibited.
 
RValue is a temporary value used in an expression, such as a literal or value returned due to a
function call or due to computing a fragment of the expression.
 
Category LValue is of expansive nature, i.e., falling within it allows placing the relevant object to the
left of '=' but does not prohibit using it, on par with RValue, to the right of '='.
 
Category RValue, over again, is of a limiting nature, i.e., any RValue may only be to the right of '='.
 
As a certain LValue element is used to the right of '=', its identifier, in fact, denotes its current
contents placed into the expression formula.
 
However, if an element of LValue is used to the left of '=', its identifier indicates a memory address
(cell) where the new value (expression computation result) should be written.
 
Different operators have different limitations regarding whether they can be used for the operands

---

## Page 92

Part 2. Programming fundamentals
92
2.5 Expressions
of LValue or RValue. For example, increment '++' and decrement '--' operators (see Increment and
Decrement) may only be used with LValue.
Here are some examples of what is and is not allowed to do with assignment operators (script
ExprAssign.mq5):
// description of variables
const double cx = 123.0;
int x, y, a[5] = {1};
string s;
// assignment
a[2] = 21;       // ok
x = a[0] + a[1] + a[2]; // ok
s = Symbol();    // ok
cx = 0;          // const variable may not be changed
                 // error: 'cx' - constant cannot be modified
5 = y;           // 5 — this number (literal)
                 // error: '5' - l-value required
x + y = 3;       // to the left of RValue (expression computation result)
                 // error: l-value required
Symbol() = "GBPUSD"; // to the left of RValue with the function call result  
                     // error: l-value required
The compiler returns an error of breaking the operator use rules.
2.5.3 Arithmetic operations
Arithmetic operations include 5 binary ones, i.e., addition, subtraction, multiplication, division, and
division modulo, and 2 unary ones, i.e., plus and minus. Symbols used for each of those operations are
given in the table below.
In the column containing examples, e1  and e2 are arbitrary subexpressions. Associativity is marked
with 'L' (left to right) and 'R' (right to left). The number in the first column can be considered as
precedence of executing the operations.
P
Symbols
Description
Example
A
2
+
Unary plus
+e1 
R
2
-
Unary minus
-e1 
R
3
*
Multiplication
e1  * e2
L
3
/
Division
e1  / e2
L
3
%
Division modulo
e1  % e2
L
4
+
Addition
e1  + e2
L
4
-
Subtraction
e1  - e2
L
Order in the table corresponds with decreasing the priorities: Unary plus and minus are calculated
before multiplication and division, while the latter ones, in turn, before addition and subtraction.

---

## Page 93

Part 2. Programming fundamentals
93
2.5 Expressions
double a = 3 + 4 * 5; // a = 23
In fact, unary plus does not have any effect in calculations, but can be used for a better visualization of
the expression. Unary minus reverses the sign of its operand.
Arithmetic operations are used for numeric types or those that can be cast to them. The calculation
result is an RValue. In computation, the storage locations of integer operands are often extended up to
the "largest" of the integers used or to int (if all integer types were of a smaller size), as well as cast to
a common type. More details can be found in the section on Typecasting.
bool b1 = true;
bool b2 = -b1;
In this example, variable b1  "expands" to the int type with value 1 . Sign reversing gives -1 , which in the
reverse typecasting to bool gives true (because -1  is not zero). Using logic type in arithmetic
computations is not welcome.
Dividing integers gives an integer, that is, the fractional part, if any, is omitted. It can be checked using
the script ExprArithmetic.mq5.
int a = 24 / 7;      // ok: a = 3
int b = 24 / 8;      // ok: b = 3
double c = 24 / 7;   // ok: c = 3 (!)
Although variable c is described as double, there are integers in the expression to initialize it; therefore,
the division performed is an integer. To perform a division with a fractional part, at least one operand
must be of real type (the second one will also be cast to it).
double d = 24.0 / 7; // ok: d = 3.4285714285714284
Operator '%' calculates the remainder of integer division (it is only applicable to two operands of
integer type).
int x = 11 % 5;   // ok: x = 1
int y = 11 % 5.0; // no real number can be used
                  // error: '%' - illegal operation use
Where operands have different signs, operators '*' and '/' give a negative number. The following rules
apply to operator '%':
• if the divisor of operator '%' is negative, the sign "escapes"; and
• if the dividend of operator '%' is negative, the result is negative;
This is easy to check using the alternative calculation of division modulo: m % n = m - m / n * n. It
should be kept in mind that division m / n for integers will be rounded; therefore, m / n * n is not equal
to m, in the general case.
In section Characteristics of Arrays, we delved into the idea that a multidimensional array could be
represented by a one-dimensional one due to recalculating the indices of their elements. We also
provided the formula to obtain an index through in a one-dimensional array by the coordinates (column
number X and row number Y at the string length of N) of the two-dimensional array.
index = Y * N + X
Operation '%' allows us to perform a more convenient backward calculation, i.e., find X and Y by the
index-through:

---

## Page 94

Part 2. Programming fundamentals
94
2.5 Expressions
Y = index / N
X = index % N
If an unpresentable result NaN (Not A Number, such as infinity, square root of a negative number, etc.)
was obtained at some stage during calculating the expression, all subsequent operations with it will also
produce a NaN. It can be distinguished from a normal number using the MathIsValidNumber function
(see Mathematical Functions).
double z = DBL_MAX / DBL_MIN - 1; // inf: Not A Number
Here, it is subtracted from the NaN (obtained from division) and gives the NaN again.
Addition operation is defined for strings and performs the concatenation, i.e., combining them.
string s = "Hello, " + "world!"; // "Hello, World!"
Other operations are prohibited for strings.
2.5.4 Increment and decrement
Increment and decrement operators allow writing the increase or decrease of an operand by 1  in a
simplified manner. They most frequently occur inside loops to modify indexes when accessing to arrays
or other objects supporting enumeration.
The increment is denoted by two consecutive pluses: '++'. Decrement is denoted by two consecutive
minuses: '--'.
There are two types of such operators: Prefix and postfix.
Prefix operators, as the name implies, are written before operand (++x, --x). They change the operand
value, and this new value is involved in the further calculations of the expression.
Postfix operators are written after operand (x++, x--). They substitute the copy of the current operand
value in the expression and then change its value (the new value does not get into the expression).
Simple examples are given in the script ExprIncDec.mq5.
int i = 0, j;
j = ++i;       // j = 1, i = 1
j = i++;       // j = 1, i = 2
Postfix form may be useful for more compact writing of expressions combining a reference to the
preceding value of the operand and its side modification (two separate statements would be required to
make an alternative record of the same). In all other cases, it is recommended to use the prefix form
(it does not create a temporary copy of the "old" value).
In the following example, the sign is reversed in the array elements consecutively, until the zeroth
element is found. Moving through the array indices is ensured by postfix increment k++ inside the loop
while. Due to postfix, expression a[k++] = -a[k] first updates the kth element and then increases k by
1 . Then the assignment result is checked for not being equal to zero (!= 0, see the following section).
int k = 0;
int a[] = {1, 2, 3, 0, 5};
while((a[k++] = -a[k]) != 0){}
// a[] = {-1, -2, -3, 0, 5};
The table below shows the increment and decrement operators in order of priority:

---

## Page 95

Part 2. Programming fundamentals
95
2.5 Expressions
P
Symbols
Description
Example
A
1
++
Postfix increment
e1 ++
L
1
--
Postfix decrement
e1 --
L
2
++
Prefix increment
++e1 
R
2
--
Prefix decrement
--e1 
R
All increment and decrement operations have a priority higher than arithmetic operations. Prefixes are
of a lower priority than postfixes. In the following example, the "old" value of x is summed up with the
value of y, upon which x is incremented. If the prefix priority were higher, the increment of y would be
performed, upon which the new value, 6, would be summed up with x, and we would get z = 6, x = 0
(previous).
int x = 0, y = 5;
int z = x+++y; // "x++ + y" : z = 5, x = 1
2.5.5 Comparison operations
As the name implies, these operations are intended for comparing two operands and returning a logic
feature, true or false, depending on the condition to hold in the comparison.
The table below gives all comparison operations and their properties, such as symbols used, priorities,
examples, and associativity.
P
Symbols
Description
Example
A
6
<
Less
e1  < e2
L
6
>
Greater
e1  > e2
L
6
<=
Less than or equal
e1  <= e2
L
6
>=
greater than or equal
e1  >= e2
L
7
==
Equal
e1  == e2
L
7
!=
Not equal
e1  != e2
L
The principle of each operation is to compare two operands using the criterion from the column
containing its description. For example, entry "x < y" means checking whether "x is lesser than y".
Correspondingly, the comparison result will be true if x is really lesser than y, and false in all other
cases.
Comparisons work for the operands of any type (for different types, typecasting is performed).
Considering the left associativity and the return of the bool type result, constructing a sequence of
comparisons does not work so obviously. For example, a hypothetic expression to check whether the
value y lies between the values of x and z, could seemingly appear as follows:

---

## Page 96

Part 2. Programming fundamentals
96
2.5 Expressions
int x = 10, y = 5, z = 2;
bool range = x < y < z;   // true (!)
However, such an expression is processed in a different manner. Even the compiler distinguishes it by
the warning: "unsafe use of type 'bool' in operation".
Due to the left associativity, the left condition x < y is checked first, and its result is substituted as a
temporary value of the bool type into the expression that goes as follows: b < z. Then the value of z is
compared to true or false in the temporary variable b. To check whether y ranges between x and z, you
should use two comparison operations combined with the logic operation AND (it will be considered in
the next section).
int x = 10, y = 5, z = 2;
bool range = x < y && y < z;   // false
When using the comparing for equality/inequality, the features of the operand types shall be
considered. For instance, floating-point numbers often contain "approximate" values after calculations
(we considered the accuracy of representing double and float in the section Real Numbers). For
example, the sum of 0.6 and 0.3 is not strictly 0.9:
double p = 0.3, q = 0.6;
bool eq = p + q == 0.9;        // false
double diff = p + q - 0.9;     // -0.000000000000000111
The difference makes 1 *1 0-16, but it is sufficient for the comparison operation to return false.
Therefore, real numbers should be compared for equality/inequality using the greater-/less-then
operators for their difference and acceptable deviation that is sorted out manually, based on the
features of the computation, or a universal one is taken. Recall that for double and float, the embedded
accuracy constants, DBL_EPSILON and FLT_EPSILON, are defined, valid for the value of 1 .0. They
must be scaled to compare other values. In script ExprRelational.mq5, one of the possible realizations
of function isEqual is presented to compare real numbers, which considers this aspect.
bool isEqual(const double x, const double y)
{
   const double diff = MathAbs(x - y);
   const double eps = MathMax(MathAbs(x), MathAbs(y)) * DBL_EPSILON;
   return diff < eps;
}
Here we use the function of obtaining an absolute unsigned value (MathAbs) and the highest of the two
values (MathMax). They will be described in the section Mathematical Functions of Part 4. The absolute
difference between the parameters of function isEqual is compared to the calibrated tolerance in
variable eps using operation '<'.
This function cannot be used to compare with absolute zero, anyway. For this purpose, you can use the
following approach (it will probably require some adaptation to your specific needs):
bool isZero(const double x)
{
   return MathAbs(x) < DBL_EPSILON;
}
Strings are compared lexicographically, i.e., letter by letter. The code of each character is compared
to the code of the character in the same position of the second string. Comparison is performed until a

---

## Page 97

Part 2. Programming fundamentals
97
2.5 Expressions
difference in the codes is found or one of the strings ends. The string ratio will be equal to that of the
first differing characters, or a longer string will be considered greater than the shorter one. Remember
that upper- and lowercase letters have different codes, and strange enough, uppercase ones have
smaller codes than the lowercase ones.
An empty string "" (in fact, it stores one terminal 0) is not equal to the special value of NULL which
means no string.
bool cmp1 = "abcdef" > "abs";     // false, [2]: 's' > 'c'
bool cmp2 = "abcdef" > "abc";     // true,  by length
bool cmp3 = "ABCdef" > "abcdef";  // false, by case
bool cmp4 = "" == NULL;           // false
Moreover, to compare strings, MQL5 provides some functions that will be described in the section
Working with Strings.
In comparing for equality/inequality, it is not recommended to use bool constants: true or false. The
matter is that, in expressions like v == true or v == false, operand v can be interpreted intuitively as a
logical type, while in fact, it is a number. As it is known, zero value is considered false in numbers, while
all others are interpreted as true (we often want to use it as an indication of some result being present
or absent). However, in this case, typecasting goes backward: true or false are "expanded" to a
numeric type v and actually become equal to 1  and 0, respectively. Such a comparison will have a
result other than the expected one (for example, comparison 1 00 == true will turn out to be false).
2.5.6 Logical operations
Logical operations perform computations on logical operands and return a result of the same type.
P
Symbols
Description
Example
A
2
!
Logical NOT
!e1 
R
1 1 
&&
Logical AND
e1  && e2
L
1 2
| | 
Logical OR
e1  | |  e2
L
Logical NOT transforms true into false and false into true.
Logical AND is equal to true if both operands are equal to true.
Logical OR is equal to true if at least one operand is equal to true.
Operators AND and OR always compute operands from left to right and, if possible, use the
computational shortcut. If the left operand is equal to false, then operator AND skips the second
operand, because it does not affect anything — the result is already false. If the left operand is equal
to true, then operator OR skips the second operand for the same reason, since the result will, in any
case, be equal to true.
This is often used in programs to prevent from errors in the second (and subsequent) operands. For
example, we can hedge ourselves against the error of accessing a non-existing array element:

---

## Page 98

Part 2. Programming fundamentals
98
2.5 Expressions
index < ArraySize(array) && array[index] != 0
Here we use the built-in function ArraySize that returns the array length. Only if index is smaller than
the length, the element with this index is read and compared with zero.
Checking by contraries, using '| | ' is also used, for example:
ArraySize(array) == 0 || array[0] == 0
The condition is true immediately if the array is null. And only if there are elements, the additional
check for the contents will continue.
If the expression consists of multiple operands combined by logical OR, then with the first true (if any)
the total result of true will be obtained immediately. However, if operands are combined by logical AND,
then with the first false the total result of false will be obtained immediately.
Of course, you can combine different operations within one expression, considering their different
priority: Negation is executed first, then the AND-related conditions, and in the end the OR-related
conditions. If another sequence is required, it must be explicitly specified using parentheses.
For example, the following expression without parentheses, A && B | |  C && D, is in fact equivalent to:
(A && B) | |  (C && D). For the logical OR to be executed as the first, it should be enclosed in
parentheses: A && (B | |  C) && D. For more details on using parentheses, see section Grouping with
Parentheses.
Simple examples are given in script ExprLogical.mq5 to check logical operations in practice.
int x = 3, y = 4, z = 5;
bool expr1 = x == y && z > 0;  // false, x != y, z does not matter
bool expr2 = x != y && z > 0;  // true,  both conditions are complied with
bool expr3 = x == y || z > 0;  // true,  it is sufficient that z > 0
bool expr4 = !x;               // false, x must be 0 to get true
bool expr5 = x > 0 && y > 0 && z > 0; // true, all 3 are complied with
bool expr6 = x < 0 || y > 0 && z > 0; // true, y and z are sufficient
bool expr7 = x < 0 || y < 0 || z > 0; // true, z is sufficient
In the string of calculating expr6, the compiler gives the warning: "Check operator precedence for
possible error; use parentheses to clarify precedence".
Logical operations '&&' and '| | ' should not be mixed with bitwise operations '&' and '| ' (considered in
the next section).
2.5.7 Bitwise operations
Sometimes you may need to process numbers at the bit level. For this purpose, there is a group of
bitwise operations applicable to integer types.
All symbols and descriptions of bitwise operators are provided with their associativity and in order of
their priority in the table below.

---

## Page 99

Part 2. Programming fundamentals
99
2.5 Expressions
P
Symbols
Description
Example
A
2
~
Bitwise complement (inversion)
~e1 
R
5
<<
Shift to the left
e1  << e2
L
5
>>
Shift to the right
e1  >> e2
L
8
&
Bitwise AND
e1  & e2
L
9
^
Bitwise exclusive OR
e1  ^ e2
L
1 0
|
Bitwise OR
e1  |  e2
L
Of the entire group, only the bitwise complement operation '~' is unary, while all others are binary.
In all cases, if the operand size is less than int/uint, it is preliminarily extended to int/uint by adding 0
bits into higher order. Based on the operand type being signed/unsigned, a high-order bit may affect
the sign.
Standard Windows application, Calculator, may help understand the representation of numbers at the
bit level. If you select the Programmer operation mode in the View menu, the groups of toggle buttons
will appear in the program to select representing the number in a hexadecimal (Hex), decimal (Dec),
octal (Oct), or binary (Bin) form. It is the latter one that shows bits. Moreover, you can select the
number size: 1 , 2, 4, and 8 bytes. The buttons allow executing all the operations considered: Not ('~'),
And ('&'), Or ('| '), Xor ('^'), Lsh ('<<'), and Rsh ('>>').
 
Since the Calculator uses signed numbers, negative values may appear when toggling to the decimal
mode (remember that the high-order bit is interpreted as a sign). For convenient analysis, it is
reasonable to exclude the minus that appears, for which purpose it is necessary to select the size in
bytes one grade higher. For example, to check the values within the range up to 255 (uchar, unsigned
one-byte integer), you should select 2 bytes (otherwise, only decimal values through 1 27 will be
positive, while the others will be displayed in the negative region).
Bitwise complement creates a value, in which the 0-bit is in the place of all 1 -bits, while 1 -bit is in the
place of 0-bits. For example, the negation of a byte with all zero bits gives a byte with all 1  bits.
Number 50 appears in the bitwise format as '001 1 001 0' (byte). Its inversion gives '1 1 001 1 01 '.
Unity represented hexadecimally is 0x0001  (for short). Inversion of these bits gives 0xFFFE (see script
ExprBitwise.mq5).
short v = ~1;  // 0xfffe = -2
ushort w = ~1; // 0xfffe = 65534
Bitwise AND checks each bit in both operands and in the positions where two set bits (1 ) are found,
stores the 1 -bit into the result. In all other cases (where there is only a set bit in one operand or they
are reset in both places), the 0-bit is written in the result.
Bitwise OR writes 1 -bits into the result if they are on the positions where there is a set bit in at least
one of two operands.
Bitwise exclusive OR writes in the result the 1 -bits on the positions where there is a set bit in either the
first or second operand, but not in both at the same time. The binary representation of two numbers, X
and Y, and the results of bitwise operations with them are shown below.

---

## Page 100

Part 2. Programming fundamentals
1 00
2.5 Expressions
X       10011010   154
Y       00110111    55
X & Y   00010010    18
X | Y   10111111   191
X ^ Y   10101101   173
When writing complex expressions from several different operators, use grouping with parentheses in
order not to become confused with priorities.
Shift operations move bits to the left ('<<') or right ('>>') by the quantity of bits, defined in the second
operand that must be a non-negative integer. As a result, left (for '<<') or right (for '>>') bits are
dropped, since they go beyond the memory cell boundaries. With the left shift, the relevant number of
0 bits are added on the right. With the right shift, either 0 bits are added on the left (if the operand is
unsigned) or the sign bit is reproduced (if the operand is signed). In the latter case, 0 bits are added on
the left for positive numbers and 1  bits for negative ones; i.e., the sign retains.
short q = v << 5;  // 0xffc0 = -64
ushort p = w << 5; // 0xffc0 = 65472
short r = q >> 5;  // 0xfffe = -2
ushort s = p >> 5; // 0x07fe = 2046
In the example above, the initial left shift "destroyed" the high-order bits of variable p, while the
subsequent right shift by the same quantity of bits filled them with zeros, which led to decreasing the
value from 0xffc0 to 0x07fe.
Shift size (quantity of bits) must be less than that of the operand type (considering its potential
extension). Otherwise, all initial bits will get lost.
Shifting by 0 bits leaves the number unchanged.
Bitwise operations '&' and '| ' should not be mixed with logical operations '&&' and '| | ' (considered in
the preceding section).
2.5.8 Modification operations
Modification that is also called compound assignment allows combining within one operator arithmetic
or bitwise operations with normal assignment.

---

## Page 101

Part 2. Programming fundamentals
1 01 
2.5 Expressions
P
Symbols
Description
Example
A
1 4
+=
Addition with assignment
e1  += e2
R
1 4
-=
Subtraction with assignment
e1  -= e2
R
1 4
*=
Multiplication with assignment
e1  *= e2
R
1 4
/=
Division with assignment
e1  /= e2
R
1 4
%=
Division modulo with assignment
e1  %= e2
R
1 4
<<=
Left shift with assignment
e1  <<= e2
R
1 4
>>=
Right shift with assignment
e1  >>= e2
R
1 4
&=
Bitwise AND with assignment
e1  &= e2
R
1 4
| =
Bitwise OR with assignment
e1  | = e2
R
1 4
^=
Bitwise AND/OR with assignment
e1  ^= e2
R
These operators execute the relevant action for operands e1  and e2, whereupon the result is stored in
e1 .
An expression like e1  @= e2 where @ is any operator from the table is approximately equivalent to e1 
= e1  @ e2. The word "approximately" emphasizes the presence of some subtle aspects.
First, if the place of e2 is occupied by an expression with an operator having a lower priority than that
of @, e2 is still calculated before that. That is, if the priority is marked with parentheses, we will get e1 
= e1  @ (e2).
Second, if there are side modifications of variables in expression e1 , they are made only once. The
following example demonstrates this.
int a[] = {1, 2, 3, 4, 5};
int b[] = {1, 2, 3, 4, 5};
int i = 0, j = 0;
a[++i] *= i + 1;           // a = {1, 4, 3, 4, 5}, i = 1
                           // not equivalent!
b[++j] = b[++j] * (j + 1); // b = {1, 2, 4, 4, 5}, j = 2
Here, arrays a and b contain identical elements and are processed using index variables i and j. At the
same time, the expression for array a uses operation '*=', while that for array b uses the equivalent.
Results are not equal: Both index variables and arrays differ.
Other operators will be useful in problems with bit-level manipulations. Thus, the following expression
can be used to set a specific bit into 1 :
ushort x = 0;
x |= 1 << 10;
Here, shift 1  ('0000 0000 0000 0001 ') is made by 1 0 bits to the left, which results in obtaining a
number with one set 1 0th bit ('0000 01 00 0000 0000'). Bitwise OR operation copies this bit into
variable x.

---

## Page 102

Part 2. Programming fundamentals
1 02
2.5 Expressions
To reset the same bit, we will write:
x &= ~(1 << 10);
Here, the inversion operation is applied to 1  shifted by 1 0 bits to the left (which we saw in the
preceding expression), which results in all bits changing their value: '1 1 1 1  1 01 1  1 1 1 1  1 1 1 1 '. Bitwise
AND operation resets the zeroed bits (in this case, one) in variable x, while all other bits in x remain
unchanged.
2.5.9 Conditional ternary operator
Conditional ternary operator allows describing in a single expression two calculation options, based on a
certain condition. The operator syntax is as follows:
condition ? expression_true : expression_false
The logical condition must be specified in the first operand 'condition'. This can be an arbitrary
combination of comparison operations and logical operations. Both branches must be present.
If the condition is true, expression expression_ true will be computed, while if it is false, the
expression_ false will be computed.
This operator guarantees that only one of the expressions expression_ true and expression_ false will be
executed.
Types of the two expressions must be identical, otherwise, there will be an attempt to implicitly
typecast them.
Please note that the result of processing expressions in MQL5 always represents an RValue (in C++, if
only LValues are in expressions, then the result of the operator will also be LValue). Thus, the following
code is compiled well in C++, but gives an error in MQL5:
int x1, y1; ++(x1 > y1 ? x1 : y1); // '++' - l-value required
Conditional operators can be nested, that is, it is permitted to use another conditional operator as a
condition or either branch (expression_ true or expression_ false). At the same time, it cannot be always
clear what the conditions relate to (if parentheses are not used to explicitly denote grouping). Let's
consider examples from ExprConditional.mq5.
int x = 1, y = 2, z = 3, p = 4, q = 5, f = 6, h = 7;
int r0 = x > y ? z : p != 0 && q != 0 ? f / (p + q) : h; // 0 = f / (p + q)
In this case, the first logical condition represents comparison x > y. If it is true, the branch with variable
z is executed. If it is false, the additional logical condition p != 0 && q != 0 is checked, with two
expression options, as well.
Below are some more operators, in which logical conditions are written uppercase, while computation
options are lowercase. For simplicity, they all are made variables (from the example above). In reality,
each of the three components may be a richer expression.
For each string, you can track how the result is obtained, which has been shown in the comment.

---

## Page 103

Part 2. Programming fundamentals
1 03
2.5 Expressions
bool A = false, B = false, C = true;
int r1 = A ? x : C ? p : q;                              // 4
int r2 = A ? B ? x : y : z;                              // 3
int r3 = A ? B ? C ? p : q : y : z;                      // 3
int r4 = A ? B ? x : y : C ? p : q;                      // 4
int r5 = A ? f : h ? B ? x : y : C ? p : q;              // 2
Since the operator is right-associative, the compound expression is analyzed from right to left, that is,
the rightmost structure with three operands combined by '?' and ':' becomes the operand of the
external condition written to the left. Then, considering this substitution, the expression is analyzed
from right to left again, and so on, until the final complete upper-level structure '?:' is obtained.
Therefore, the expressions above are grouped as follows (parentheses denote the implicit interpretation
of the compiler; but such parentheses could be added into expressions to visualize the source code,
which approach is actually recommended).
int r0 = x > y ? z : ((p != 0 && q != 0) ? f / (p + q) : h);
int r1 = A ? x : (C ? p : q); 
int r2 = A ? (B ? x : y) : z; 
int r3 = A ? (B ? (C ? p : q) : y) : z; 
int r4 = A ? (B ? x : y) : (C ? p : q); 
int r5 = (A ? f : h) ? (B ? x : y) : (C ? p : q); 
For variable r5, the first condition A ? f : h computes the logical condition for the subsequent expression
and therefore, is transformed into bool. Since A is equal to false, the value is taken from variable h. It is
not equal to 0; therefore, the first condition is considered true. This results in the actuating branch (B ?
x : y), from which the value of variable y is returned, since B is equal to false.
There must be all 3 components (a condition and 2 alternatives) in the operator. Otherwise, the
compiler will generate the error "unexpected token":
// ';' - unexpected token
// ';' - ':' colon sign expected
int r6 = A ? B ? x : y; // lack of alternative
In the compiler language, a token is an indivisible fragment of the source code, having its independent
meaning or purpose, such as type, identifier, punctuation character, etc. The entire source code is
divided by the compiler into a sequence of tokens. Signs of the operators considered are tokens, too. In
the code above, there are two symbols '?', and there must be two symbols ':' matching with them, but
it is the only one. Therefore, the compiler "says" that the statement end symbol ';' is premature and
"inquires" what exactly is deficient: "colon sign expected".
Since the conditional operator has a very low priority (1 3 in the full table, see Priorities of Operations),
it is recommended to enclose it in parentheses. This makes it easier to avoid situations where the
operands of a conditional operator could be "caught" by the neighboring operations having higher
priorities. Fir instance, if we need to calculate the value of a certain variable w via the sum of two
ternary operators, a straightforward approach might appear as follows:
int w = A ? f : h + B ? x : y;                           // 1
This will work differently than we thought. Due to the higher priority, the sum h + B is considered as a
single expression. Considering its parsing from right to left, this sum appears as a condition and is cast
to the bool type, which is even warned by the compiler as "expression not boolean". Compiler
interpretation can even be visualized by parentheses:

---

## Page 104

Part 2. Programming fundamentals
1 04
2.5 Expressions
int w = A ? f : ((h + B) ? x : y);                       // 1
To solve the problem, we should place parentheses in our own way.
int v = (A ? f : h) + (B ? x : y);                       // 9
Deep nesting of conditional operators impacts adversely on the code understandability. Nesting levels
exceeding two or three should be avoided.
2.5.1 0 Comma
Operator comma that is explicitly denoted as ',' is placed between two expressions computed
independently from left to right. In other words, this operator does not perform any actions itself but
just allows specifying the sequence of two or more expressions within a statement.
Expressions placed right-hand in the sequence can use the results of computing the left-hand
expressions, since they have already been processed.
The operator result is the result of the rightmost expression. The operator has the lowest priority.
Currently, using the operator in MQL5 is limited by the header of the for statement.
Example:
for(i=0,j=99; i<100; i++,j--) 
   Print(array[i][j]);
Let's repeat the key aspects of the comma operator in MQL5:
Order of evaluation:
·Expressions are processed from left to right. Thus, the expressions on the right can use the results
of the expressions on the left since they have already been processed.
Result and priority:
·The result of the comma operator is the value of the rightmost expression. It's important to note
that the comma operator has the lowest priority, meaning that other operators in the expression
may have higher priorities.
2.5.1 1  Special operators sizeof and typename
sizeof
The sizeof operator returns the size of its operand in bytes. Operator syntax: sizeof(x), where x can be
a type or an expression. The expression is not computed in this case, since operator sizeof is executed
at the compilation stage and, in fact, a constant is substituted in its place in the expression.
For fixed-size arrays, the operator returns the total amount of the allocated memory, that is, the
multiplication of the number of elements in all dimensions by the type size in bytes. For dynamic
arrays, it returns the size of an internal structure storing the array properties.
Let's give some examples with explanations (ExprSpecial.mq5).

---

## Page 105

Part 2. Programming fundamentals
1 05
2.5 Expressions
double array[2][2];
double dynamic1[][1];
double dynamic2[][2];
Print(sizeof(double));                           // 8
Print(sizeof(string));                           // 12
Print(sizeof("This string is 29 bytes long!"));  // 12
Print(sizeof(array));                            // 32
Print(sizeof(array) / sizeof(double));           // 4 (quantity of elements)
Print(sizeof(dynamic1));                         // 52
Print(sizeof(dynamic2));                         // 52
The result to be printed in the log is marked in the comments.
Type double takes up 8 bytes. The size of the string type is 1 2. These 1 2 bytes store the service
information we mentioned in the section dealing with type string. This memory is allocated for any
string (even uninitialized). Please note that a string containing a 29-character text is also sized 1 2.
This is because both an empty string and a string with some contents have an internal structure
intended for storing a reference to memory. To obtain the text length, we should use the StringLen
function.
Fixed-size array size is really computed as the multiplication of the number of elements (2*2=4) by the
double type size (8), a total of 32. As a consequence, an expression like sizeof(array) / sizeof(double)
allows finding out the entity of elements in it.
For dynamic arrays, the internal structure size is 52 bytes. Differences in the descriptions of arrays
dynamic1  and dynamic2 do not affect this value.  
Operator sizeof is especially useful to get the sizes of classes and structures.
typename
Operator typename returns a string with the name of the parameter passed to it, which can be a type
or an expression. For arrays, along with the data type keyword, a tag is printed as a pair of parentheses
(or several ones, depending on the array dimensionality).
Print(typename(double));                         // double
Print(typename(array));                          // double [2][2]
Print(typename(dynamic1));                       // double [][1]
Print(typename(1 + 2));                          // int
For custom types, such as classes, structures, and others (that we will consider in Part 3), the type
name follows the entity category, such as "class MyCustomType". Moreover, for constants, the "const"
modifier will be added to the string description.
Therefore, to know the short type name consisting of one word, use macro TYPENAME from the
attached file TypeName.mqh.
It can be necessary to learn the type name in the so-called templates that can generate from the
source code similar realizations for different types defined in the parameters of templates.

---

## Page 106

Part 2. Programming fundamentals
1 06
2.5 Expressions
2.5.1 2 Grouping with parentheses
In the preceding sections, we have already seen more than a few times that some expressions can
cause unexpected results due to the priorities of operations. To explicitly change the computation
order, we should use parentheses. Part of the expression enclosed in them gets a higher priority as
compared to the environment, without regard to default priorities. Pairs of parentheses can be nested,
but it is not recommended to make more than 3-4 nesting levels. It is better to divide the too complex
expressions into several simpler ones.
Script ExprParentheses.mq5 shows the evolution of placing parentheses within one expression. The
initial intent for it is to set the bit in variable flags using the left-shift operation '<<'. The bit number is
taken from variable offset if it is not zero, or otherwise, as 1  (remember that numbering starts with
zero). Then the obtained value is multiplied by coefficient. No need to search for any applied sense in
this example. However, more sophisticated structures can occur, too.
int offset = 8;
int coefficient = 10, flags = 0;
int result1 = coefficient * flags | 1 << offset > 0 ? offset : 1;     // 8
int result2 = coefficient * flags | 1 << (offset > 0 ? offset : 1);   // 256
int result3 = coefficient * (flags | 1 << (offset > 0 ? offset : 1)); // 2560
The first version, without parentheses, seems suspicious even to the compiler. It gives a warning that
we have already known: "expression not boolean". The matter is that the ternary conditional operator
has the lowest priority of all operators here. For this reason, the entire left part before '?' is considered
its condition. Inside the condition, calculations are in the following order: Multiplication, bitwise shift,
"more than" comparison, and bitwise OR, which results in an integer. Of course, it can be used as true
or false, but it is desired to "communicate" such intentions to the compiler using explicit typecasting. If
it is absent, the compiler considers the expression suspicious, and not in vain. The first calculation
results in 8. It is incorrect.
Let's add parentheses around the ternary operator. The warning of the compiler will disappear.
However, the expression is still computed wrongly. Since the priority of multiplication is higher than
that of bitwise OR, variables coefficient and flags are multiplied before the bit mask is used, which is
obtained by shifting to the left. The result is 256.
Finally, having added another pair of parentheses, we will get the correct result: 2560.
2.5.1 3 Priorities of operations
Here is the full table of all operations in the order of their priorities.
P
Symbols
Description
Example
A
0
::
Scope resolution
n1  :: n2
L
1
()
Grouping
(e1 )
L
1
[]
Index
[e1 ]
L
1
.
Dereferencing
n1 .n2
L
1
++
Postfix increment
e1 ++
L

---

## Page 107

Part 2. Programming fundamentals
1 07
2.5 Expressions
P
Symbols
Description
Example
A
1
--
Postfix decrement
e1 --
L
2
!
Logical NOT
!e1 
R
2
~
Bitwise complement (inversion)
~e1 
R
2
+
Unary plus
+e1 
R
2
-
Unary minus
-e1 
R
2
++
Prefix increment
++e1 
R
2
--
Prefix decrement
--e1 
R
2
(type)
Typecasting
(n1 )
R
2
&
Taking the address
&n1 
R
3
*
Multiplication
e1  * e2
L
3
/
Division
e1  / e2
L
3
%
Division modulo
e1  % e2
L
4
+
Addition
e1  + e2
L
4
-
Subtraction
e1  - e2
L
5
<<
Shift to the left
e1  << e2
L
5
>>
Shift to the right
e1  >> e2
L
6
<
Less
e1  < e2
L
6
>
Greater
e1  > e2
L
6
<=
Less than or equal
e1  <= e2
L
6
>=
Greater than or equal
e1  >= e2
L
7
==
Equal
e1  == e2
L
7
!=
Not equal
e1  != e2
L
8
&
Bitwise AND
e1  & e2
L
9
^
Bitwise exclusive OR
e1  ^ e2
L
1 0
|
Bitwise OR
e1  |  e2
L
1 1 
&&
Logical AND
e1  && e2
L
1 2
| | 
Logical OR
e1  | |  e2
L
1 3
?:
Conditional ternary
c1  ? e1  : e2
R
1 4
=
Assignment
e1  = e2
R

---

## Page 108

Part 2. Programming fundamentals
1 08
2.5 Expressions
P
Symbols
Description
Example
A
1 4
+=
Addition with assignment
e1  += e2
R
1 4
-=
Subtraction with assignment
e1  -= e2
R
1 4
*=
Multiplication with assignment
e1  *= e2
R
1 4
/=
Division with assignment
e1  /= e2
R
1 4
%=
Division modulo with assignment
e1  %= e2
R
1 4
<<=
Left shift with assignment
e1  <<= e2
R
1 4
>>=
Right shift with assignment
e1  >>= e2
R
1 4
&=
Bitwise AND with assignment
e1  &= e2
R
1 4
| =
Bitwise OR with assignment
e1  | = e2
R
1 4
^=
Bitwise AND/OR with assignment
e1  ^= e2
R
1 5
,
Comma
e1  , e2
L
As we have seen, square brackets are used to specify the indices of array elements and, therefore,
have one of the highest priorities.
Along with operators that have been considered earlier, there are some still unknown ones here.
We will learn the scope resolution operator '::' within object-oriented programming (OOP). We will also
need the dereferencing operator '.' at the same time. Identifiers of types (classes) and their properties,
not expressions, act as their operands.
Address-taking operator '&' is intended to pass the function parameters by referencing and to obtain
the object addresses in OOP. In both cases, the operator is applied to a variable (LValue).
Explicit typecasting operations will be considered in the next chapter.
2.6 Type conversion
In this section, we will consider the concept of type conversion, limiting ourselves to built-in data types
for now. Later, after studying OOP, we will supplement it with the nuances inherent in object types.
Type conversion in MQL5 is the process of changing the data type of a variable or expression. MQL5
supports three main types of type conversion: implicit, arithmetic, and explicit.
Implicit type conversion:
·Occurs automatically when a variable of one type is used in a context that expects another type.
For example, integer values can be implicitly converted to real values.
Arithmetic type conversion:
·Arises during arithmetic operations with operands of different types. The compiler attempts to
maintain maximum accuracy but warns about potential data loss. For instance, in integer division,
the result is converted to a real type.

---

## Page 109

Part 2. Programming fundamentals
1 09
2.6 Type conversion
Explicit type conversion:
·Gives the programmer control over type conversion. It is done in two forms: C-style ((target)) and
"functional" style (target()). It is used when you need to explicitly instruct the compiler to perform
a conversion between types, for example, when rounding real numbers or when successive type
conversions are required.
Understanding the differences between implicit, arithmetic, and explicit type conversion is crucial for
ensuring the correct execution of operations and avoiding data loss. This knowledge helps programmers
effectively utilize this mechanism in MQL5 development.
2.6.1 . Implicit type conversion
Type conversion occurs automatically if one type is used at some point in the source code, but another
is expected, and there are conversion rules between them. Such conversion is called an implicit type
conversion and may not always correspond to the programmer's intent. In addition, some conversion
operations have side effects, and the compiler, not knowing whether their use is intentional, highlights
the corresponding lines of code with warnings. To solve these problems, there is an explicit type
conversion syntax (see Explicit type casting).
We have already seen several rules for implicit type conversion while studying types and variables.
Specifically, if a value of type other than boolean is assigned to a bool variable, then the value 0 is
regarded as false, and all the rest as true. In the more general case, all expressions that assume the
presence of logical conditions are converted to type bool. For example, the first operand of a ternary
conditional operator is always converted into a bool.
But if a value of type bool is assigned to a numeric type, then true becomes 1 , and false becomes 0.
When a real number is assigned to an integer type variable, the fractional part is discarded (the
compiler issues a warning). When an integer, on the other hand, is assigned to a variable of real type,
precision can be lost (the compiler also issues a warning). We have already talked about this in the
sections on Integer numbers and Real numbers.
If we have integer and floating point numbers, everything is converted to floating point numbers of the
maximum size used (usually double, unless you explicitly specify float or the numeric literal has a suffix
'f', for example1 234.56789f).
For integers of different sizes, there are also conversion rules: they expand if necessary, which means
that they increase to the size of the largest integer type used in the expression (see Arithmetic type
conversions).
In addition to expressions, we often need to implicitly convert types during initialization and
assignment, when the types to the right and left of the '=' sign do not match. The same conversion
rules apply when passing values through function parameters and returning results from functions (for
further details please see the Functions section).
Considering the above, a large number of conversions can be performed in one line of code. If this
causes compiler warnings, it's a good idea to make sure the conversion is intentional and eliminate
warnings by inserting an explicit type conversion.

---

## Page 110

Part 2. Programming fundamentals
1 1 0
2.6 Type conversion
short s = 10;
long n = 10;
int p = s * n + 1.0;
In this example, when performing a multiplication, the type of the variable s is extended to the type of
the second operand long and an intermediate result of type long is obtained. Because the constant 1 .0
is of type double, the result of the product is converted to double before addition. The overall result is
also of type double; however, the variable p is of type int and therefore an implicit conversion from
double to int is performed.
The special types datetime and color are processed according to the rules of integers with lengths of 8
and 4 bytes, respectively. But for date and time, there is a stricter limit on the maximum value -
32535244799, which corresponds to D'3000.1 2.31  23:59:59'.
Most types can be implicitly converted to and from strings, but the results are not always adequate, so
the compiler issues warnings "implicit conversion from 'number' to 'string'" and "implicit conversion
from 'string' to 'number'" so that the programmer can check them. For example, converting a string to
an integer allows the string to contain only digits and '+'/'-' characters at the beginning. Converting
from a string to a real allows, in addition to numbers, the presence of a dot '.' and notation with
"exponent" ('e' or 'E', e.g. +1 .2345e-1 ). If an unsupported character (for example, a letter) is
encountered in the string, the rest of the string is discarded in full.
For example, the string date and time ("2021 .1 2.1 2 00:00") cannot be assigned without losses to a
variable of type datetime because datetime is an integer (number of seconds). In this case, reading the
number from the string will end when the first point is reached, i.e. the number will get the value 2021 .
This number of seconds corresponds to the 34th minute of the year 1 970.
There are special functions for such conversions (see section Data Transformation).
The only direction of implicit and explicit type conversion that is forbidden is from string to bool. The
compiler in such cases shows the error message "cannot implicitly convert type 'string' to 'bool'".
Examples from this chapter are provided in TypeConversion.mq5.
2.6.2. Arithmetic type conversions
In arithmetic calculation and comparison expressions, values of different types are often used as
operands. To process them correctly, it is necessary to bring the types to a certain "common
denominator". The compiler attempts to do this without the programmer's intervention unless the
programmer has specified explicit conversion rules (see Explicit type conversion). In this case, the
compiler, whenever possible, tries to preserve the maximum precision when it comes to numbers. In
particular, it produces an increase in the capacity of integer numbers and the transition from integer to
real numbers (if they are involved).
Integer expansion implies conversion of bool, char, unsigned char, short, unsigned short to int (or
unsigned int if int isn't big enough to store specific numbers). Large values can be converted to long
and unsigned long.
If the type of the variable is not able to store the result of the type that was obtained when the
expression was evaluated, the compiler will issue a warning:

---

## Page 111

Part 2. Programming fundamentals
1 1 1 
2.6 Type conversion
double d = 1.0;
int x = 1.0 / 10; // truncation of constant value
int y = d / 10;   // possible loss of data due to type conversion
The expression to initialize the variables x and y contains the real number 1 .0, so the other operands
(constant 1 0 in this case) are converted to double, and the result of division will also be of type double.
However, the type of variables is int, and therefore an implicit conversion to it takes place.
Calculation 1 .0 / 1 0 is done by the compiler during compilation and therefore it gets a constant of type
double (0.1 ). Of course, in practice, it is unlikely that the initializing constant will exceed the size of the
receiving variable. Therefore, the compiler warning "truncation of constant value" can be considered
exotic. It just shows the problem in the most simplified way.
However, as a result of variable-based calculations, similar data loss can also occur. The second
compiler warning we see here ("possible loss of data due to type conversion") occurs much more
frequently. Moreover, the loss is possible not only when converting from real type to integer, but also
vice versa.
double f = LONG_MAX; // truncation of constant value
long m1 = 1000000000;
f = m1 * m1;         // possible loss of data due to type conversion
As we know, type double cannot accurately represent large integers (although its range of valid values
is much larger than long).
Another warning we might encounter due to type mismatch: "integral constant overflow".
long m1 = 1000000000;
long m2 = m1 * m1;                 // ok: m2 = 1000000000000000000
long m3 = 1000000000 * 1000000000; // integral constant overflow
                                   // m3 = -1486618624
Integer constants in MQL5 have type int, so the multiplication of million by million is performed taking
into account the range of this type, which is equal to INT_MAX (21 47483647). The value
1 000000000000000000 causes an overflow, and m3 gets the remainder after dividing this value by
the range (more on this in the sidebar below).
The fact that the receiving variable m3 has type long 
does not mean that the values   in the expression
must be converted to it beforehand. This only happens at the moment of assignment. In order for the
multiplication to be performed according to the rules of long, you need to somehow specify the type
long directly in the expression itself. This can be done with an explicit conversion or by using variables.
In particular, obtaining the same product using a variable m1  of type long (such as m1  * m1 ) leads to
the correct result in m2.
Signed and unsigned integers
Programs are not always written perfectly, with protection from all possible failures. Therefore,
sometimes it happens that the integer number obtained during the calculations does not fit into the
variable of the selected integer type. Then it gets the remainder of dividing this value by the
maximum value (M) that can be written in the corresponding number of bytes (type size), plus 1 . So
for integer types with sizes from 1  to 4 bytes, M + 1  is, respectively, 256, 65536, 4294967296,
and 1 8446744073709551 61 6.
But there is a nuance for signed types. As we know, for signed numbers, the total range of values   is
divided approximately equally between positive and negative areas. Therefore, the new "residual"

---

## Page 112

Part 2. Programming fundamentals
1 1 2
2.6 Type conversion
value may in 50% of cases exceed the positive or negative limit. In this case, the number turns into
the "opposite": it changes sign and ends up at a distance M from the original one.
It is important to understand that this transformation occurs only due to a different interpretation
of the bit state in the internal representation, and the state itself is the same for signed and
unsigned numbers.
Let's explain this with an example for the smallest integer types: char and uchar.
Since unsigned char 
can store values   from 0 to 255, 256 maps to 0, -1  maps to 255, 300 maps to
44, and so on. If we try to write 300 into a regular signed char, we also get 44, because 44 is in
the range from 0 to 1 27 (the positive range of char). However, if you set the variables char and
uchar to 3000, the picture will be different. The remainder of 3000 divided by 256 is 1 84. It ends
up in uchar unchanged. However, for char, the same combination of bits results in -72. It is easy to
check that 1 84 and -72 differ by 256.
In the following example, it is easy to spot the problem thanks to the compiler warning.
char c = 3000;      // truncation of constant value
Print(c);           // -72
uchar uc = 3000;    // truncation of constant value
Print(uc);          // 184
However, if you get an extra large number during the calculation, there will be no warning.
char c55 = 55;
char sm = c55 * c55;  // ok! 
Print(sm);            // 3025 -> -47
uchar um = c55 * c55; // ok!
Print(um);            // 3025 -> 209
A similar effect can occur when signed and unsigned integer numbers of the same size are used in the
same expression since the signed operand is converted to unsigned. For example:
uint u = 11;
int i = -49;
Print(i + i); // -98
Print(u + i); // 4294967258 = 4294967296 - 38
When two negative integers add up, we get the expected result. The second expression maps the sum
of -38 to the "opposite" unsigned number 4294967258.
Mixing signed and unsigned types in the same expression is not recommended because of these
potential issues.
Besides that, if we subtract something from an unsigned integer, we need to make sure that the result
doesn't come out negative. Otherwise, it will be converted to a positive number and can distort the idea
of the algorithm, in particular, the idea of the while loop which checks the variable for the "greater than
or equal to zero" condition: since unsigned numbers are always non-negative, we can easily get an
infinite loop, i.e. a program hang.
2.6.3. Explicit type conversion
For explicit type conversion, MQL5 supports two forms of notation: in the C style and "functional". C-
style has the following syntax:

---

## Page 113

Part 2. Programming fundamentals
1 1 3
2.6 Type conversion
target t = (target)s;
Where target is the name of the target type. Any expression can be a data source s. If any operations
are performed in it, you must enclose the expression in parentheses so that the type conversion applies
to the entire expression.
An alternative "functional" syntax looks like this:
target t = target(s);
Let's look at a couple of examples.
double w = 100.0, v = 7.0;
int p = (int)(w / v);      // 14
Here, the result of dividing two real numbers is explicitly converted to the type int. Thus, the
programmer confirms their intention to discard the fractional part, and the compiler will not issue
warnings. It should be noted that MQL5 has a group of functions for rounding real numbers in various
ways (see Math functions).
If, on the contrary, you want to perform an operation on integer numbers with a real result, you need
to apply type conversion to the operands (in the expression itself):
int x = 100, y = 7;
double d = (double)x / y;  // 14.28571428571429
Converting one of the operands is enough to automatically convert the rest to the same type.
If necessary, you can perform several type conversion operations sequentially. Because the conversion
operation is right-associative, the target types will be applied in order from right to left. In the following
example, we convert the quotient to type float (this conversion allows for a more compact, fewer-
character representation of the value), and then to string. Without an explicit conversion to string, we
would get a compiler warning "implicit number to string conversion".
Print("Result:" + (string)(float)(w / v)); // Result:14.28571
Don't use explicit type conversion just to avoid a compiler warning. If it has no practical basis, you are
masking a potential error in the program.
2.7 Statements
So far, we've learned about data types, variable declarations, and their use in expressions for
calculations. However, these are only small bricks in the building with which the program can be
compared. Even the simplest program consists of larger blocks that allow you to group related data
processing operations and control the sequence of their execution. These blocks are called statements,
and we have actually already used some of them.
In particular, the declaration of a variable (or several variables) is a statement. Assigning the
expression evaluation result to a variable is also a statement. Strictly speaking, the assignment
operation itself is part of the expression, so it is more correct to call such a statement a statement of
expression. By the way, an expression may not contain an assignment operator (for example, if it
simply calls some function that does not return a value, such as Print("Hello");).
Program execution is the progressive execution of statements: from top to bottom and from left to
right (if there are several statements on one line). In the simplest case, their sequence is performed

---

## Page 114

Part 2. Programming fundamentals
1 1 4
2.7 Statements
linearly, one after the other. For most programs, this is not enough, so there are various control
statements. They allow you to organize loops (repeating calculations) in programs and the selection of
algorithm operation options depending on the conditions.
Statements are special syntactic constructions that represent the source text written according to the
rules. Statements of a particular type have their own rules, but there is something in common.
Statements of all types end with a ';' except for the compound statement. It can do without a
semicolon because its beginning and end are set by a pair of curly brackets. It is important to note that
thanks to the compound statement, we can include sets of statements inside other statements,
building arbitrary hierarchical structures of algorithms.
In this chapter, we will get acquainted with all types of MQL5 control statements, as well as consolidate
the features of declaration and expression statements.
2.7.1  Compound statements (blocks of code)
A compound statement is a generic container for other statements enclosed in curly brackets '{' and
'}'. Such a block of code can be used to define the body of a function, after the header of other control
statements if they require more than one controlled statement, or simply as a nested block on its own
within the body of a function or other statement. This allows you to create a local, limited scope for
variables. We already talked about this in the section Context, scope, and lifetime of variables.
In a generalized form, a compound statement can be described as follows:
{
[statements]
}
In such a schematic description, any fragment enclosed in semicircular brackets and with the
superscripted opt indicates that it is optional. In this case, there may not be any nested statements
inside the block.
In the following sections, we will see how compound statements are used in combination with other
kinds of statements and what they can contain.
There is one nuance that is worth emphasizing: after the description of the compound statement, the
semicolon ';' is not required. This distinguishes it from all other statements.
2.7.2 Declaration/definition statements
The declaration of a variable, array, function, or any other named element of a program (including
structures and classes, which will be discussed in Part 3) is a statement.
The declaration must contain the type and identifier of the element (see Declaring and defining
variables), as well as an optional initial value for initialization. Also, when declaring, additional modifiers
can be specified that change certain characteristics of the element. In particular, we already know the
static and const modifiers, and more will be added soon. Arrays require an additional specification of the
dimension and number of elements (see Description of arrays), while functions require a list of
parameters (for further details please see Functions).
The variable declaration statement can be summarized as follows:

---

## Page 115

Part 2. Programming fundamentals
1 1 5
2.7 Statements
[modifiers] identifier type
  [= initialization expressions] ;
For an array, it looks like this:
[modifiers] identifier type [ [size_1]ᵒᵖᵗ ] [ [size_N] ]ᵒᵖᵗ(3)
  [ = { initialization_list } ]ᵒᵖᵗ ;
The main difference is the mandatory presence of at least one pair of square brackets (the size inside
them can be indicated or not; depending on that, we get a fixed or dynamically distributed array). In
total, up to 4 pairs of square brackets are allowed (4 is the maximum supported number of
measurements).
In many cases, a declaration can simultaneously act as a definition, i.e. it reserves memory for the
element, determines its behavior, and makes it possible to use it in the program. Specifically, the
declaration of a variable or array is also a definition. From this point of view, a declaration statement
can be called a definition statement all the same, but this has not become a common practice.
Our basic knowledge of functions is enough to reliably assume what their definition should look like:
type identifier ( [list_of_arguments] )
{
  [statements]
}
Type, identifier, and list of arguments make up the function header. 
Please note that this is a definition since this description contains both the external attributes of the
function (interface) and statements that define its internal essence (implementation). The latter is
done with a block of code formed by a pair of curly brackets and immediately following the function
header. As you might guess, this is an example of the compound statement we mentioned in the
previous section. In this case, a terminological tautology is indispensable, since it is perfectly justified:
the compound statement is part of the function definition statement. 
A little later, we will learn why and how to separate the interface description from the implementation
and thereby achieve function declaration without defining it. We will also demonstrate the difference
between a declaration and a definition using the class as an example.  
The declaration statement makes the new element available by its name in the context of the code
block (see Context, scope, and lifetime of variables) in which the statement is located. Recall that
blocks form the local scope of objects (variables, arrays). In the first part of the book, we encountered
this when describing the greeting function.
In addition to local scopes, there is always a global scope, in which you can also use declaration
statements to create elements that are accessible from anywhere in the program.
If there is no static modifier in the declaration statement and it is located in some local block, then the
corresponding element is created and initialized at the moment the statement is executed (strictly
speaking, memory for all local variables inside the function is allocated, for the sake of efficiency,
immediately upon entering the function, but they are not yet formed at that moment).
For example, the following declaration of the variable i at the beginning of the OnStart function ensures
that such a variable will be created with the specified initial value (0) as soon as the function receives
control (i.e., the terminal will call it because it is the main function of the script). 

---

## Page 116

Part 2. Programming fundamentals
1 1 6
2.7 Statements
void OnStart()
{
   int i = 0;
   Print(i);
   
   // error: 'j' - undeclared identifier
   // Print(j); 
   int j = 1;
}
Thanks to the declaration in the first statement, the variable i is known and available in the subsequent
lines of the function, in particular, in the second line with the call of the Print function, which displays
the contents of the variable in the log.
The variable j described in the last line of the function will be created just before the end of the function
(this, of course, is meaningless, but clear). Therefore, this variable is not known in all earlier strings of
this function. An attempt to output j to the log using a commented Print call will result in an
"undeclared identifier" compilation error.
Elements declared this way (inside code blocks and without the static modifier) are called automatic,
because the program itself allocates memory for them when entering the block and destroys them
when exiting the block (in our case, after exiting the function). Therefore, the area of memory in which
this happens is called the stack ("last in, first out").
Automatic elements are created in the order in which the declaration statements are executed (first i,
then j). Destruction is performed in reverse order (first j, then i).
If a variable is declared without initialization and starts to be used in subsequent statements (for
example, to the right of the '=' sign) without first writing a meaningful value into it, the compiler issues
a warning: "possible use of uninitialized variable".
void OnStart()
{
   int i, p;
   i = p; // warning: possible use of uninitialized variable 'p'
}
If a declaration statement has the static modifier, the corresponding element is created only once when
the statement is executed for the first time, and remains in memory, regardless of exit and possible
subsequent entries and exits in the same block of code. All such static members are removed only
when the program is unloaded. 
Despite the increased lifetime, the scope of such variables is still limited to the local context in which
they are defined, and can only be accessed from later statements (located below in the code).
In contrast, declaration statements in the global context create their elements in the same order in
which they appear in the source code, immediately after the program is loaded (before any standard
start function is called, such as OnStart for scripts). Global objects are deleted in reverse order when
the program is unloaded.
To demonstrate the aforementioned, let's create a more "cunning" example (StmtDeclaration.mq5).
Recalling the skills gained in the first part, in addition to OnStart, we will write a simple function Init,
which will be used in variable initialization expressions and will log a sequence of calls.

---

## Page 117

Part 2. Programming fundamentals
1 1 7
2.7 Statements
int Init(const int v)
{
   Print("Init: ", v);
   return v;
}
The Init function accepts a single parameter v of integer type int, the value of which is returned to the
calling code (return statement).
This allows using it as a wrapper to set the initial value of a variable, for example, for two global
variables:
int k = Init(-1);
int m = Init(-2);
The value of the passed argument gets into the variables k and m by calling the function and returning
from it. However, inside Init, we additionally output the value with Print, and thus we can track how the
variables are created.
Note that we cannot use the Init function in the initialization of global variables above its definition. If
we try to move the k variable declaration above the Init declaration, we get the error "'Init' is an
unknown identifier". This limitation only works for the initialization of global variables, because functions
are also defined globally, and the compiler builds a list of such identifiers in one go. In all other cases,
the order of defining functions in the code is not important, because the compiler first registers them
all in the internal list, and then mutually links their calls from blocks. In particular, you can move the
entire Init function and the declaration of the global variables k and m below the OnStart function - it
will not break anything.
Inside the OnStart function, we will describe several more variables using Init: local i and j, as well as
static n. For simplicity, all variables are given unique values so that they can be distinguished.
void OnStart()
{
   Print(k);
   
   int i = Init(1);
   Print(i);
   // error: 'n' - undeclared identifier
   // Print(n);
   static int n = Init(0);
   // error: 'j' - undeclared identifier
   // Print(j);
   int j = Init(2);
   Print(j);
   Print(n);
}
Comments here show erroneous attempts to call the relevant variables before they are defined.
Run the script and get the following log:

---

## Page 118

Part 2. Programming fundamentals
1 1 8
2.7 Statements
Init: -1
Init: -2
-1
Init: 1
1
Init: 0
Init: 2
2
0
As we can see, the global variables were initialized before the OnStart function was called, and exactly
in the order in which they were encountered in the code. Internal variables were created in the same
sequence as their declaration statements were written.
If a variable is defined but not used anywhere, the compiler will issue a "variable 'name' not used"
warning. This is a sign of a potential programmer error.
Looking ahead, let's say that with the help of declaration/definition statements, not only data elements
(variables, arrays) or functions, but also new user-defined types (structures, classes, templates,
namespaces) that are not yet known to us can be introduced into the program. Such statements can
only be made at the global level, that is, outside of all functions.
It is also impossible to define a function within a function. The following code will not compile:
void OnStart()
{
   int Init(const int v)
   {
      Print("Init: ", v);
      return v;
   }
   int i = 0;
}
The compiler will generate an error: "function declarations are allowed on global, namespace, or class
scope only".
2.7.3 Simple statements (expressions)
Simple statements contain expressions, such as assigning new values or calculation results to variables,
as well as function calls.
Formally, the syntax looks like this: 
expression ;
The semicolon at the end is important here. Since MQL5 source codes support free formatting, the ';'
is the only delimiter that tells the compiler where the previous statement ended and the next one
began. As a rule, statements are written on separate lines, for example, like this:

---

## Page 119

Part 2. Programming fundamentals
1 1 9
2.7 Statements
int i = 0, j = 1, k;   // declaration statement
++i;                   // simple statement
j += i;                // simple statement
k = (i + 1) * (j + 1); // simple statement
Print(i, " ", j);      // simple statement
However, the rules do not prohibit shorthand code writing:
int i=0,j=1;++i;j+=i;k=(i+1)*(j+1);Print(i," ",j);
If it weren't for the ';', adjacent expressions could silently "stick together" and lead to unintended
results. For example, the expression x = y - 1 0 * z could well be two: x = y; and -1 0 * z; (-1 0 with a unary
minus). How is this possible?
The fact is that it is syntactically permissible to write a statement that actually works in vain, i.e., does
not save the result. Here is another example:
i + j; // warning: expression has no effect
The compiler issues an "expression has no effect" warning. The possibility to construct such
expressions is necessary because the object types, which we will learn in Part 3, allow for the operator
overloading, i.e., we can replace the usual meaning of operator symbols with some specific actions.
Then, if the type of i and j is not int, but some class with an overridden addition operation, such a
notation will have an effect, and the compiler will not issue a warning.
Simple statements can only be written inside compound statements. For example, calling the Print
function outside of a function will not work:
Print("Hello ", Symbol());
void OnStart()
{
}
We will get a cascade of errors::
'Print' - unexpected token, probably type is missing?
'Hello, ' - declaration without type
'Hello, ' - comma expected
'Symbol' - declaration without type
'(' - comma expected
')' - semicolon expected
')' - expressions are not allowed on a global scope
The most relevant, in this case, is the last one: "expressions are not allowed in the global context."
2.7.4 Overview of control statements
Control statements are designed to organize the non-linear execution of other statements, including
declarations, expressions, and nested control statements. They can be divided into 3 types:
• repetition statements, or loops
• conditional statements for choosing one of several branches of alternative actions
• jump statements that change, if necessary, the standard behavior of the first two types of
statements

---

## Page 120

Part 2. Programming fundamentals
1 20
2.7 Statements
Repeat and select statements consist of a header (each with a different syntax) followed by a
controlled statement. If a managed part needs to specify multiple statements, it uses a compound
statement. This feature is not available for jump statements. They only move the internal pointer,
based on which the program determines which statement is currently to be executed, according to
special rules, which we will discuss in the following sections.
In the simplest case, without control statements, the statements are executed sequentially, one after
the other, as they are written in the code block (in particular, in the body of the main function OnStart
for scripts). If an expression with a call to another function is encountered in a code block, the
program, according to the same linear principle, begins to execute statements inside the called
function, and when they are all executed, it will return to the calling code block, and execution will
continue on the next statement after the function call. Control statements can significantly change this
logic of work.
You can use selection inside loops or vice versa, and the nesting level is unlimited. However, too much
nesting makes the program difficult to understand for the programmer. Therefore, it is recommended
to allocate (transfer) code blocks into functions (one or several): inside each function, it makes sense
to maintain a nesting level of no more than 2-3.
The following repetition statements are supported in MQL5:
• for loop
• while loop
• do loop
All loops allow one or more statements to be executed a given number of times or until some boolean
condition is met. Executing the contents of a loop once is called an iteration. As a rule, arrays are
processed in loops or periodic repeating actions are performed (usually in scripts or services).
Conditional statements include:
• selection with if
• selection with switch
The former allows you to specify one or more conditions, depending on the truth or falsity of which the
options assigned to them (one or more statements) will be executed. The latter evaluates an expression
of an integer type and selects one of several alternatives based on its value.
Finally, jump statements are:
• break
• continue
• return
Later we will consider each of them in detail.
Unlike C++, MQL5 does not have a go to statement.
2.7.5 For loop
This loop is implemented by a statement with the for keyword, hence the name. In a generalized form,
it can be described as follows:

---

## Page 121

Part 2. Programming fundamentals
1 21 
2.7 Statements
for ( [initialization] ; [condition] ; [expression] )
  loop body
In the title, after the word 'for', the following is indicated in parentheses:
• Initialization: a statement for one-time initialization before the start of the loop;
• Condition: a boolean condition that is checked at the beginning of each iteration, and the loop runs
as long as it is true;
• Expression: formula of calculations performed at the end of each iteration, when all statements in
the loop body have been passed.
The loop body is a simple or compound statement.
All three header components are optional and may be omitted in any combination, including their
absence.
Initialization may include the declaration of variables (along with setting initial values) or the
assignment of values to already existing variables. Such variables are called loop variables. If they are
declared in the header, then their scope and lifetime are limited to the loop.
The loop starts executing if, after initialization, the condition is true, and continues executing for as
long as it is true at the beginning of each subsequent iteration. If during the next check, the condition
is violated, the loop exits, i.e., control is transferred to the statement written after the loop and its
body. If the condition is false before the start of the loop (after initialization), it will never be executed.
The condition and expression usually include loop variables.
Executing a loop means executing its body.
The most common form of the for loop has a single loop variable that controls the number of iterations.
In the following example, we calculate the squares of the numbers in the a array.
int a[] = {1, 2, 3, 4, 5, 6, 7};
const int n = ArraySize(a);
for(int i = 0; i < n; ++i)
   a[i] = a[i] * a[i];
ArrayPrint(a);    // 1  4  9 16 25 36 49
// Print(i);      // error: 'i' - undeclared identifier
This loop is executed in the following steps:
1 .A variable i with an initial value of 0 is created.
2. The condition is checked of whether the variable i is less than the size of the loop n. As long as it
is true, the loop continues. If it is false, we jump to the statement calling the ArrayPrint function.
3. If the condition is true, the statements of the loop body are executed. In this case, the i-th
element of the array gets the product of the initial value of this element by itself, i.e. the value of
each element is replaced by its square.
4. The variable i is incremented by 1 .
Then everything repeats, starting from step 2. After exiting the loop, its variable i is destroyed, and an
attempt to access it will cause an error.
The expression for step 4 can be of arbitrary complexity, not just an increment of the loop variable. For
example, to iterate over even or odd elements, one could write i += 2.

---

## Page 122

Part 2. Programming fundamentals
1 22
2.7 Statements
Regardless of how many statements make up the body of the loop, it is recommended to write it on a
separate line (lines) from the header. This makes the step-by-step debugging process easier.
Initialization may include multiple variable declarations, but they must be of the same type because
they are one statement. For example, to rearrange elements in reverse order, you can write such a
loop (this is just a demonstration of the loop, there is a built-in function ArrayReverse to reverse the
order in an array, see Copying and editing arrays):
for(int i = 0, j = n - 1; i < n / 2; ++i, --j)
{
   int temp = a[i];
   a[i] = a[j];
   a[j] = temp;
}
ArrayPrint(a);    // 49 36 25 16  9  4  1
The auxiliary variable temp is created and deleted on each pass of the loop, but the compiler allocates
memory for it only once, as for all local variables, when entering the function. This optimization works
well for built-in types. However, if a custom class object is described in the loop, then its constructor
and destructor will be called at each iteration.
It is acceptable to change the loop variable in the loop body, but this technique is only used in very
exotic cases. It is not recommended to do this, as this may cause errors (in particular, processed
elements can be skipped or execution can get into an infinite loop).
To demonstrate the ability to omit header components, let's imagine the following problem: We need to
find the number of elements of the same array the sum of which is less than 1 00. To do this, we need a
counter variable k defined before the loop because it must continue to exist after its completion. We will
also create the sum variable to calculate the sum on a cumulative basis.
int k = 0, sum = 0;
for( ; sum < 100; )
{
  sum += a[k++];
}
 
Print(k - 1, " ", sum - a[k - 1]); // 2 85
Thus, there is no need to do initialization in the header. In addition, the k counter is incremented using
a postfix increment directly in the expression that calculates the sum (when accessing an array
element). Therefore, we do not need an expression in the title.
At the end of the loop, we print out k and the sum minus the last added element, because it was the
one that exceeded our limit of 1 00.
Note that we are using a compound block even though there is only one statement in the loop body.
This is useful because when the program grows, everything is already done for adding additional
statements inside the brackets. In addition, this approach guarantees a uniform style for all loops. But
the choice, in any case, is up to the programmer.
In the explicit, maximally abbreviated version, the cycle header might look like this:

---

## Page 123

Part 2. Programming fundamentals
1 23
2.7 Statements
for( ; ; )
{
   // ...       // periodic actions
   Sleep(1000); // pause the program for 1 second
}
If there are no statements in the body of such a loop that would interrupt the loop due to some
conditions, it will be executed indefinitely. We'll learn how to break and test conditions in Break jump
and If selection respectively.
Such looping algorithms are usually used in services (they are designed for constant background work)
to monitor the state of the terminal or external network resources. They usually contain statements
that pause the program at a specified interval, for example, using the built-in function Sleep. Without
this precaution, an infinite loop will load 1 00% of one processor core.
Script StmtLoopsFor.mq5 contains an infinite loop at the end, but it is for demonstration purposes only.
for( ; ; )
{
   Comment(GetTickCount());
   Sleep(1000); // 1000 ms
  
   // the loop can be exited only by deleting the script at the user's command
   // after 3 seconds of waiting we will get the message 'Abnormal termination'
}
Comment("");  // this line will never be executed
In the loop, once per second, the computer's internal timer (GetTickCount) is displayed using the
Comment function: the value is displayed in the upper left corner of the chart. Only the user can
interrupt the loop by deleting the entire script from the chart (the "Delete" button in the Experts
dialog). This code does not check for such user requests to stop inside the loop, although there is a
built-in function IsStopped for this purpose. It returns true if the user has given the command to stop.
In the program, especially if there are loops and long-term calculations, it is desirable to provide for
checking the value of this function and voluntarily terminate the loop and the entire program upon
receipt of true. Otherwise, the terminal will forcibly terminate the script after 3 seconds of waiting
(with output to the "Abnormal termination" log), which will happen in this example.
A better version of this loop should be:
for( ; !IsStopped(); ) // continue until user interrupt
{
   Comment(GetTickCount());
   Sleep(1000); // 1000 ms
}
Comment("");    // will clear the comment
However, this loop would be better implemented using another repeat statement while. As a rule of
thumb, a for loop should only be used when there is an obvious loop variable and/or a predetermined
number of iterations. In this case, these conditions are not met.
Loop variables are usually integers, although other types are allowed, such as double. This is due to the
fact that the very logic of the loop operation implies the numbering of iterations. In addition, it is
always possible to calculate the necessary real numbers from an integer index, and with greater
accuracy. For example, the following loop iterates over values from 0.0 to 1 .0 in increments of 0.01 :

---

## Page 124

Part 2. Programming fundamentals
1 24
2.7 Statements
for(double x = 0.0; x < 1.0; x += 0.01) { ... }
It can be replaced by a similar loop with an integer variable:
for(int i = 0; i < 100; ++i) { double x = i * 0.01; ... }
In the first case, when adding x += 0.01 , the error of floating-point calculations gradually accumulates.
In the second case, each value x is obtained in one operation i * 0.01 , with the maximum available
precision.
It is customary to give loop variables the following single-letter names, for example, i, j , k, m, p, q.
Multiple names are required when loops are nested or both forward (increasing) and backward
(decreasing) indexes are calculated within the same loop.
By the way, here is an example of a nested loop. The following code calculates and stores the
multiplication table in a two-dimensional array.
int table[10][10] = {0};
for(int i = 1; i <= 10; ++i)
{
   for(int j = 1; j <= 10; ++j)
   {
      table[i - 1][j - 1] = i * j;
   }
}
ArrayPrint(table);
2.7.6 While loop
This loop is described using the while keyword. It repeats the execution of controlled statements as
long as the logical expression in its header is true.
while ( condition )
  loop body
The condition is an arbitrary expression of a boolean type. The presence of the condition is mandatory.
If the condition is false before the start of the loop, the loop will never execute.
Unlike C++, MQL5 does not support defining variables in the while loop header.
Variables included in the condition must be defined before the loop.
The loop body is a simple or compound statement.
The while loop is usually used when the number of iterations is not defined. So, an example with the
loop that outputs a computer timer counter every second can be written using a while loop and
checking the stop flag (by calling the IsStopped function) as follows (StmtLoopsWhile.mq5):

---

## Page 125

Part 2. Programming fundamentals
1 25
2.7 Statements
while(!IsStopped())
{
   Comment(GetTickCount());
   Sleep(1000);
}
Comment("");
Also, the while loop is convenient when the loop termination condition can be combined with the
modification of variables in one expression. The next loop is executed until the variable i reaches zero (0
is treated as false).
int i = 5;
while(--i) // warning: expression not boolean
{
   Print(i);
}
However, in this case, the header expression is not boolean (and is implicitly converted to false or true).
The compiler generates the relevant warning. It is desirable to always compose expressions taking into
account the expected (according to the rules) characteristics. Below is the correct loop version:
int i = 5;
while(--i > 0)
{
   Print(i);
}
The loop can also be used with a simple statement (no block):
while(i < 10)
   Print(++i);
Note that a simple statement ends with a semicolon. It also demonstrates that changing the variable
being checked in the header is done inside the loop.
When working with loops, be careful when using unsigned integers. For example, the next loop will never
end, because its condition is always true (in theory, the compiler could issue warnings in such places,
but it does not). After zero, the counter will "turn" into a large positive number (UINT_MAX) and the
loop will continue.
uint i = 5;
while(--i >= 0)
{
   Print(i);
}
From the user's point of view, the MQL program will freeze (stop responding to commands), although it
will still consume resources (processor and memory).
while loops can be nested like other kinds of repetition statements.

---

## Page 126

Part 2. Programming fundamentals
1 26
2.7 Statements
2.7.7 Do loop
This loop is similar to the while loop, but its condition is checked after the loop body. Due to this,
controlled statements must be executed at least once.
Two keywords, do and while, are used to describe the loop:
do
  loop body
while ( condition ) ;
Thus, the loop header is separated, and after the logical condition in brackets, there should be a
semicolon. The condition cannot be omitted. When it becomes false, the loop exits.
Variables included in the condition must be defined before the loop.
The loop body is a simple or compound statement.
The following example calculates a sequence of numbers starting from 1 , in which each next number is
obtained by multiplying the previous one by the square root of two, the predefined constant M_SQRT2
(StmtLoopsDo.mq5).
double d = 1.0;
do
{
   Print(d);
   d *= M_SQRT2;
}
while(d < 100.0);
The process terminates when the number exceeds 1 00.
2.7.8 If selection
The if statement has several forms. In its simplest case, it executes the dependent statement if the
specified condition is true:
if ( condition )
  statement
If the condition is false, the statement is skipped and the execution immediately jumps to the rest of
the algorithm (subsequent statements, if any).
The statement can be simple or compound. A condition is an expression of a boolean or castable type.
The second form allows you to specify two branches of actions: not only for the true condition
(statement_A) but also for the false (statement_B):
if ( condition )
  statement_A
else
  statement_B
Whichever of the controlled statements is executed, the algorithm will then continue following the
statements below the if/else statement.

---

## Page 127

Part 2. Programming fundamentals
1 27
2.7 Statements
For example, a script can follow a different strategy depending on the timeframe of the chart it is
placed on. For this purpose, it is enough to analyze the value returned by the Period built-in function.
The value is of the ENUM_TIMEFRAMES enum type. If it is less than PERIOD_D1 , it means short-term
trading, otherwise, long-term trading (StmtSelectionIf.mq5).
if(Period() < PERIOD_D1)
{
   Print("Intraday");
}
else
{
   Print("Interday");
}
As a statement in the else branch, it is allowed to specify the following operator if, and thus arrange
them into a chain of successive checks. For example, the following fragment counts the number of
capital letters and punctuation symbols (more precisely, non-Latin letters) in a string.
string s = "Hello, " + Symbol();
int capital = 0, punctuation = 0;
for(int i = 0; i < StringLen(s); ++i)
{
   if(s[i] >= 'A' && s[i] <= 'Z')
      ++capital;
   else if(!(s[i] >= 'a' && s[i] <= 'z'))
      ++punctuation;
      
}
Print(capital, " ", punctuation);
The loop is organized through all the characters of the string (numbering starts from 0) and the
StringLen function returns the length of the string. The first if checks each character to see if it
belongs to the range 'A' to 'Z' and, if successful, increments the capital counter by 1 . If the character
does not fall into this range, the second if is run, in which the condition for belonging to the range of
lowercase letters (s[i] >= ' a'  && s[i] <= ' z' ) is inverted with '!'. In other words, the condition means that
the character is not in the given range. Given two consecutive checks, if the character is not an
uppercase letter (else) and not a lowercase letter (the second if), we can conclude that the character
is not a letter of the Latin alphabet. In this case, we increment the punctuation counter.
The same checks could be written in a more detailed form, with '{...}' blocks for clarity.

---

## Page 128

Part 2. Programming fundamentals
1 28
2.7 Statements
int capital = 0, small = 0, punctuation = 0;
for(int i = 0; i < StringLen(s); ++i)
{
   if(s[i] >= 'A' && s[i] <= 'Z')
   {
      ++capital;
   }
   else
   {
      if(s[i] >= 'a' && s[i] <= 'z')
      {
         ++small;
      }
      else
      {
         ++punctuation;
      }
   }
}
The use of curly brackets helps to avoid logical errors associated which can occur when the
programmer is only guided by indentation in the code. In particular, the most common problem is
called the "hanging" else.
When if statements are nested, sometimes there are fewer else branches than if. Here is one example:
factor = 0.0;
if(mode > 10)
   if(mode > 20)
      factor = +1.0;
else
   factor = -1.0;
The indentation indicates what kind of logic the programmer meant: factor should become +1  when
mode is greater than 20, remain equal to 0 when mode is between 1 0 and 20, and change to -1 
otherwise (mode <= 1 0). But will the code work that way?
In MQL5, each else is assumed to refer to the nearest previous if (which does not have a else). As a
result, the compiler will treat the statements as follows:
factor = 0.0;
if(mode > 10)
   if(mode > 20)
      factor = +1.0;
   else
      factor = -1.0;
So the factor will be -1  in the mode range from 1 0 to 20, and 0 for mode <= 1 0. The most interesting
thing is that the program does not produce any formal errors, neither during compilation nor during
execution. And yet it doesn't work correctly.
To eliminate such subtle logical problems allows the placement of curly brackets.

---

## Page 129

Part 2. Programming fundamentals
1 29
2.7 Statements
if(mode > 10)
{
   if(mode > 20)
      factor = +1.0;
}
else
   factor = -1.0;
To keep the design consistent, it is desirable to use blocks in all branches of the statement if at least
one block has already been required in it.
When using the loop to check equality, take into account the possibility of a typo when one '=' is
written instead of two characters '=='. This turns the comparison into an assignment, and the assigned
value is analyzed as a logical condition. For example,
// should have been x == y + 1, which would give false and skip the if
if(x = y + 1) // warning: expression not boolean
{
   // assigned x = 5 and treated x as true, so if is executed
}
The compiler will produce a warning "expression not boolean".
2.7.9 Switch selection
The switch operator provides the ability to choose one of several algorithm options. As a rule, the
number of options is significantly higher than two, because otherwise, it is easier to use the if/else
statement. In theory, the chain of if/else statements allows having an equivalent of switch in many
cases (but not all). An important feature of switch is that all options are selected (identified) based on
the integer expression value, usually a variable.
In general case, the switch statement looks as follows:
switch ( expression )
{
   case constant-expression : statements [break; ]
   ...
   [ default : statements ] 
}
The statement header starts with the keyword switch. It must be followed by an expression in
parentheses. The block with curly brackets is also required.
Integer values that can be obtained by evaluating an expression should be specified as constants after
the case keyword. A constant is a literal of any integer types, for example, int (1 0, 1 23), ushort
(characters 'A', 's', '*' etc.), or enum elements. Real numbers, variables, or expressions are not
allowed here.
There may be many such case options, or may not be at all, which is indicated by semicircular brackets
with index opt(n). All variants must have unique constants (no repetitions).
For each alternative declared with case, a statement must be written after the colon, which will be
executed if the value of the expression is equal to the corresponding constant. Again, a statement can

---

## Page 130

Part 2. Programming fundamentals
1 30
2.7 Statements
be simple or compound. In addition, it is permissible to write several simple statements without
enclosing them in curly brackets: they will still be executed as a group (a compound statement).
One or more of these statements can be followed by the break jump statement.
If there is a break, after executing the previous statements from the case branch, the switch statement
exits, i.e., control is transferred to the statements below switch.
In the absence of break, the statements of the next branch or several branches case continue to be
executed, that is, until the first encountered break or the end of the block switch. This is called "fall-
through".
Thus, the switch statement not only allows splitting the algorithm execution flow into several
alternatives but also combining them, which is not available for the if operator. On the other hand, in
the switch statement, unlike if, you cannot select a range of values as a condition for activating
alternatives.
The default keyword allows you to set the default algorithm variant, that is, for any other expression
values except for constants from all cases. The default option may not be present, or there must be
only one.
The sequence in which case constants and default are listed can be arbitrary.
Even if there is no algorithm for the default branch yet, it is recommended to make it explicitly empty,
i.e. containing break. An empty default will remind you and other programmers that other options exist
but are considered unimportant because otherwise, the default branch would have to signal an error.
Several case variants with different constants can be listed one below the other (or left to right) without
statements, but the last one must have a statement. Such combined cases are indicated on the
diagram by the index (i).
Here is the simplest and most useless switch:
switch(0)
{
}
Let's consider a more complex example with different modes (StmtSelectionSwitch.mq5). In it, the
switch operator is placed inside the loop to show how its work depends on the values of the control
variable i.

---

## Page 131

Part 2. Programming fundamentals
1 31 
2.7 Statements
for(int i = 0; i < 7; i++)
{
   double factor = 1.0;
   
   switch(i)
   {
      case -1:
         Print("-1: Never hit");
         break;
      case 1:
         Print("Case 1");
         factor = 1.5;
         break;
      case 2: // fall-through, no break (!)
         Print("Case 2");
         factor *= 2;
      case 3: // same statements for 3 and 4
      case 4:
         Print("Case 3 & 4");
         {
            double local_var = i * i;
            factor *= local_var;
         }
         break;
      case 5:
         Print("Case 5");
         factor = 100;
         break;
      default:
         Print("Default: ", i);
   }
   
   Print(factor);
}
The -1  option will fail because the loop changes the variable i from 0 to 6 (inclusive). When i is 0, the
default branch will trigger. It will also take control when i is equal to 6. All other possible i values are
distributed according to the corresponding case directives. At the same time, there is no break
statement after case 2, and therefore the code for options 3 and 4 will be executed in addition to 2 (in
such cases, it is always recommended to leave a comment that this was done intentionally).
Cases 3 and 4 have a common statement block. But it is also important to note here that if you want
to declare a local variable inside one of the case options, you need to enclose the statements in a
nested compound block ('{...}'). Here, the variable local_ varis defined this way.
It is worth advising that in the default case, there is no break statement. It's redundant because
default is written last in this case. However, many programmers advise inserting break at the end of
any option, even the last one, because it can cease to be the last in the process of subsequent
modifications of the code, and then it is easy to forget to add break, which will probably lead to an
error in the program logic.

---

## Page 132

Part 2. Programming fundamentals
1 32
2.7 Statements
If in switch there is no default, and the header expression does not match any of the case constants,
the entire switch is skipped.
As a result of the script execution, we will receive the following messages in the log:
Default: 0
1.0
Case 1
1.5
Case 2
Case 3 & 4
8.0
Case 3 & 4
9.0
Case 3 & 4
16.0
Case 5
100.0
Default: 6
1.0
2.7.1 0 Break jump
The break operator is intended for early termination of the for, while, do loops, as well as exit from the
switch selection statement. The operator can only be applied within the specified statements and only
affects the one immediately containing break if there are multiple nested ones. After processing the
break statement, program execution continues to the statement following the interrupted loop or
switch.
The syntax is very simple: the keyword break and a semicolon:
break ;
When used inside loops, break is usually implemented in one of the branches of the if/else conditional
operator.
Consider a script that prints the current system time counter once per second, but no more than 1 00
times. It provides for handling the interruption of the process by the user: for this, the function
IsStopped is polled in the conditional operator if and its dependent statement contains break
(StmtJumpBreak.mq5).

---

## Page 133

Part 2. Programming fundamentals
1 33
2.7 Statements
int count = 0;
while(++count < 100)
{
   Comment(GetTickCount());
   Sleep(1000);
   if(IsStopped())
   {
      Print("Terminated by user");
      break;
   }
}
In the following example, a diagonal matrix is filled in with a times table (the top right corner will remain
filled with zeros).
int a[10][10] = {0};
for(int i = 0; i < 10; ++i)
{
   for(int j = 0; j < 10; ++j)
   {
      if(j > i)
         break;
      a[i][j] = (i + 1) * (j + 1);
   }
}
ArrayPrint(a);
When the inner loop variable j is greater than the outer loop variable i, the break statement breaks the
inner loop. Of course, this is not the best way to fill the matrix diagonally: it would be easier to loop
over j from 0 to i without any break, but here it demonstrates the presence of equivalent constructions
with break and without break.
Although things may not be so obvious in production projects, it is recommended to avoid the break
operator whenever possible and replace it with additional variables (for example, a boolean variable with
a "telling" name needAbreak), which should be used in terminal expressions in loop headers to break
them in the standard way.
Imagine that two nested loops are used to find duplicate characters in a string. The first loop
sequentially makes each character of the string current and the second runs through the remaining (to
the right) characters.

---

## Page 134

Part 2. Programming fundamentals
1 34
2.7 Statements
string s = "Hello, " + Symbol();
ushort d = 0;
const int n = StringLen(s);
for(int i = 0; i < n; ++i)
{
   for(int j = i + 1; j < n; ++j)
   {
      if(s[i] == s[j])
      {
         d = s[i];
         break;
      }
   }
}
If the characters at positions i and j  match, remember the duplicate character and exit the loop via
break.
It could be assumed that the variable d should contain the letter 'l' after the execution of this
fragment. However, if you place the script on the most popular instrument "EURUSD", the answer will
be 'U'. The thing is that break breaks only the inner loop, and after finding the first duplicate ('ll' in the
word "Hello"), the loop continues on i. Therefore, to exit from several nested loops at once, additional
measures must be taken.
The most popular way is to include in the condition of the outer loop (or all outer loops) a variable that
is filled in the inner loop. In our case, there is already such a variable: d.
for(int i = 0; i < n && d == 0; ++i)
{
   for(int j = i + 1; j < n; ++j)
   {
      if(s[i] == s[j])
      {
         d = s[i];
         break;
      }
   }
}
Checking d for being equal to 0 will now stop the outer loop after finding the first duplicate. But the
same check can be added to the inner loop, which eliminates the need to use break.
for(int i = 0; i < n && d == 0; ++i)
{
   for(int j = i + 1; j < n && d == 0; ++j)
   {
      if(s[i] == s[j])
      {
         d = s[i];
      }
   }
}

---

## Page 135

Part 2. Programming fundamentals
1 35
2.7 Statements
2.7.1 1  Continue jump
The continue statement breaks the current iteration of the innermost loop containing continue and
initiates the next iteration. The statement can only be used inside for, while and do loops. Execution of
continue inside for results in the next calculation of the expression in the loop header
(increment/decrement of the loop variable), after which the loop continuation condition is checked.
Executing continue inside while or do immediately results in checking the condition in the loop header.
The statement consists of the keyword continue and a semicolon:
continue ;
It is usually placed in one of the branches of the if/else or switch conditional statement.
For example, we can generate a times table with gaps: when the product of two indexes is odd, the
corresponding array element will remain zero (StmtJumpContinue.mq5).
int a[10][10] = {0};
for(int i = 0; i < 10; ++i)
{
   for(int j = 0; j < 10; ++j)
   {
      if((j * i) % 2 == 1)
         continue;
      a[i][j] = (i + 1) * (j + 1);
   }
}
ArrayPrint(a);
And here's how you can calculate the sum of the positive elements of an array.
int b[10] = {1, -2, 3, 4, -5, -6, 7, 8, -9, 10};
int sum = 0;
for(int i = 0; i < 10; ++i)
{
   if(b[i] < 0) continue;
   sum += b[i];
}
Print(sum); // 33
Note that the same loop can be rewritten without continue but with a greater nesting of code blocks:
for(int i = 0; i < 10; ++i)
{
   if(b[i] >= 0)
   {
      sum += b[i];
   }
}
Thus, operator continue is often used to simplify code formatting (especially if there are several
conditions to pass). However, which of the two approaches to choose is a matter of personal
preference.

---

## Page 136

Part 2. Programming fundamentals
1 36
2.7 Statements
2.7.1 2 Return jump
The return operator is designed to return control from functions. Given that all executable statements
are inside a particular function, it can be indirectly used to interrupt containing it loops for, while, and
do of any nesting level. It should be taken into account that unlike continue and, especially, break, all
statements following interrupted loops inside the function will also be ignored.
The syntax for the return operator: 
return ([expression]) ;
The need to specify an expression is determined by the function signature (more on this will be
discussed in the relevant section). For a general understanding of how return works in the context of
control statements, let's view an example with the main script function OnStart. Since it is of type void,
i.e. it does not return anything, the operator takes the following form:
return ;
In the section on break, we implemented an algorithm for finding duplicate characters in a string. To
break two nested loops, we not only use break but also modify the condition of the outer loop.
With the return operator, this can be done in a simpler way (StmtJumpReturn.mq5).
void OnStart()
{
   string s = "Hello, " + Symbol();
   const int n = StringLen(s);
   for(int i = 0; i < n; ++i)
   {
      for(int j = i + 1; j < n; ++j)
      {
         if(s[i] == s[j])
         {
            PrintFormat("Duplicate: %c", s[i]);
            return;
         }
      }
   }
   
   Print("No duplicates");
}
If equality is found in the if operator, we display the symbol and exit the function. If this algorithm was
in a custom function other than OnStart, we could define a return type for it (for example, ushort
instead of void) and pass the found character using the full form return to the calling code.
Since the double letter 'l' is known to exist in the test string, the statement after the loops (Print) will
not be executed.
2.7.1 3 Empty statement
The empty statement is the simplest in the language. It consists of only one character, the semicolon
';'

---

## Page 137

Part 2. Programming fundamentals
1 37
2.7 Statements
An empty statement is used in the program in those places where the syntax requires the presence of a
statement, but the logic of the algorithm instructs to do nothing.
For example, the following while loop is used to find a space in a string. The whole essence of the
algorithm is performed directly in the loop header, so its body must be empty. We could write an empty
block of curly brackets, but an empty statement would also work here. (StmtNull.mq5).
int i = 0;
ushort c;
string s = "Hello, " + Symbol();
while((c = s[i++]) != ' ' && c != 0); // intentional ';' (!)
if(c == ' ')
{
   Print("Space found at: ", i);
}
Note that if the semicolon at the end of the while header is omitted (perhaps by accident), then the if
statement will be treated as the body of the loop. As a result, there will be no output to the log by the
Print function. In fact, the program will not work correctly, although without noticeable errors.
The opposite situation is also possible: an extra semicolon after the loop header (where it should not
have been) will "detach" the loop body from the header, i.e. only an empty statement will be executed
in the loop.
In this regard, optional semicolons should be checked in the code, and wherever they are placed
intentionally, leave a comment with explanations.
By the way, from a formal point of view, the empty statement is also used in the for statement when
we omit the initialization expression. In fact, there is always initialization:
for ( [initialization] ; [end loop condition]; [post-expression] )
  loop body
The first character ';' is part of an initialization statement, which can be an expression or an empty
statement: both contain the character ';' at the end, with the latter containing nothing but ';'. Thus,
optionality (emptiness) is achieved.
2.8 Functions
A function is a named block with statements. Almost the entire application algorithm of the program is
contained in functions. Outside of functions, only auxiliary operations are performed, such as creating
and deleting global variables.
The execution of statements within a function occurs when we call that function. Some functions, the
main ones, are called automatically by the terminal when various events occur. They are also referred
to as the MQL program entry points or event handlers. In particular, we already know that when we run
a script on a chart, the terminal calls its main function OnStart. In other types of programs, there are
other functions called by the terminal, which we will discuss in detail in the fifth and sixth chapters
covering the trading architecture of the MQL5 API.
In this chapter, we will learn how to define and declare a function, how to describe and pass
parameters to it, and how to return the result of its work from the function.

---

## Page 138

Part 2. Programming fundamentals
1 38
2.8 Functions
We will also talk about function overloading, i.e., the ability to provide multiple functions with the same
name, and how this can be useful.
Finally, we will get acquainted with a new type: a pointer to a function.
2.8.1  Function definition
A function definition consists of the value type it returns, an identifier, a list of parameters in
parentheses, and a body – a block of code with statements. Parameters in the list are separated by
commas. Each parameter is given a type, a name, and optionally a default value.
result_type function_identifier ( [parameter_type parameter_identifier
                                       = value_by_default] ,... )
{
  [statement]
   ...
}
It is allowed to create functions without parameters: then there is no list, and empty brackets are
placed after the function name (they cannot be omitted). Optionally, you can write the void keyword
between the brackets to emphasize that there are no parameters. For example, like this:
void OnStart(void)
{
}
The combination of return type, number and types of parameters in the list is called a function
prototype or signature. Different functions can have the same prototype.
In previous sections, we have already seen function definitions such as OnStart and Greeting. Now let's
try to implement the calculation of Fibonacci numbers as a test function. These numbers are calculated
by the following formula:
f[0] = 1
f[1] = 1
f[i] = f[i - 1] + f[i - 2], i > 1
The first two numbers are 1 , and all subsequent numbers are the sum of the previous two. We give the
beginning of the series: 1 , 1 , 2, 3, 5, 8, 1 3, 21 , 34, 55...
You can calculate the number at a given index using the following function (FuncFibo.mq5).

---

## Page 139

Part 2. Programming fundamentals
1 39
2.8 Functions
int Fibo(const int n)
{
   int prev = 0;
   int result = 1;
   for(int i = 0; i < n; ++i)
   {
      int temp = result;
      result = result + prev;
      prev = temp;
   }
   return result;
}
It takes one parameter n of type int and returns a result of type int. The n parameter has the const
modifier because we are not going to change n inside the function (such an explicit declaration of
restrictions on the "rights" of variables is welcome because it helps avoid random errors).
Local variables prev and result will store the current values of the last two numbers in the series. In the
loop over i we calculate their sum, getting the next number of the sequence. Previously, the old value
result is written to the variable temp, so that after summation, it is transferred to prev.
After executing the loop a given number of times, the result variable contains the desired number. We
return it from the function using the result statement.
The input parameter of a function is also a local variable that will be initialized to the actual value
during the function call. This value is passed "outside" from the statement with the function call.
Parameter names must be unique and must not match local variable names.
The body of a function is a block of code that defines the scope and lifetime of local variables. Their
definition and operation principles were discussed in the sections Declaration/definition statements and
Initialization.
2.8.2 Function call
A function is called when its name is mentioned in an expression. After the name, there should be a pair
of parentheses, in which the arguments corresponding to the function parameters (if there is a list of
parameters in its definition) are indicated, separated by commas.
A little later, we will look at the function pointer type, which allows you to create variables that point to
a function with specific characteristics, and then call it not by name, but through this variable.
Continuing the example with the Fibo function, let's call it from the OnStart function. To do this, let's
create a variable f to store the resulting number and in its initialization expression we indicate the name
of the function Fibo and an integer (for example, 1 0) as an argument, in parentheses.
void OnStart()
{
   int f = Fibo(10); 
   Print(f); // 89
}
We are not required to create a variable to receive a value from a function. Instead, you can call the
function directly from an expression, such as "2*Fibo(1 0)" or "Print(Fibo(1 0))". Then its value will be

---

## Page 140

Part 2. Programming fundamentals
1 40
2.8 Functions
substituted into the expression at the place of the call. Here, the auxiliary variable f is introduced to
implement the call and return of a value in a separate statement.
The call process includes the following steps:
• Execution of the statement sequence of the calling function (OnStart) is suspended;
• The value of the argument gets into the input parameter n of the called function (Fibo);
• The execution of its statements starts;
• When it is completely finished, it sends the result back (remember the return statement inside);
• The result is written to the variable f; and
• After that, the execution of the OnStart function continues, that is, the number is printed to the log
(Print).
For each function call, the compiler generates auxiliary binary code (the programmer does not need to
worry about it). The idea of this code is that before calling the function, it pushes the current position
in the program onto the stack, and after the call is completed, it retrieves it and uses it to return to the
statements following the function call. When one function calls another, that one calls one more
function, the second calls a third, and so on, the return addresses of transitions throughout the
hierarchy of called functions are accumulated on the stack (hence the name stack). As nested function
calls are processed, the stack will be cleared in reverse order. Note that the stack also allocates
memory for the local variables of each function.
2.8.3 Parameters and arguments
The arguments passed to the function with its call are the initial values of the corresponding function
parameters. The number, order, and types of arguments must match the function prototype. However,
the order in which arguments are computed is not defined (see the Basic concepts section). Depending
on the specifics of the source code and optimization considerations, the compiler may choose an option
that is convenient for it. For example, given a list of two arguments, the compiler might evaluate the
second argument first and then the first. It is only guaranteed that both arguments will be evaluated
before the call.
Each argument is mapped to the corresponding parameter in the same way that variables are
initialized, with implicit casts if necessary. Before the function starts, all its parameters are guaranteed
to have the specified values. For example, depending on the arguments passed, calls to the Fibo
function can lead to the following effects (described in the comments):
// warnings
double d = 5.5;
Fibo(d);          // possible loss of data due to type conversion
Fibo(5.5);        // truncation of constant value
Fibo("10");       // implicit conversion from 'string' to 'number'
// errors
Fibo();           // wrong parameters count
Fibo(0, 10);      // wrong parameters count
All warnings are about implicit conversions that the compiler performs because the value types do not
match the parameter types. They should be regarded as potential errors and eliminated. The "wrong
parameters count" error occurs when there are too few or too many arguments.

---

## Page 141

Part 2. Programming fundamentals
1 41 
2.8 Functions
In theory, a function parameter does not have to have a name, i.e. the type alone is sufficient to
describe the parameter. This sounds rather strange because we will not be able to access a parameter
without a name inside the function. However, when creating programs based on some standard
interfaces, sometimes you have to write functions that must correspond to given prototypes. In this
case, some parameters inside the function may be unnecessary. Then, to explicitly indicate this fact,
the programmer can omit their names. For example, the MQL5 API requires the implementation of the
OnDeinit event handler function with the following prototype:
void OnDeinit(const int reason);
If we don't need the reason parameter in the function code, we can omit it in the description:
void OnDeinit(const int);
The terminal event handling function is usually called by the terminal itself, but if we needed to call a
similar function (with an anonymous parameter) from our code, then we need to pass all the
arguments, regardless of whether the parameters are named or not.
2.8.4 Value parameters and reference parameters
Arguments can be passed to a function in two ways: by value and by reference.
All the cases we've looked at so far are passing by value. This option means that the value of the
argument prepared by the calling code snippet is copied into a new variable, the corresponding input
variable of the function. Otherwise, the argument and input variable are unrelated. All subsequent
manipulations with the variable inside the function do not affect the argument in any way.
To describe a reference parameter, add an ampersand sign '&' on the right of the type. Many
programmers prefer to append an ampersand to a parameter name, thus emphasizing that the
parameter is a reference to the given type. For example, the following entries are equivalent:
void func(int &parameter);
void func(int & parameter); 
void func(int& parameter);
When a function is called, a corresponding local variable is not created for a reference parameter.
Instead, the argument specified for this parameter becomes available inside the function under the
name (alias) of the input parameter. Thus, the value is not copied, but used at the same address in
memory. Therefore, modifications to a parameter within a function are reflected in the state of its
associated argument. An important feature follows from this.
You can only specify a variable (LValue, see Assignment operator) as an argument for a reference
parameter. Otherwise, we'll get the "parameter passed as reference, variable expected" error.
Passing by reference is used in several cases:
• to improve the efficiency of the program by eliminating the copying of the value;
• to pass modified data from a function to the calling code when returning a single value with return
is not enough;
The first point is especially relevant for potentially large variables such as strings or arrays.
To distinguish between the first and second purposes of a reference parameter, the authors of the
function are encouraged to add the const modifier when the parameter inside the function is not

---

## Page 142

Part 2. Programming fundamentals
1 42
2.8 Functions
expected to change. This will remind you and make it clear to other developers that passing a variable
inside a function will not lead to side effects.
Not applying the const modifier to reference parameters where possible can lead to problems
throughout the entire function call hierarchy. The fact is that calling such functions will require non-
constant arguments. Otherwise, the error "constant variable cannot be passed as reference" will occur.
As a result, it may gradually turn out that all parameters in all functions should be stripped of the const
modifier for the sake of the code compilability. In fact, this actually expands the scope for potential
bugs with unintentional corruption of variables. The situation should be corrected in the opposite way:
put const wherever return and modification of values are not required.
To compare the ways of passing parameters in the FuncDeclaration.mq5 script, several functions are
implemented: FuncByValue — passing by value, FuncByReference — passing by reference,
 FuncByConstReference — passing by constant reference. 
void FuncByValue(int v)
{
   ++v;
   // we are doing something else with v
}
void FuncByReference(int &v)
{
   ++v;
}
void FuncByConstReference(const int &v)
{
   // error
   // ++v; // 'v' - constant cannot be modified
   Print(v); 
}
In the OnStart function, we call all these functions and observe their effect on i variable used as an
argument. Note that passing a parameter by reference does not change the function call syntax.

---

## Page 143

Part 2. Programming fundamentals
1 43
2.8 Functions
void OnStart()
{
   int i = 0;
   FuncByValue(i);          // i cannot change
   Print(i);                // 0
   FuncByReference(i);      // i is changing
   Print(i);                // 1
   FuncByConstReference(i); // i cannot change, 1
   const int j = 1;
   // error
   // 'j' - constant variable cannot be passed as a reference
   // FuncByReference(j);
   
   FuncByValue(10);         // ok
   // error: '10' - parameter passed as reference, variable expected
   // FuncByReference(10);
}
The literal can only be passed to FuncByValue function, since other functions require a reference, i.e. a
variable, as an argument.
Function FuncByReference cannot be called with the variable j, since the latter is declared as a
constant, and this function declares the ability (or intention) to change its parameter since it is not
equipped with the const modifier. This generates the "constant variable cannot be passed as reference"
error.
The script also describes the Transpose function: it transposes a 2x2 matrix passed as a two-
dimensional array by reference.
void Transpose(double &m[][2])
{
   double temp = m[1][0];
   m[1][0] = m[0][1];
   m[0][1] = temp;
}
Its call from OnStart demonstrates the expected change in the contents of the local array a.
double a[2][2] = {{-1, 2}, {3, 0}};
Transpose(a);
ArrayPrint(a);
In MQL5, array parameters are always passed as an internal structure of a dynamic array (see the
Characteristics of arrays section). As a consequence, the description of such a parameter must
necessarily have an open size in the first dimension, that is, it is empty inside the first pair of square
brackets.
This does not prevent, if necessary, passing to the function the actual argument, which is an array with
a fixed size (as in our example). However, functions like ArrayResize will not be able to resize or
otherwise reorganize such a masked fixed array.
The sizes of the array in all dimensions except the first must match for both, the parameter and
argument. Otherwise, we will get a "parameter conversion not allowed" error. In particular, the
TransposeVectorfunction is defined in the example:

---

## Page 144

Part 2. Programming fundamentals
1 44
2.8 Functions
void TransposeVector(double &v[])
{
}
An attempt to call it on a two-dimensional array a is commented out in OnStart because it generates
the above error: array dimensions do not match.
In addition to passing parameters by value or by reference, there is another option: passing a pointer.
Unlike C++, MQL5 only supports pointers for object types (classes). We will look at this feature in the
third Part.
2.8.5 Optional parameters
MQL5 provides an opportunity to specify default values for parameters when describing a function. For
this, the initialization syntax is used, that is, a literal of the corresponding type to the right of the
parameter, after the '=' sign. For example:
void function(int value = 0);
When calling a function, arguments for such parameters can be omitted. Then their values will be set to
their default values. Such parameters are called optional (optional).
Optional parameters must appear at the end of the parameter list. In other words, if the i-th parameter
is declared with initialization, then all subsequent parameters must also have it. Otherwise, a
compilation error "missing default value for parameter" is shown. Below is a description of a function
with such a problem.
double Largest(const double v1, const double v2 = -DBL_MAX,
               const double v3);
There are two solutions: either the parameter v3 must also have a default value, or the parameter v2
must become mandatory.
You can only omit optional arguments when calling a function from right to left. That is, if the function
has two parameters and both are optional, then when calling, you cannot skip the first one, but specify
the second one. The single value passed will be matched against the first parameter, and the second
will be considered omitted. If both arguments are missing, the empty parentheses are still needed.
Consider the function of finding the maximum number of three. The first parameter is mandatory, the
last two are optional and equal by default to the minimum possible number of type double. Thus, each
of them, in the absence of an explicitly passed value, will certainly be less than (or, in extreme cases,
equal to) all other parameters.
double Largest(const double v1, const double v2 = -DBL_MAX,
               const double v3 = -DBL_MAX)
{
   return v1 > v2 ? (v1 > v3 ? v1 : v3) : (v2 > v3 ? v2 : v3);
}
This is how you can call it:

---

## Page 145

Part 2. Programming fundamentals
1 45
2.8 Functions
Print(Largest(1));       // ok: 1
Print(Largest(0, -2));   // ok: 0
Print(Largest(1, 2, 3)); // ok: 3
With the help of optional parameters, MQL5 implements the concept of functions with a variable
number of parameters in custom functions.
MQL5 does not support the ellipsis syntax for defining functions with a variable number of parameters,
as C++ does. At the same time, there are built-in functions in the MQL5 API, which are described using
ellipsis and accept a variable number of arbitrary parameters. For example, it is the Print function. Its
prototype looks like this: void Print(argument, ...). Therefore, we can call it with up to 64 arguments
separated by commas (excluding arrays) and it will display them in the log.
2.8.6 Return values
Functions can return the values of built-in types, structures with fields of built-in types, as well as
pointers to functions and pointers to class objects. The type name is written in the function definition
before the name. If the function does not return anything, it should be assigned the void type.
To return from an array function, you must use parameters passed by reference (see Value parameters
and reference parameters).
A value is returned using the return statement, in which an expression is specified after the return
keyword. Any of the two forms may be used:
return expression ;
or:
return ( expression ) ;
If the function is of type void, then the return statement is simplified:
return ;
The return statement cannot contain any expression inside the void-function: the compiler will generate
an error "'return' - 'void' function returns a value".
For such functions, theoretically, it is not necessary to use return at the end of the block with the
function body. We saw this in the example of the OnStart function.
If the function has a type other than void, then the return statement must be mandatory. If it is not
present, a compilation error "not all control paths return a value" will occur.
int func(void)
{
   if(IsStopped()) return; // error: function must return a value
                           // error: not all control paths return a value  
}
It is important to note that a function body can have multiple return statements. In particular, in case
of early exits by condition. Any return statement breaks the execution of the function at the place
where it is located.

---

## Page 146

Part 2. Programming fundamentals
1 46
2.8 Functions
If a function must return a value (because it is not of type void), and it is not specified in the return
operator, the compiler will generate an error "function must return a value". The compiler-correct
version of the func function is given below (FuncReturn.mq5).
int func(void)
{
   if(IsStopped()) return 0;
   return 1;
}
If the return value differs from the specified function type, the compiler will attempt an implicit
conversion. In case the types require explicit conversion, an error will be generated.
To return a value, a temporary variable is implicitly created and made available to the calling code.
After we learn about object types (see the chapter on Classes) and the ability to return pointers to
objects from functions, we'll get back to considering how to pass them safely. Unlike C++, functions in
MQL5 are not capable of returning references. Attempting to declare a function with an ampersand in
the result type results in a "'&' - reference cannot used" error.
2.8.7 Function declaration
Function declaration describes a prototype without specifying a function body. Instead of a block with a
body, a semicolon is put.
The declaration is necessary for the compiler so that it can check in subsequent code fragments how
correctly the function is called by name, passing arguments to it and getting the result.
The entire function definition (including the body) is also a declaration, so there is no need to declare a
function in addition to the definition.
For example, the declaration of the Fibo function above could look like this.
int Fibo(const int n);
Separate function declarations and definitions are used when building a program from several files with
source text: then the declaration is made in the header file with the extension mqh (see the section
about the #include preprocessor directive ), which is included in files where the function is used, and
the function definition is implemented in only one of the files. Matching of the function signature in the
declaration and definition provides error protection. In other words, a single declaration guarantees the
consistency of changes made to the entire source code
If we declare a function and call it somewhere in the code, but do not provide a fully appropriate
definition for it, the compiler will throw an error: "function 'Name' must have a body". This often
happens when there are typos or inaccuracies either in the declaration or in the definition, as well as in
the process of changing the source codes, when some of the corrections have already been made, and
the other part has most likely been forgotten.
If the function is declared and not used anywhere, the compiler does not require its definition either -
such an element is simply "cut out" from the binary program.
In the Declaration/definition statements section, we considered an example of the Init function (script
StmtDeclaration.mq5), which was used to initialize variables. There, in particular, the problem was

---

## Page 147

Part 2. Programming fundamentals
1 47
2.8 Functions
demonstrated that the global variable k cannot be defined before the Init function, since the initial
value k is obtained by calling Init. The compiler through the error "'Init' is an unknown identifier".
Now we know that such a problem can be solved with a declaration. In the FuncDeclaration.mq5 script,
we added the following forward declaration of the Init function before the k variable, and left the  Init
definition after k.
// preliminary declaration
int Init(const int v);
// before adding preliminary declaration above
// here was an error: 'Init' is an unknown identifier
int k = Init(-1);
int Init(const int v)
{
   Print("Init: ", v);
   return v;
}
Now the script compiles normally. Technically, in this case, we could simply move the function above
the variable without a preliminary declaration. We did this to explain the concept. However, there are
cases of mutual dependence of language elements on each other (for example, classes), when it is
impossible to go without a preliminary declaration within the same file.
2.8.8 Recursion
It is allowed to call the same function from statements inside a function. Such calls are called
recursive.
Let's go back to the example of calculating Fibonacci numbers. Following the formula for calculating
each number as the sum of the previous two (except for the first two, which are equal to 1 ), it is easy
to write a recursive function for calculating Fibonacci numbers.
int Fibo(const int n)
{
   if(n <= 1) return 1;
   
   return Fibo(n - 1) + Fibo(n - 2);
}
A recursive function must be able to return control without recursion, as in our case inside the
conditional statement if for indexes 0 and 1 . Otherwise, the sequence of function calls could continue
indefinitely. In practice, because unfinished function calls accumulate in a limited area of   memory
called the stack (see the Declaration/Definition statements section, and the "Heap" and "Stack"
sidebar in the Describing arrays section), sooner or later the function will terminate with the "Stack
overflow" runtime error. This problem is shown in the FiboEndless function.

---

## Page 148

Part 2. Programming fundamentals
1 48
2.8 Functions
int FiboEndless(const int n)
{
   return FiboEndless(n - 1) + FiboEndless(n - 2);
}
Please note that this is not a compilation error. In such a case, the compiler will not even generate a
warning (although, technically it could). The error occurs during script execution. It will be printed to
the Experts journal in the terminal.
Recursion can occur not only when a function is called from the function itself. For example, if the F
function calls the G function which, in turn, calls the F function, this case is an indirect recursion. Thus,
recursion can occur as a result of cyclic calls of any depth.
2.8.9 Function overloading
MQL5 allows the definition of functions with the same name but with different numbers or types of
parameters in the same source code. This approach is called function overloading. It is usually applied
when the same action can be triggered by different inputs. Differences in signatures allow the compiler
to automatically determine which function to call based on the arguments passed. But there are some
specifics.
Functions cannot differ only in their return type. In this case. the overload mechanism is not triggered
and the "function already defined and has different type" error is returned.
If functions of the same name have different numbers of parameters and the "extra" parameters are
declared optional, then the compiler will not be able to determine which one to call. This will generate
the error "ambiguous call to overloaded function with the same parameters".
When an overloaded function is called, the compiler matches the arguments and parameters in the
available overloads. If no exact match is found, the compiler tries to add/remove the const modifier and
to perform numeric type expansion and arithmetic conversion. In the case of object pointers, class
inheritance rules are used.
With a different number of parameters or unrelated parameter types in the same position (such as a
number and a string), the choice is usually clear. However, if the parameter types are to be implicitly
converted from one to another, ambiguity may arise.
For example, we have two summation functions:
double sum(double v1, double v2)
{
   return v1 + v2;
}
int sum(int v1, int v2)
{
   return v1 + v2;
}
Then the following call will result in an error:

---

## Page 149

Part 2. Programming fundamentals
1 49
2.8 Functions
sum(1, 3.14); // overloaded function call is ambiguous
Here, the compiler is equally uncomfortable with each of the overloads: for the function double
sum(double v1 , double v2) it is necessary to implicitly convert the first argument to double, and for int
sum(int v1 , int v2) the second argument in int needs to be converted.
The term 'overload' should be interpreted in the sense that a reused name is "loaded" with "duties"
several times heavier than a regular name used only for one function.
Let's try to overload the function for matrix transposition. We already had an example for a 2x2 array
(see Value parameters and reference parameters). Let's implement the same operation for a 3x3
array. The size of a multidimensional array parameter in higher dimensions (non-zero) changes the
type, i.e. double [][2] is different from double [][3]. Thus, we will overload the old version of the
function:
void Transpose(double &m[][2]);
by adding a new one (FuncOverload.mq5):
void Transpose(double &m[][3]);
In the implementation of the new version, it is convenient to use the helper function Swap to exchange
two matrix elements at given indices.
void Transpose(double &m[][3])
{
   Swap(m, 0, 1);
   Swap(m, 0, 2);
   Swap(m, 1, 2);
}
void Swap(double &m[][3], const int i, const int j)
{
   static double temp;
   
   temp = m[i][j];
   m[i][j] = m[j][i];
   m[j][i] = temp;
}
Now we can call both functions from OnStart using the same notation for arrays of different sizes. The
compiler itself will generate a call to the correct versions.
double a[2][2] = {{1, 2}, {3, 4}};
Transpose(a);
...
double b[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
Transpose(b);
It is important to note that the const modifier on the parameter, although it changes the prototype of
the function, is not always a sufficient difference for overloading. Two functions of the same name,
which differ only in the presence and absence of const for some parameter, can be considered the
same. This will result in a "function already defined and has body" error. This behavior occurs because,
for value parameters, the const modifier is discarded when the argument is assigned (because a value

---

## Page 150

Part 2. Programming fundamentals
1 50
2.8 Functions
parameter, by definition, cannot change the argument in the calling code), and this does not allow one
of several overlapped functions to be selected based on it.
To demonstrate this, it is enough to add a function in the script:
void Swap(double &m[][3], int i, int j);
It is an unsuccessful overload for the existing one:
void Swap(double &m[][3], const int i, const int j);
The only difference between the two functions is the const modifiers for the i and j  parameters.
Therefore, they are both suitable for calling with arguments of type int and passing by value.
When parameters are passed by reference, overloading with a difference of only const/non-const
attributes succeeds because, for references, the const modifier is important (it changes the type and
eliminates the possibility of implicit conversion). This is demonstrated in the script with a couple of
functions:
void SwapByReference(double &m[][3], int &i, int &j)
{
   Print(__FUNCSIG__);
}
void SwapByReference(double &m[][3], const int &i, const int &j)
{
   Print(__FUNCSIG__);
}
void OnStart()
{
   // ...
   {
      int i = 0, j = 1;
      SwapByReference(b, i, j);
   }
   {
      const int i = 0, j = 1;
      SwapByReference(b, i, j);
   }
}
They are left as almost empty stubs, in which the signature of each function is printed using the
Print(_ _ FUNCSI_ _ )call. This makes it possible to ensure that the appropriate version of the function is
called depending on the const attribute of the arguments.
2.8.1 0 Function pointers (typedef)
MQL5 has the typedef keyword, which allows you to describe a special type of function pointer.
Unlike C++, where typedef has a much wider application, in MQL5 typedef is used only for function
pointers.
The syntax for a new type declaration is:

---

## Page 151

Part 2. Programming fundamentals
1 51 
2.8 Functions
typedef function_result_type ( *function_type )( [list_of_input_parameters] ) ;
The function_ type identifier defines a type name that becomes a synonym (alias) for a pointer to any
function that returns a value of the given type function_ result_ type and accepts a list of input
parameters (list_ of_ input_ parameters).
For example, we can have 2 functions with the same prototypes (two input parameters of type double
and the result type is also double) that perform different arithmetic operations: addition and
subtraction (FuncTypedef.mq5).
double plus(double v1, double v2)
{
   return v1 + v2;
}
double minus(double v1, double v2)
{
   return v1 - v2;
}
Their common prototype is easy to describe for use as a pointer:
typedef double (*Calc)(double, double);
This entry introduces the Calc type into the program, with which you can define a variable/parameter
for storing/passing a reference to any function with such a prototype, including both functions plus and
minus. This type is a pointer because the character '*' (*Calc) is used in the description. We will learn
more about the features of the asterisk as applied to pointers when studying OOP.
It is convenient to use such a class of pointers to create custom algorithms that can "on the fly" call
different functions corresponding to the alias, depending on the input data.
In particular, we can introduce a generalized calculator function:
double calculator(Calc ptr, double v1, double v2)
{
   if(ptr == NULL) return 0;
   return ptr(v1, v2);
}
Its first parameter is declared with the Calc type. Thanks to this, we can pass an arbitrary function with
a suitable prototype to it and, as a result, perform some operation, the essence of which the calculator
function itself does not know about. It does this by delegating the call to a pointer: ptr(v1 , v2). Because
ptr is a function pointer, this syntax not only resembles a function call but actually calls the function
that the pointer holds.
Note that we pre-check the ptr parameter against the special value NULL (NULL is the equivalent of
zero for pointers). The fact is that the pointer may not point anywhere, that is, it may not be initialized.
So, in the script, we have a global variable described:
Calc calc;
It has no pointers. If it weren't for the "protection" against NULL, calling calculator with an "empty"
pointer calc would result in a run-time error "Invalid function pointer call ".

---

## Page 152

Part 2. Programming fundamentals
1 52
2.8 Functions
Calls to the calculator function with different pointers in the first parameter will give the following
results (shown in the comments):
void OnStart()
{
   Print(calculator(plus, 1, 2));   //  3
   Print(calculator(minus, 1, 2));  // -1
   Print(calculator(calc, 1, 2));   //  0
}
Note that if there is no explicit initialization, all function pointers are filled with zero values. This applies
to both global and local variables of a given type.
A pointer type defined with typedef can be returned from functions, for example:
Calc generator(ushort type)
{
   switch(type)
   {
      case '+': return plus;
      case '-': return minus;
   }
   return NULL;
}
In addition, the type of function pointers is often used for callback functions (callback, see
FuncCallback.mq5). Suppose we have a DoMath function that performs lengthy calculations (probably, it
is implemented in a separate library). In terms of user interface convenience and friendliness, it would
be great to show the user a progress indication. For this purpose, you can define a special type of
function pointer for notifications about the percentage of work completed (ProgressCallback), and add a
parameter of this type to the DoMath function. In the DoMath code, you should periodically call the
passed function:
typedef void (*ProgressCallback)(const float percent);
void DoMath(double &bigdata[], ProgressCallback callback)
{
   const int N = 1000000;
   for(int i = 0; i < N; ++i)
   {
      if(i % 10000 == 0 && callback != NULL)
      {
         callback(i * 100.0f / N);
      }
      
      // long calculations
   }
}
Then the calling code can define the required callback function, pass a pointer to it to DoMath and
receive updates as the calculation progresses.

---

## Page 153

Part 2. Programming fundamentals
1 53
2.8 Functions
void MyCallback(const float percent)
{
   Print(percent);
}
  
void OnStart()
{
   double data[] = {0};
   DoMath(data, MyCallback);
}
Function pointers work only with custom functions defined in MQL5. They cannot point to built-in
functions of the MQL5 API.
2.8.1 1  Inlining
In order to improve code efficiency, modern compilers often use the following trick. When generating
executable code, some function calls are replaced directly by the function body (its statements). This
technique is called inlining. This speeds up the operation by avoiding the overhead associated with the
organization of the call and return from the function. From a programmer's point of view, inlining
doesn't change anything.
MQL5 supports inlining by default. If necessary, it can be disabled, but only in code profiling mode. The
inline keyword is reserved in MQL5 for compatibility with C++ source codes. Its presence or absence
before the function definition does not affect the generated program.
2.9 Preprocessor
Up to this moment, we have been studying MQL5 programming, assuming that source codes are
processed by the compiler, which converts their textual representation into binary (executable by the
terminal). However, the first tool that reads and, if necessary, converts source codes is the
preprocessor. This utility built into MetaEditor is controlled by special directives inserted directly into
the source code. It can solve a number of problems that programmers face when preparing source
codes.
Similarly to the C++ preprocessor, MQL5 supports the definition of macro substitutions (#define),
conditional compilation (#ifdef) and inclusion of other source files (#include ). In this chapter, we will
explore these possibilities. Some of them have limitations compared to C++.
In addition to the standard directives, the MQL5 preprocessor has its own specific ones, in particular, a
set of MQL program properties (#property), and functions import from separate EX5 and DLLs
(#import). We will address them in the fifth, sixth and seventh parts when studying various types of
MQL programs.
All preprocessor directives begin with a hash sign '#' followed by a keyword and additional parameters,
the syntax of which depends on the type of directive.
It is recommended to start a preprocessor directive from the very beginning of the line, or at least
after a whitespace indent (if the directives are nested). Inserting a directive inside source code
statements is considered a bad programming style (unlike MQL5, the C++ preprocessor does not allow
this at all).

---

## Page 154

Part 2. Programming fundamentals
1 54
2.9 Preprocessor
Preprocessor directives are not language statements and should not be terminated with a ';'. Directives
usually continue to the end of the current line. In some cases, they can be extended in a special way
for the following lines, which will be discussed separately.
The directives are executed sequentially, in the same order in which they occur in the text and taking
into account the processing of previous directives. For example, if another file is connected to a file
using the #include directive and a substitution rule is defined in the included file using #define, then this
rule starts working for all subsequent lines of code, including the header files included later.
The preprocessor does not process comments.
2.9.1  Including source files (#include)
The #include directive is used to include the contents of another file into the source code. The directive
produces the same action as if the programmer copies the text from the include file to the clipboard
and pastes it into the current file at the place where the directive is used.
Splitting source code into multiple files is a common practice when writing complex programs. Such
programs are built on a modular basis so that each module/file contains logically related code that
solves one or more related tasks.
Include files are also used to distribute libraries (sets of ready-made algorithms). The same library can
be included in different programs. In this case, the library update (the update of its header file) will be
automatically applied in all programs during their next compilation.
If the main files of MQL programs must have the mq5 extension, then the include files commonly have
the extension mqh ('h' at the end of the word means "header"). At the same time, it is permissible to
use the #include directive for other types of text files, for example, *.txt (see below). In any case, when
a file is included, the final program combined from the main mq5 file and all headers must still be
syntactically correct. For example, including a file with binary information (like a png image) will break
the compilation.
There are two types of #include statements:
#include <file_name>
#include "file_name"
In the first one, the file name is enclosed in angle brackets. The compiler searches for such files in the
terminal data directory in the MQL5/Include/ subfolder.
For the second one, with the name in quotes, the search is performed in the same directory which
contains the current file that uses the #include statement.
In both cases, the file can be located in subfolders within the search directory. In this case, you should
specify the entire relative hierarchy of folders before the file name in the directive. For example, along
with MetaTrader 5, there are many commonly used boot files, among which is DateTime.mqh with a set
of methods for working with date and time (they are designed as structures, the language constructs
that we will discuss in Part 3 devoted to OOP). The DateTime.mqh file is located in the Tools folder. To
include it in your source code, you should use the following directive:
#include <Tools/DateTime.mqh>
To demonstrate how to include a header file from the same folder as the source file with the directive,
let's consider the file Preprocessor.mq5. It contains the following directive:

---

## Page 155

Part 2. Programming fundamentals
1 55
2.9 Preprocessor
#include "Preprocessor.mqh"
It refers to the Preprocessor.mqh file, which is really located next to Preprocessor.mq5.
An include file can, in turn, include other files. In particular, inside Preprocessor.mqh there is the
following code:
double array[] =
{
   #include "Preprocessor.txt"
};
It means that the contents of the array are initialized from the given text file. If we look inside
Preprocessor.txt, we will see the text that complies with the array initialization syntax rules:
1, 2, 3, 4, 5
Thus, it is possible to collect source code from custom components, including generating it using other
programs.
Note that if the file specified in the directive is not found, the compilation will fail.
The order in which multiple files are included determines the order in which the preprocessor directives
in them are processed.
2.9.2 Overview of macro substitution directives
Macro substitution directives include two forms of the #define directive:
• simple, usually to define a constant
• defining a macro as a pseudo-function with parameters
In addition, there is a #undef directive to undo any of the previous #define definitions. If #undef is not
used, each defined macro is valid until the end of source compilation.
Macros are registered and then used in code by name, following the rules of identifiers. By convention,
macro names are written in capital letters. Macro names can overlap the names of variables, functions,
and other elements of the source code. Purposeful use of this fact allows the flexibility to change and
generate source code on the fly. However, an unintentional coincidence of a macro name with a
program element will result in errors.
The principle of operation of both forms of macro substitutions is the same. Using the #define directive,
an identifier is introduced, which is associated with a certain piece of text – a definition. If the
preprocessor finds a given identifier later in the source code, it replaces it with the text associated with
it. We emphasize that the macro name can be used in compiled code only after registration (this is
similar to the variable declaration principles, but only at the compilation stage).
Replacing a macro name with its definition is called expansion. The analysis of the source code occurs
progressively and by one line in a pass, but the expansion in each line can be performed an arbitrary
number of times, as in a loop, as long as macro names are found in the result. You cannot include the
same name in a macro definition: when substituting, such a macro will result in an "unknown identifier"
error.
In Part 3 of the book, we'll learn about templates, which also allow you to generate (or, in fact,
replicate) source code, but with different rules. If there are both, macro substitution directives and

---

## Page 156

Part 2. Programming fundamentals
1 56
2.9 Preprocessor
templates in the source code, the macros are expanded first, and then the code is generated from the
templates.
Macro names are highlighted in red in MetaEditor.
2.9.3 Simple form of #define
The simple form of the #define directive registers an identifier and the character sequence by which
the identifier should be replaced everywhere in the source codes after the directive, up to the end of
the program, or before the #undef directive with the same identifier.
Its syntax is:
#define macro_identifier [text]
The text starts after the identifier and continues to the end of the current line. The identifier and text
must be separated by an arbitrary number of spaces or tabs. If the required sequence of characters is
too long, then for readability you can split it into several lines by putting a backslash character '\' at
the end of the line.
#define macro_identifier text_beginning \
                           text_continued \
                           text_ending
The text can consist of any language constructs: constants, operators, identifiers, and punctuation
marks. If you substitute macro_ identifier instead of the found constructs in the source code, all of them
will be included in the compilation.
The simple form is traditionally used for several purposes:
1 .Flag declarations, which are then used for conditional compilation checks;
2. Named constant declarations;
3. Abbreviated notation of common statements.
The first point is characterized by the fact that nothing needs to be specified after the identifier - the
presence of a directive with a name is already enough for the corresponding identifier to be registered
and can be used in conditional directives #ifdef/ifndef. For them, it is only important whether the
identifier exists or not, i.e. it works in the flag mode: declared / not declared. For example, the following
directive defines the DEMO flag:
#define DEMO
It can then be used, say, to build a demo version of the program from which certain functions are
excluded (see the example in the conditional compilation section).
The second way to use a simple directive allows you to replace the "magic numbers" in the source
code with friendly names. "Magic numbers" are constants inserted into the source text, the meaning of
which is not always clear (because a number is just a number: it is desirable to at least explain it in a
comment). In addition, the same value can be scattered throughout different parts of the code, and if
the programmer decides to change it to another, then he will have to do this in all places (and hope
that he did not miss anything).

---

## Page 157

Part 2. Programming fundamentals
1 57
2.9 Preprocessor
With a named macro, these two problems are easily solved. For example, a script can prepare an array
with Fibonacci numbers to a certain maximum depth. Then it makes sense to define a macro with a
predefined array size and use it in the description of the array itself (Preprocessor.mq5).
#define MAX_FIBO 10
int fibo[MAX_FIBO]; // 10
void FillFibo()
{
   int prev = 0;
   int result = 1;
   for(int i = 0; i < MAX_FIBO; ++i) // i < 10
   {
      int temp = result;
      result = result + prev;
      fibo[i] = result;
      prev = temp;
   }
}
If the programmer subsequently decides that the size of the array needs to be increased, it is enough
for him to do this in one place - in the #define directive. Thus, the directive actually defines a certain
parameter of the algorithm, which is "hardwired" into the source code and is not available for user
configuration. The need for this arises quite often.
The question may arise how defining through #define differs from a constant variable in the global
context. Indeed, we could declare a variable with the same name and purpose, and even preserve the
uppercase letters:
const int MAX_FIBO = 10;
However, in this case, MQL5 will not allow defining an array with the specified size, since only constants
are allowed in square brackets, i.e. literals (and a constant variable, despite its similar name, is not a
constant). To solve this problem, we could define an array as dynamic (without specifying a size first)
and then allocate memory for it using the ArrayResize function - passing a variable as a size is not
difficult here.
An alternative way to define a named constant is provided by enums, but is limited to integer values   
only. For example:
enum
{
   MAX_FIBO = 10
};
But macro can contain a value of any type.
#define TIME_LIMIT     D'2023.01.01' 
#define MIN_GRID_STEP  0.005
The search for macro names in source texts for replacement is performed taking into account the
syntax of the language, that is, indivisible elements, such as variable identifiers or string literals, will
remain unchanged, even if they include a substring that matches one of the macros. For example, given

---

## Page 158

Part 2. Programming fundamentals
1 58
2.9 Preprocessor
the macro XYZ below, the variable XYZAXES will be kept as it is, and the name XYZ (because it is
exactly the same as the macro) will be changed to ABC.
#define XYZ ABC
int XYZAXES = 3; // int XYZAXES = 3
int XYZ = 0;     // int ABC = 0
Macro substitutions allow you to embed your code in the source code of other programs. This
technique is usually used by libraries that are distributed as mqh header files and connected to
programs using the #include directives.
In particular, for scripts, we can define our own library implementation of the OnStartfunction, which
must perform some additional actions without affecting the original functionality of the program.
void OnStart()
{
   Print("OnStart wrapper started");
   // ... additional actions
   _OnStart();
   // ... additional actions
   Print("OnStart wrapper stopped");
}
#define OnStart _OnStart
Suppose this part is in the included header file (Preprocessor.mqh).
Then the original function OnStart (in Preprocessor.mq5) will be renamed by the preprocessor in the
source code to _ OnStart (it is understood that this identifier is not used anywhere else for some other
purpose). And the new version of OnStart from the header calls _ OnStart, "wrapping" it into additional
statements.
The third common way to use the simple #define is to shorten the notation of language constructs. For
example, the title of an infinite loop can be denoted with one word LOOP:
#define LOOP for( ; !IsStopped() ; )
And then applied in code:
LOOP
{
   // ...
   Sleep(1000);
}
This method is also the main technique for using the #define directive with parameters (see below).
2.9.4 #define form as a pseudo-function
The syntax of the parametric form #define is similar to a function.

---

## Page 159

Part 2. Programming fundamentals
1 59
2.9 Preprocessor
#define macro_identifier(parameter,...) text_with_parameters
Such a macro has one or more parameters in parentheses. Parameters are separated by commas.
Each parameter is a simple identifier (often a single letter). Moreover, all parameters of one macro
must have different identifiers.
It is important that there is no space between the identifier and the opening parenthesis, otherwise the
macro will be treated as a simple form in which the replacement text starts with an opening
parenthesis.
After this directive is registered, the preprocessor will search the source codes for lines of the form:
macro_identifier(expression,...)
Arbitrary expressions can be specified instead of parameters. The number of arguments must match
the number of macro parameters. All found occurrences will be replaced with text_ with_ parameters, in
which, in turn, the parameters will be replaced with the passed expressions. Each parameter can occur
several times, in any order.
For example, the following macro finds the maximum of two values:
#define MAX(A,B) ((A) > (B) ? (A) : (B))
If the code contains the statement:
int z = MAX(x, y);
it will be "expanded" by the preprocessor into:
int z = ((x) > (y) ? (x) : (y));
Macro substitution will work for any data type (for which the operations applied inside the macro are
valid).
However, substitution can also have side effects. For example, if the actual parameter is a function call
or statement that modifies the variable (say, ++x), then the corresponding action can be performed
multiple times (instead of the intended one time). In the case of MAX, this will happen twice: during the
comparison and when getting values in one of the branches of the '?:' operator. In this regard, it makes
sense to convert such macros into functions whenever possible (especially considering that in MQL5
functions are automatically inlined).
There are parentheses around the parameters and around the entire macro definition. They are used to
ensure that the substitution of expressions as parameters or the macro itself inside other expressions
does not distort the computing order due to different priorities. Let's say the macro defines the
multiplication of two parameters (not yet enclosed in parentheses):
#define MUL(A,B) A * B
Then the use of the macro with the following expressions will produce unexpected results:
int x = MUL(1 + 2, 3 + 4); // 1 + 2 * 3 + 4
Instead of multiplication (1  + 2) * (3 + 4) which gives 21 , we have 1  + 2 * 3 + 4, i.e., 1 1 . The
appropriate macro definition should be like this:

---

## Page 160

Part 2. Programming fundamentals
1 60
2.9 Preprocessor
#define MUL(A,B) ((A) * (B))
You can specify another macro as a macro parameter. In addition, you can also insert other macros in
a macro definition. All such macros will be replaced sequentially. For example:
#define SQ3(X) (X * X * X)
#define ABS(X) MathAbs(SQ3(X))
#define INC(Y) (++(Y))
Then the following code will print 504 (MathAbs is a built-in function that returns the modulus of a
number, i.e. without a sign):
int x = -10;
Print(ABS(INC(x)));
// -> ABS(++(Y))
// -> MathAbs(SQ3(++(Y)))
// -> MathAbs((++(Y))*(++(Y))*(++(Y)))
// -> MathAbs(-9*-8*-7)
// -> 504
In the variable x, the value -7 will remain (due to the triple increment).
A macro definition can contain unmatched parentheses. This technique is used, as a rule, in a pair of
macros, one of which should open a certain piece of code, and the other should close it. In this case,
unmatched parentheses in each of them will become matched. In particular, in standard library files
available in the MetaTrader 5 distribution package, in Controls/Defines.mqh, the EVENT_MAP_BEGIN
and EVENT_MAP_END macros are defined. They are used to form the event processing function in
graphical objects.
The preprocessor reads the entire source text of the program line by line, starting from the main mq5
file and inserting the texts from the header files encountered in place. By the time any line of code is
read, a certain set of macros that are already defined is formed. It does not matter in which order the
macros were defined: it is quite possible that one macro refers in its definition to another, which was
described both above and below in the text. It is only important that in the line of source code where
the macro name is used, the definitions of all referenced macros are known.
Consider an example.
#define NEG(x) (-SQN(x))*TEN
#define SQN(x) ((x)*(x))
#define TEN 10
...
Print(NEG(2)); // -40
Here, the NEG macro uses the SQN and TEN macros, which are described below it. And this does not
prevent us from successfully using it in the code after all three #define-s.
However, if we change the relative position of the rows to the following:

---

## Page 161

Part 2. Programming fundamentals
1 61 
2.9 Preprocessor
#define NEG(x) (-SQN(x))*TEN
#define SQN(x) ((x)*(x))
...
Print(NEG(2)); // error: 'TEN' - undeclared identifier
...
#define TEN 10
we get an "undeclared identifier" compilation error.
2.9.5 Special operators '#' and '##' inside #define definitions 
Inside macro definitions, two special operators can be used:
·a single hash symbol '#' before the name of a macro parameter turns the contents of that
parameter into a string; it is allowed only in function macros;
·a double hash symbol '##' between two words (tokens) combines them, and if the token is a macro
parameter, then its value is substituted, but if the token is a macro name, it is substituted as is,
without expanding the macro; if as a result of "gluing" another macro name is obtained, it is
expanded;
In the examples in this book, we often used the following macro:
#define PRT(A) Print(#A, "=", (A))
It calls the Print function, in which the passed expression is displayed as a string thanks to #A, and
after the sign "equal", the actual value of A is printed.
To demonstrate '##', let's consider another macro:
#define COMBINE(A,B,X) A##B(X)
With it, we can actually generate a call to the SQN macro defined above:
Print(COMBINE(SQ,N,2)); // 4
The literals SQ and N are concatenated, after which the macro SQN expands to ((2)*(2)) and produces
the result 4.
The following macro allows you to create a variable definition in code by generating its name given the
parameters of the macro:
#define VAR(TYPE,N) TYPE var##N = N
Then the line of code:
VAR(int, 3);
is equivalent to the following:
int var3 = 3;
Concatenation of tokens allows the implementation of a loop shorthand over the array elements using a
macro.

---

## Page 162

Part 2. Programming fundamentals
1 62
2.9 Preprocessor
#define for_each(I, A) for(int I = 0, max_##I = ArraySize(A); I < max_##I; ++I)
  
// describe and somehow fill in the array x
double x[];
// ...
// implement loop through the array
for_each(i, x)
{
   x[i] = i * i;
}
2.9.6 Cancelling macro substitution (#undef)
Substitutions registered with #define can be undone if they are no longer needed after a particular
piece of code. For these purposes, the #undef directive is used.
#undef macro_identifier
In particular, it is useful if you need to define the same macro in different ways in different parts of the
code. If the identifier specified in #define has already been registered somewhere in earlier lines of
code (by another #define directive), then the old definition is replaced with the new one, and the
preprocessor generates the "macro redefinition" warning. The use of #undef avoids the warning while
explicitly indicating the programmer's intention not to use a particular macro further down the code.
#undef cannot undefine predefined macros.
2.9.7 Predefined preprocessor constants
MQL5 has several predefined constants that are equivalent to simple macros, but they are defined by
the compiler itself. The following table lists some of their names and meanings.
Name
Description
__COUNTER__
Counter (each mention in the text during macro expansion results in an
increase of 1 )
__DATE__
Compilation date (day)
__DATETIME__
Compilation date and time
__FILE__
The name of the compiled file
__FUNCSIG__
Current function signature
__FUNCTION__
Current function name
__LINE__
Line number in the compiled file
__MQLBUILD__,
__MQL5BUILD__
Compiler version
__RANDOM__
Random number of type ulong

---

## Page 163

Part 2. Programming fundamentals
1 63
2.9 Preprocessor
Name
Description
__PATH__
Path to compiled file
_DEBUG
Defined when compiling in debug mode
_RELEASE
Defined when compiling in normal mode
2.9.8 Conditional compilation (#ifdef/#ifndef/#else/#endif)
Conditional compilation directives allow you to include and exclude code fragments from the
compilation process. The #ifdef and #ifndef directives mark the beginning of the code fragment they
control. The fragment ends with the #endif directive. In the simplest case, the #ifdef syntax is as
follows:
#ifdef macro_identifier
  statements
#endif
If a macro with the specified identifier is defined above in the code using #define, then this code
fragment will participate in compilation. Otherwise, it is excluded. In addition to the macros defined in
the application code, the environment provides a set of predefined constants, in particular, the
_RELEASE and _DEBUG flags (see section Predefined constants): their names can also be checked in
conditional compilation directives.
The extended form #ifdef allows the specification of two pieces of code: the first will be included if the
macro identifier is defined, and the second if it is not. To do this, a fragment separator #else is inserted
between #ifdef and #endif.
#ifdef macro_identifier
  statesments_true
#else
  statements_false
#endif
The #ifndef directive works similarly, but fragments are included and excluded according to the reverse
logic: if the macro specified in the header is not defined, the first fragment is compiled, and if it is
defined, the second fragment is compiled.
For example, depending on the presence of the DEMO macro substitution, we may or may not call the
function for calculating Fibonacci numbers.
#ifdef DEMO
   Print("Fibo is disabled in the demo");
#else
   FillFibo();
#endif
In this case, if the DEMO mode is enabled, instead of calling the function, a message would be displayed
in the log, but since in the Preprocessor.mq5 script and all the included files there is no #define DEMO
definition, compilation proceeds according to branch #else, that is, the call to the FillFibo function gets
into the executable ex5 file.

---

## Page 164

Part 2. Programming fundamentals
1 64
2.9 Preprocessor
Directives can be nested.
#ifdef _DEBUG
   Print("Debugging");
#else
   #ifdef _RELEASE
      Print("Normal run");
   #else
      Print("Undefined mode!");
   #endif
#endif
2.9.9 General program properties (#property)
Using the #property directive, a programmer can set some properties of an MQL program. Some of
these properties are general, that is, applicable to any program, and we will consider them here. The
remaining properties are typical for specific types of MQL5 programs and will be discussed in the
relevant sections of Part 5 when describing the MQL5 API.
Directive #property has the following format:
#property key value
The key is one of the properties listed in the following table, in the first column. The second column
specifies how the value will be interpreted.
Property
Value
copyright
String with information about the copyright holder
link
String with a link to the developer's site
version
String with the program version number (for the MQL5 Market, it must
be in the "X.Y" format, where X and Y are integers corresponding to the
major and minor build numbers)
description
Line with program description (several #description directives are
allowed and their contents are combined)
icon
String, path to the file with the program logo in ICO format
stacksize
Integer specifying the size of the stack in bytes (by default it is from 4 to
1 6 MB, depending on the type of program and environment, 1  MB =
1 024*1 024 bytes); if necessary, the size increases up to 64 MB
(maximum)
All aforementioned string properties are the source of information for the program's properties dialog,
which opens when it starts. However, for scripts, this dialog is not displayed by default. To change this
behavior, you must additionally specify the #property script_ show_ inputs directive. In addition,
information about the rights is displayed in a tooltip when hovering the mouse cursor over the program
in the MetaTrader 5 Navigator.
The copyright, link, and version properties have already been seen in all the previous examples in this
book.

---

## Page 165

Part 2. Programming fundamentals
1 65
2.9 Preprocessor
The stack size stacksize is a recommendation: if the compiler finds local variables (usually arrays) in
the source code that exceed the specified value, the stack will be automatically increased during
compilation, but up to no more than 64 MB. If the limit is exceeded, the program will not even be able
to start: in the log (tab Log, and not Experts) the error "Stack size of 64MB exceeded. Reduce the
memory occupied by local variables" will occur.
Please note that such analysis and launch prevention only take into account a fixed snapshot of the
program at the time of launch. In the case of recursive function calls, the stack memory consumption
can increase significantly and lead to a stack overflow error, but already at the program execution
stage. For more information about the stack, see the note in Describing arrays.
The #property directives work only in the compiled mq5 file, and are ignored in all those included with
#include.

---

## Page 166

Part 3. Object Oriented Programming
1 66
 
Part 3. Object Oriented Programming in MQL5
At some point during the process of software development, the problem of the built-in types and set of
functions not being sufficient for the effective implementation of requirements becomes apparent. The
complexity of managing many small entities that make up the program grows like a snowball and
requires using some kind of technology capable of improving the convenience, productivity, and quality
of the programmer's work.
One of these technologies, implemented at the level of many programming languages, is called Object-
Oriented, and the programming style based on it is called Object-Oriented Programming (OOP),
respectively. The MQL5 programming language also supports it and therefore belongs to the family of
object-oriented languages, like C++.
From the name of the technology, it can be concluded that it is organized around objects. Essentially,
an object is a variable of a user-defined type, i.e., a type defined by a programmer using MQL5 tools.
The opportunity to create types that model the subject area makes programs more understandable and
simplifies their writing and maintenance.
In MQL5, there are several methods to define a new type, and each method is characterized by some
features that we will describe in the relevant sections. Depending on the method of description, user-
defined types are divided into classes, structures, and associations. Each of them can combine data
and algorithms, i.e., describe the state and behavior of applied objects.
In Part 1  of the book, we brought up the quote from one of the fathers of programming, Nicklaus Wirth,
that programs are a symbiosis of algorithms and data structures. So, the objects are essentially mini-
programs – each is responsible for solving its own, albeit small, but logically complete task. By
composing objects into a single system, you can build a service or product of arbitrary complexity.
Thus, with the OOP we get a new interpretation of the principle of "divide and conquer".
OOP should be thought of as a more powerful and flexible alternative to the procedural programming
style we explored in Part Two. At the same time, both approaches should not be contrasted: if
necessary, they can be combined, and in the simplest tasks, OOP can be left aside.
So, in this third Part of the book, we will study the basics of OOP and the possibilities of their practical
implementation in MQL5. In addition, we will talk about templates, interfaces, and namespaces.
MQL5 Programming for Traders – Source Codes from the Book. Part 3
Examples from the book are also available in the public project \MQL5\Shared Projects\MQL5Book
3.1  Structures and unions
A structure is the object type that is easiest to understand, so we'll start our introduction to OOP with
it. Structures have a lot in common with classes, which are the main building blocks in OOP, so
knowledge of structures will help in the future when moving to classes. At the same time, structures
have certain differences, some of which can be considered limitations, and some are considered
advantages. In particular, structures cannot have virtual functions, but they can be used for integration
with third-party DLLs.
The choice between structures and classes in the implementation of the algorithm is traditionally based
on the requirements for access to the elements of the object and the presence of internal business

---

## Page 167

Part 3. Object Oriented Programming
1 67
3.1  Structures and unions
logic. If a simple container with structured data is needed and its state does not need to be checked
for correctness (in programming this is called an "invariant"), then a structure will do just fine. If you
want to restrict access and support writing and reading according to some rules (which are formalized
in the form of functions assigned to the object, which we will discuss later), then it is better to use
classes.
MQL5 has built-in types of structures that describe entities that are in demand for trading, in
particular, rates (MqlRates), ticks (MqlTick), date and time (MqlDateTime), trade requests
(MqlTradeRequest), requests' results (MqlTradeResult) and many others. We will talk about them in
Part 6 of this book.
3.1 .1  Definition of structures
A structure consists of variables, which can be built-in or other user-defined types. The purpose of the
structure is to combine logically related data in a single container. Suppose we have a function that
performs a certain calculation and accepts a set of parameters: number of bars that show a history of
quotes for analysis, date when the analysis started, price type, and number of signals allocated (for
example, harmonics).
double calculate(datetime start, int barNumber,
                 ENUM_APPLIED_PRICE price, int components);
In reality, there may be more parameters and it won't be easy to pass them to the function as a list.
Moreover, based on the results of several calculations, it makes sense to save some of the best settings
in some kind of array. Therefore, it is convenient to represent a set of parameters as a single object.
The description of the structure with the same variables looks as follows:
struct Settings
{
   datetime start;
   int barNumber;
   ENUM_APPLIED_PRICE price;
   int components;
};
The description starts with the keyword struct followed by the identifier of our choice. This is followed
by a block of code in curly brackets, and inside it are descriptions of variables included in the structure.
Additionally, these are called fields or members of a structure. There is a semicolon after the curly
brackets since the whole notation is a statement defining a new type, and ';' is required after
statements.
Once the type is defined, we can apply it in the same way as built-in types. In particular, the new type
allows you to describe variable Settings in the program in the usual way.
Settings s;
It is important to note that a single structure description allows you to create an arbitrary number of
structure variables and even arrays of this type. Each structure instance will have its own set of
elements, and they will contain independent values.
To access members of a structure, a special dereference operator is provided — the dot character '.'.
To the left of it should be a variable of structure type, and to the right — an identifier of one of the
fields available in it. Here's how you can assign a value to a structure element:

---

## Page 168

Part 3. Object Oriented Programming
1 68
3.1  Structures and unions
void OnStart()
{
   Settings s;
   s.start = D'2021.01.01';
   s.barNumber = 1000;
   s.price = PRICE_CLOSE;
   s.components = 8;
}
There is a more convenient way to fill in the structure which is the aggregate initialization. In this case,
the sign '=' is written to the right of the structure variable, followed by a comma-separated list of initial
values   of all fields in curly brackets.
   Settings s = {D'2021.01.01', 1000, PRICE_CLOSE, 8};
The types of the value must match the corresponding element types. It is allowed to specify fewer
values than the number of fields: then the remaining fields will receive zero values.
Note that this method only works when the variable is initialized, at the time of its definition. It is
impossible to assign the contents of an already existing structure in this way, we will get a compilation
error.
   Settings s;
   // error: '{' - parameter conversion not allowed
   s = {D'2021.01.01', 1000, PRICE_CLOSE, 8};
Using the dereference operator, you can also read the value of a structure element. For example, we
use the number of bars to calculate the number of components.
   s.components = (int)(MathSqrt(s.barNumber) + 1);
Here MathSqrt is the built-in square root function.
We have introduced a new type, Settings, to make it easier to pass a set of parameters to a function.
Now it can be used as the only parameter of the updated function calculate:
double calculate(Settings &settings);
Notice the ampersand '&' in front of the parameter name, which means passing by reference.
Structures can only be passed as parameters by reference.
Structures are also useful if you need to return a set of values from a function rather than a single
value. Let's imagine that the calculate function should return not a value of the type double, but several
coefficients and some trading recommendations (trade direction and probability of success). Then we
can define the type of the structure Result and use it in the function prototype (Structs.mq5).

---

## Page 169

Part 3. Object Oriented Programming
1 69
3.1  Structures and unions
struct Result
{
   double probability;
   double coef[3];
   int direction;
   string status;
};
Result calculate(Settings &settings)
{
   if(settings.barNumber > 1000) // edit fields
   {
      settings.components = (int)(MathSqrt(settings.barNumber) + 1);
   }
   // ...
   // emulate getting the result
   Result r = {};
   r.direction = +1;
   for(int i = 0; i < 3; i++) r.coef[i] = i + 1;
   return r;
}
The empty curly brackets in the line Result r = {} represent the minimal aggregate initializer: it fills all
fields of the structure with zeros.
The definition and declaration of the structure type can, if necessary, be done separately (as a rule,
the declaration goes in the header mqh file, and the definition is in the mq5 file). This extended syntax
will be covered in the Chapter on Classes.
3.1 .2 Functions (methods) in structures
After receiving a result from the calculate function, it would be desirable to print it to the log, but the
Print function does not work with user-defined types: they themselves must provide a way to output
information.
void OnStart()
{
   Settings s = {D'2021.01.01', 1000, PRICE_CLOSE, 8};
   Result r = calculate(s);
   // Print(r);  // error: 'r' - objects are passed by reference only
   // Print(&r); // error: 'r' - class type expected
}
The comments show the attempts to call the Print function for the structure, and what follows
thereafter. The first error is caused by the fact that structure instances are objects, and objects must
be passed to functions by reference. At the same time, Print is expecting a value (one or several). The
use of an ampersand before the variable name in the second Print call means in MQL5 that the pointer
is received, and it is not a reference as one might think. Pointers in MQL5 are only supported for class
objects (not structures), hence the second "class type expected" error. We will learn more about
pointers in the next chapter (see Classes and interfaces).

---

## Page 170

Part 3. Object Oriented Programming
1 70
3.1  Structures and unions
We could specify in the Print call all the members of the structure separately (using dereference), but
this is rather troublesome.
For those cases when it is necessary to process the contents of the structure in a special way, it is
possible to define functions inside the structure. The syntax of the definition is no different from the
familiar global context functions, but the definition itself is located inside the structure block.
Such functions are called methods. Since they are located in the context of the corresponding block,
the fields of the structure can be accessed from them without the dereference operator. As an
example, let's write the implementation of the function print in the Resultstructure.
struct Result
{
   ...
   void print()
   {
      Print(probability, " ", direction, " ", status);
      ArrayPrint(coef);
   }
};
Calling a method of the structure instance is as simple as reading its field: the same '.' operator is
used.
void OnStart()
{
   Settings s = {D'2021.01.01', 1000, PRICE_CLOSE, 8};
   Result r = calculate(s);
   r.print();
}
Chapter on Classes will cover methods in more detail.
3.1 .3 Copying structures
Structures of the same type can be copied entirely into each other using the '=' assignment operator.
Let's demonstrate this rule using an example of the structure Result. We get the first instance of r from
the calculate function.

---

## Page 171

Part 3. Object Oriented Programming
1 71 
3.1  Structures and unions
void OnStart()
{
   ...
   Result r = calculate(s);
   r.print();
   // will output to the log:
   // 0.5 1 ok
   // 1.00000 2.00000 3.00000
   ...
   Result r2;
   r2 = r;
   r2.print();
   // will output to the log the same values:
   // 0.5 1 ok
   // 1.00000 2.00000 3.00000
}
Then, the variable Result r2 was additionally created, and the contents of the r variable, all fields
concurrently, were duplicated into it. The accuracy of the operation can be verified by outputting to
the log using the method print (the lines are given in the comments).
It should be noted that defining two types of structures with the same set of fields does not make the
two types the same. It is not possible to assign a structure to another one completely, only
memberwise assignment is permitted in such cases.
A little later, we'll talk about structure inheritance, which will give you more options for copying. The
fact is that copying works not only between structures of the same type but also between related
types. However, there are important nuances, which we will cover in the Layout and inheritance of
structures section.
3.1 .4 Constructors and destructors
Among the methods that can be defined for a structure, there are special ones: constructors and
destructors.
A constructor has the same name as the structure name and does not return a value (type void). The
constructor, if defined, will be called at the time of initialization for each new instance of the structure.
Due to this, in the constructor, the initial state of the structure can be calculated in a special way.
A structure can have multiple constructors with different sets of parameters, and the compiler will
choose the appropriate one based on the number and type of arguments when defining the variable.
For example, we can describe a pair of constructors in the structure Result: one without parameters,
and the second one with one string type parameter to set the status.

---

## Page 172

Part 3. Object Oriented Programming
1 72
3.1  Structures and unions
struct Result
{
   ...
   void Result()
   {
      status = "ok";
   }
   void Result(string s)
   {
      status = s;
   }
};
By the way, a constructor without parameters is called a default constructor. If there are no explicit
constructors, the compiler implicitly creates a default constructor for any structure that contains
strings and dynamic arrays to pad these fields with zeros.
It is important that fields of other types (for example, all numeric) are not reset to zero, regardless of
whether the structure has a default constructor, and therefore the initial values of the elements after
memory allocation will be random. You should either create constructors or make sure that the correct
values are assigned in your code immediately after the object is created.
The presence of explicit constructors makes it impossible to use the aggregate initialization syntax.
Because of it, the line Result r = {}; in the calculate method will not be compiled. Now we have the right
to use only one of the constructors that we provided ourselves. For example, the following statements
call the parameterless constructor:
   Result r1;
   Result r2();
And creating a structure with a filled status can be done like this:
   Result r3("success");
The default constructor (explicit or implicit) is also called when an array of structures is created. For
example, the following statement allocates memory for 1 0 structures with results and initializes them
with a default constructor:
   Result array[10];
A destructor is a function that will be called when the structure object is being destroyed. The
destructor has the same name as the structure name, but is prefixed with a tilde character '~'. The
destructor, like the constructor, does not return a value, but it does not take parameters either.
There can only be one destructor.
You cannot explicitly call the destructor. The program itself does this when exiting a block of code
where a local structure variable was defined, or when freeing an array of structures.
The purpose of the destructor is to release any dynamic resources if the structure allocated them in
the constructor. For example, a structure can have the persistence property, that is, save its state to a
file when it is unloaded from memory and restore it when the program creates it again. In this case, a
descriptor that needs to be opened and closed is used in the built-in file functions.

---

## Page 173

Part 3. Object Oriented Programming
1 73
3.1  Structures and unions
Let's define a destructor in the Result structure and add constructors along the way so that all these
methods keep track of the number of object instances (as they are created and destroyed).
struct Result
{
   ...
   void Result()
   {
      static int count = 0;
      Print(__FUNCSIG__, " ", ++count);
      status = "ok";
   }
   void Result(string s)
   {
      static int count = 0;
      Print(__FUNCSIG__, " ", ++count);
      status = s;
   }
   void ~Result()
   {
      static int count = 0;
      Print(__FUNCSIG__, " ", ++count);
   }
};
Three static variables named count exist independently of each other: each of them counts in the
context of its own function.
As a result of running the script, we will receive the following log:
Result::Result() 1
Result::Result() 2
Result::Result() 3
Result::~Result() 1
Result::~Result() 2
0.5 1 ok
1.00000 2.00000 3.00000
Result::Result(string) 1
0.5 1 ok
1.00000 2.00000 3.00000
Result::~Result() 3
Result::~Result() 4
Let's figure out, what it means.
The first instance of the structure is created in the function OnStart, in the same line where calculate is
called. When entering the constructor, the counter value count is initialized once with zero and then
incremented each time the constructor is executed, so for the first time, the value 1  is output.
Inside the calculate function, a local variable of type Result is defined; it is registered under number 2.

---

## Page 174

Part 3. Object Oriented Programming
1 74
3.1  Structures and unions
The third structure instance is not so obvious. The point is that to pass the result from the function, the
compiler implicitly creates a temporary variable, where it copies the data of the local variable. It is
likely that this behavior will change in the future, and then the local instance will "move" out of the
function without duplication.
The last constructor call is in a method with a string parameter, so the call count is 1 .
It is important that the total number of calls to both constructors is the same as the number of calls to
the destructor: 4.
We'll talk more about constructors and destructors in the Chapter on Classes.
3.1 .5 Packing structures in memory and interacting with DLLs
To store one instance of the structure, a contiguous area is allocated in memory, sufficient to fit all the
elements.
Unlike in C++, here structure elements follow one after another in memory and are not aligned on the
boundary of 2, 4, 8 or 1 6 bytes, depending on the size of the elements themselves (alignment
algorithms differ for different compilers and operating modes). Alignment of elements, the size of which
is less than the specified block, is performed by adding unused dummy variables to the composition of
the structure (the program does not have direct access to them). Alignment is used to optimize
memory performance.
MQL5 allows you to change the alignment rules if necessary, mainly when integrating MQL programs
with third-party DLLs that describe specific types of structures. For those, it is necessary to prepare an
equivalent description in MQL5 (see the section on importing libraries). It is important to note that
structures intended for integration should only have fields of a limited set of types in their definition. So,
they cannot use strings, dynamic arrays, as well as class objects, and pointers to class objects.
Alignment is controlled by the keyword pack added to the header of the structure. There are two
options:
struct pack(size) identifier
struct identifier pack(size)
In both cases, the size is an integer 1 , 2, 4, 8, 1 6. Or you can use sizeof(built-in_ type) operator as the
size, for example, sizeof(double).
The option pack(1 ), i.e. byte alignment, is identical to default behavior without pack modifier.
The special operator offsetof() allows you to find out the offset in bytes of a specific structure element
from its beginning. It has 2 parameters: structure object and element identifier. For example,
Print(offsetof(Result, status)); // 36
Before the status field in the Result structure, there are 4 double values and one int value: 36 in total.
When designing your own structures, it is recommended that you place the largest elements first, and
then the rest - in order of decreasing their size.

---

## Page 175

Part 3. Object Oriented Programming
1 75
3.1  Structures and unions
3.1 .6 Structure layout and inheritance
Structures can have other structures as their fields. For example, let's define the Inclosure structure
and use this type for the field data in the Main structure (StructsComposition.mq5):
struct Inclosure
{
   double X, Y;
};
struct Main
{
   Inclosure data;
   int code;
};
void OnStart()
{
   Main m = {{0.1, 0.2}, -1}; // aggregate initialization
   m.data.X = 1.0;            // assignment element by element
   m.data.Y = -1.0;
}
In the initialization list, the field data is represented by an additional level of curly brackets with field
values   Inclosure. To access fields of such a structure, you need to use two dereference operations.
If the nested structure is not used anywhere else, it can be declared directly inside the outer one.
struct Main2
{
   struct Inclosure2
   {
     double X, Y;
   }
   data;
   int code;
};
Another way of laying out structures is inheritance. This mechanism is typically used for building class
hierarchies (and will be discussed in detail in the corresponding section), but it is also available for
structs.
When defining a new type of structure, the programmer can indicate the type of the parent structure in
its header, after the colon sign (it must be defined earlier in the source code). As a result, all fields of
the parent structure will be added to the daughter structure (at its beginning), and the own fields of the
new structure will be located in memory behind the parent ones.

---

## Page 176

Part 3. Object Oriented Programming
1 76
3.1  Structures and unions
struct Main3 : Inclosure
{
   int code;
};
The parent structure here is not nested, but an integral part of the daughter structure. Because of it,
filling fields does not require additional curly brackets when initializing, or a chain of multiple
dereference operators.
   Main3 m3 = {0.1, 0.2, -1};
   m3.X = 1.0;
   m3.Y = -1.0;
All three considered structures Main, Main2, and Main3 have the same memory representation and size
of 20 bytes. But they are different types.
   Print(sizeof(Main));   // 20
   Print(sizeof(Main2));  // 20
   Print(sizeof(Main3));  // 20
As we said before (see Copying Structures), the assignment operator '=', can be used to copy related
types of structures, more specifically those that are linked by an inheritance chain. In other words, a
structure of a parent type can be written into a structure of a daughter type (in this case, the fields
added in the derived structure will remain untouched), or vice versa, a daughter type structure can be
written into a parent type structure (in this case, "extra" fields will be cut off).
For example:
   Inclosure in = {10, 100};
   m3 = in;
Here, variable m3 has a type Main3 inherited from Inclosure. As a result of the assignment m3 = in, the
fields X and Y (the common part for both types) will be copied from the variable in of the base type into
the fields X and Y in the variable m3 of the derived type. The field code of the variable m3 will remain
unchanged.
It does not matter whether the child structure is a direct descendant of the ancestor or a distant one,
i.e. the chain of inheritance can be long. Such copying of common fields works between "children",
"grandchildren" and other combinations of types from different branches of the "family tree".
If the parent structure only has constructors with parameters, it must be called from the initialization
list when the derived structure constructor is inherited. For example,

---

## Page 177

Part 3. Object Oriented Programming
1 77
3.1  Structures and unions
struct Base
{
   const int mode;
   string s;
   Base(const int m) : mode(m) { }
};
struct Derived : Base
{
   double data[10];
   // if we remove the constructor, we get an error:
   Derived() : Base(1) { } // 'Base' - wrong parameters count
};
In the Base constructor, we fill in the field mode. Since it has the modifier const, the constructor is the
only way to set a value for it, and this must be done in the form of a special initialization syntax after
the colon (you can no longer assign a constant in the body of the constructor). Having an explicit
constructor causes the compiler to not generate an implicit (parameterless) constructor. However, we
do not have an explicit parameterless constructor in the structure Base, and in its absence, any derived
class does not know how to correctly call the Base constructor with a parameter. Therefore, in the
structure Derived, it is required to explicitly initialize the base constructor: this is also done using the
initialization syntax in the constructor header, after the sign ':' - in this case, we call Base(1 ).
If we remove the constructor Derived, we get an "invalid number of parameters" error in the base
constructor, because the compiler tries to call the constructor for Base by default (which should have 0
parameters).
We'll cover the syntax and inheritance mechanism in more detail in the Class Chapter.
3.1 .7 Access rights
If necessary, in the description of the structure, you can use special keywords, which represent access
modifiers that limit the visibility of fields from outside the structure. There are three modifiers: public,
protected, and private. By default, all structure members are public, which is equivalent to the following
entry (using the Result structure as an example):
struct Result
{
public:
   double probability;
   double coef[3];
   int direction;
   string status;
   ...
};
All members below the modifier receive the appropriate access rights until another modifier is
encountered or the structure block ends. There can be many sections with different access rights,
however, they can be modified arbitrarily.
Members marked as protected are available only from the code of this structure and descendant
structures, i.e., it is assumed that they must have public methods, otherwise, no one will be able to
access such fields.

---

## Page 178

Part 3. Object Oriented Programming
1 78
3.1  Structures and unions
Members marked as private are accessible only from within the structure's code. For example, if you
add private before the status field, you will most likely need a method to read the status by external
code (getStatus).
struct Result
{
public:
   double probability;
   double coef[3];
   int direction;
   
private:
   string status;
   
public:
   string getStatus()
   {
      return status;
   }
   ...
};
It will be possible to set the status only through the parameter of the second constructor. Accessing
the field directly will result in the error "no access to private member 'status' of structure 'Result'":
// error:
// cannot access to private member 'status' declared in structure 'Result'
r.status = "message";
In classes, the default access is private. This follows the principle of encapsulation, which we will cover
in the Chapter on Classes.
3.1 .8 Unions
A union is a user-defined type composed of fields located in the same memory area, due to which they
overlap each other. This makes it possible to write a value of one type to a union, and then read its
internal representation (at the bit level) in the interpretation for another type. Thus it is possible to
provide non-standard conversion from one type to another.
Union fields can be of any built-in type, except for strings, dynamic arrays, and pointers. Also, in
unions, you can use structures with the same simple field types and without constructors/destructors.
The compiler allocates for the union a memory cell with a size equal to the maximum size among the
types of all elements. So, for the union with fields like long (8 bytes) and int (4 bytes), 8 bytes will be
allocated.
All fields of the union are located at the same memory address, that is, they are aligned at the
beginning of the union (they have an offset of 0, which can be checked using offsetof, see section
Packing Structures).
The syntax for describing a union is similar to the structure but uses the union keyword. It is followed
by an identifier and then a block of code with a list of fields.

---

## Page 179

Part 3. Object Oriented Programming
1 79
3.1  Structures and unions
For example, an algorithm might use an array of type double to store various settings, simply because
the type double is one of those with a maximum size in bytes equal to 8. Let's say among the settings
there are numbers like ulong. Since the type double is not guaranteed to accurately reproduce large
ulong values, you need to use a union to "pack" the ulong into a double and "unpack" it back.
#define MAX_LONG_IN_DOUBLE       9007199254740992
// FYI: ULONG_MAX            18446744073709551615
union ulong2double
{
   ulong U;   // 8 bytes
   double D;  // 8 bytes
};
ulong2double converter;
void OnStart()
{
   Print(sizeof(ulong2double)); // 8
   
   const ulong value = MAX_LONG_IN_DOUBLE + 1;
   
   double d = value; // possible loss of data due to type conversion
   ulong result = d; // possible loss of data due to type conversion
   
   Print(d, " / ", value, " -> ", result);
   // 9007199254740992.0 / 9007199254740993 -> 9007199254740992
   
   converter.U = value;
   double r = converter.D;
   Print(r);               // 4.450147717014403e-308
   Print(offsetof(ulong2double, U), " ", offsetof(ulong2double, D)); // 0 0
}
The size of the structure ulong2double is equal to 8 since both its fields have this size. Thus, the fields
U and D overlap completely.
In the realm of integers, 90071 99254740992 is the largest value that is guaranteed with robust
storage in double. In this example, we are trying to store one more number in double.
The standard conversion from ulong to double results in loss of precision: after writing
90071 99254740993 into a variable d of type double we read from its already "rounded" value
90071 99254740992 (for additional information about the subtleties of storing numbers in the type
double, see. section Real numbers).
When using the converter, the number 90071 99254740993 is written to the union "as is", without
conversions, since we are assigning it to a U field of type ulong. Its representation in terms of double is
available, again without conversions, from field D. We can copy it to other variables and arrays like
double without worrying.
Although the resulting value double looks strange, it exactly matches the original integer if it needs to
be extracted by reverse conversion: write to a D field of type double, then read from a U field of type
ulong.

---

## Page 180

Part 3. Object Oriented Programming
1 80
3.1  Structures and unions
A union can have constructors and destructors, as well as methods. By default, union members have
public access rights, but this can be adjusted using access modifiers, as in the structure.
3.2 Classes and interfaces
Classes are the main building block in the program development based on the OOP approach. In a
global sense, the term class refers to a collection of something (things, people, formulas, etc.) that
have some common characteristics. In the context of OOP, this logic is preserved: one class generates
objects that have the same set of properties and behavior.
In the previous chapters of this book, we familiarized ourselves with the built-in MQL5 types such as
double, int or string. The compiler knows how to store values of these types and what operations can
be performed on them. However, these types may not be very convenient to use when describing any
application area. For example, a trader has to work with such entities as a trading strategy, a signal
filter, a currency basket, and a portfolio of open positions. Each of them consists of a whole set of
related properties, subject to specific processing and consistency rules.
A program to automate actions with these objects could consist only of built-in types and simple
functions, but then you would have to come up with tricky ways to store and link properties. This is
where the OOP technology comes to the rescue, providing ready-made, unified, and intuitive
mechanisms for this.
OOP proposes to write all the instructions for storing properties, filling them correctly, and performing
permitted operations on objects of a particular user-defined type in a single container with source code.
It combines variables and functions in a certain way. Containers are divided into classes, structures,
and associations if you list them in descending order of capabilities and relevance.
We have already had an encounter with structures and associations in the previous chapter. This
knowledge will be useful for classes as well, but classes provide more tools from the OOP arsenal.
By analogy with a structure, a class is a description of a user-defined type with an arbitrary internal
storage method and rules for working with it. Based on it, the program can create instances of this
class, the objects that should be considered composite variables.
All user-defined types share some of the basic concepts that you might call OOP theory, but they are
especially relevant for classes. These include:
• abstraction
• encapsulation
• inheritance
• polymorphism
• composition (design)
Despite the tricky names, they indicate quite simple and familiar norms of the real world, transferred to
the world of programming. We'll start our dive into OOP by looking at these concepts. As for the syntax
for describing classes and how to create objects – we will discuss it later.
3.2.1  OOP fundamentals: Abstraction
We often use generalizing concepts in everyday life to convey the essence of information without going
into details. For example, to answer the question "how did you get here", a person can just say "by

---

## Page 181

Part 3. Object Oriented Programming
1 81 
3.2 Classes and interfaces
car". And it will be clear to everyone that we are talking about a vehicle on 4 wheels, with an engine
and a body for passengers. The specific brand, the color or the year of manufacture of the car does not
matter to us.
When working with the program, the user also does not really care what kind of algorithm is
implemented inside, as long as the program correctly performs its task. For example, sorting a list can
be done in a dozen different ways.
Thus, abstraction means providing a simple programming interface that leaves hidden all the
complexities and details of the implementation.
The programming interface is a set of functions that are defined in the context of a class and that
perform a set of actions according to the purpose of the objects. In addition to these interface
functions, there may be auxiliary, smaller functions, but they are available only inside the class. Similar
to structures, there is a special name for all functions of a class: they are called methods.
The implementation, as a rule, uses variables or arrays belonging to the object (according to the class
description) to store information. They are called 'fields' (this term comes from the fact that object
properties are often associated in a 1 :1  relationship with input fields in the user interface, or with fields
in databases, where the current state of the object can be saved so that it can be restored the next
time the program is launched).
Fields and methods, although described in the class, are related to a specific object: each instance has
its own allocated set of variables, they have values that are independent of the state of other objects,
and the methods work with the fields of their instance.
Interface and implementation must be independent. If desired, one implementation method should
be easy to replace with another without any impact on the programming interface. It is also very
important to design the interface based on the requirements of a particular task, and not to
customize it specifically for the implementation. The class developer must be able to view their
creation from two different points of view: 1 ) as the author of internal algorithms and data
structures; 2) as a potential picky customer who uses the class as a "black box" and its control
panel is the interface. It is recommended to start developing a class from thinking through the
programming interface to finding and choosing the implementation methods.
3.2.2 OOP fundamentals: Encapsulation
To understand what encapsulation is, let's go back to reality for a moment. When we purchase a
household appliance, it is usually "sealed" and under warranty. We are allowed to use it in normal
modes, but the manufacturer does not encourage us to open the case and start "digging inside". For
example, you can use special utilities to overclock the computer processor, but this also deprives us of
the warranty, because these actions can lead to equipment failure.
It is all the same with the development of classes. Nobody should be allowed to access internal
implementation, so as not to disrupt the class. This is called encapsulation, that is, including everything
important in a capsule. In MQL5, as in C++, there are 3 levels of access rights. By default, the class
organization is private, i.e. hidden from all its users. Only the source code of the class itself has access
to the content.
Class users are also programmers. Even if you're writing a class for yourself, it makes sense to take
advantage of the maximum restrictions so as not to accidentally break the class (after all, people tend
to make mistakes and forget the features of their own code after a while, and programs have a
tendency to grow indefinitely).

---

## Page 182

Part 3. Object Oriented Programming
1 82
3.2 Classes and interfaces
The second level of access allows the "relatives" (more precisely, the heirs; we will come back to them
in a couple of paragraphs) to take a look inside. 
Finally, the third level of access that you can choose is public. It is intended specifically for external
programming interfaces that allow objects to be used from any part of the program for their main
purpose.
Each method or field has one of three access levels, which is determined by the class developer.
3.2.3 OOP fundamentals: Inheritance
When building large and complex projects, people seek ways to make the process more efficient. One of
the popular ways is leveraging existing developments. For example, it is much easier to develop a
building plan not from scratch but based on the previous blueprints.
Code reuse in programming is also very popular. We already know one such technique: isolating a piece
of code into a function and then calling it from different places where the corresponding functionality is
required. But OOP provides a more powerful mechanism: when developing a new class, it can inherit
from another, acquiring all the internal structure and external interface, requiring only minimum
adjustment to suit the purpose. Thus, starting from the parent class, you can quickly "grow" a derived
class with additional or refined abilities. Also, any subsequent changes to the parent class (such as
enhancements or bug fixes) will automatically affect all child classes.
When a class is the parent of another, it is referred to as the base class. In turn, the class that is
inherited from the base class is called derived.
Of course, the chain of inheritance (or rather, the family tree) can be continued: each class can have
several heirs, those, in turn, have their heirs, and so on. The only thing that inheritance rules do not
allow is cycles in kinship relationships, for example, a grandson cannot be the parent of its grandfather.
The relationship between any class and its descendant of any generation is described by the word "is
a", that is, the descendant is able to act as an ancestor, but not vice versa. This is because the derived
object actually contains the data model of the ancestor and supplements it with new fields and
behavior.
By inheriting classes from each other, we get the opportunity to process related objects in a unified
way, as some of their functions are common.
For example, a hypothetical drawing program can be used to implement several types of shapes,
including circles, squares, triangles, and so on. Each object has coordinates on the screen (for
simplicity, we will assume that a pair of X and Y values of the shape center is specified). In addition,
each shape is rendered using its own background color, border color, and border thickness.
This means that we can implement functions for setting the coordinates and setting the drawing style
only once in the parent class describing the abstract shape, and these functions will be automatically
inherited by all the descendants.
Moreover, in order to simplify the source code, it is desirable to somehow unify not only the settings
but also the drawing of different shapes. This phrase contains some kind of contradiction: since the
shapes are different, and each must be displayed in its own way, what kind of unification are we talking
about? We're talking about a unified software interface. Indeed, according to the concept of
abstraction, it is necessary to separate the external interface from the internal implementation. And
the display of specific shapes is essentially an implementation detail.

---

## Page 183

Part 3. Object Oriented Programming
1 83
3.2 Classes and interfaces
A unified interface and different implementations for shape types smoothly lead us to the next concept
– polymorphism.
3.2.4 OOP fundamentals: Polymorphism
The term polymorphism means variability or diversity. This is the inverse of abstraction combined with
the inheritance mechanism. When we have a common programming interface, it can be implemented
by different classes which are linked by relations of inheritance. Then calling interface methods will
cause the task to be performed in different ways.
For example, imagine a family of abstract vehicles that includes a couple of certain types: a car and a
helicopter. The command to move from point A to point B will be executed by them equally well, but
the car will make its way on the ground, and the helicopter in the air.
Let's continue the example with the drawing program. We can say that the diversity in it is laid down at
the level of graphic shapes. The user is free to draw any combination of circles, squares, and triangles.
Each of these objects must be able to display itself on the screen using its own coordinates and its own
style, but the most important thing is to do it in a way that produces an appropriate form.
The program will most likely have an array (or another container) that stores all the shapes created by
the user, and displaying the entire drawing on the screen should consist in sequentially drawing each
shape. If we reduce drawing instructions for shapes into a separate method (let's call it draw), then
each class will have its own implementation. However, the headers of these functions will be completely
identical, since they perform the same task, and take the initial data from the objects.
Therefore, we have the opportunity to unify the source code, since the same call to draw inside the
loop over shapes exhibits polymorphism: the displayed shape will depend on the type of object.
3.2.5 OOP fundamentals: Composition (design)
When designing programs using OOP, there is a problem of finding the optimal (according to some given
characteristics) division into classes and relations between them. The term "composition" can be
ambiguous and is often used with different meanings, including one of the special cases of "composing"
classes. This digression is necessary because when reading other computer literature, you can find
different interpretations of the term "compositions": both in a generalized and in a narrower sense. We
will try to explain this concept, specifying the meaning of the terms in each case (when it means the
general "design/project development" of the software interface, and when it means "compositional
aggregation").
So, the class, as we know, consists of fields (properties) and methods. Properties, in turn, can be
described by custom types, that is, they can be objects of another class. There are several ways to
logically connect these objects:
·Composition (full inclusion or compositional aggregation) of objects-fields into an owner object.
The relationship of such objects is described by the "whole-part" relationship, and the part cannot
exist outside the whole. The owner object is said to "have a" property object, and the property
object is a "part of" the owner object. The owner creates and destroys its parts. Deleting the owner
removes all of its parts; the owner cannot exist without parts.
·Aggregation of objects-fields by the owner object is a "softer" inclusion. Although the relationship
is also described as "whole-part", the owner only contains references to parts that can be
assigned, changed, and exist in isolation from the whole. Moreover, one part can be used in several
"owners".

---

## Page 184

Part 3. Object Oriented Programming
1 84
3.2 Classes and interfaces
·Association, that is, a one- or two-way connection of independent objects that has an arbitrary
applied meaning; one object is said to "use" another.
Another type of relationship to keep in mind is "is a", discussed earlier in the inheritance section.
An example of a full inclusion is a car and its engine. Here, a car is understood as a full-fledged means
of transportation. It's not like that without a motor. And a particular engine belongs to only one car at
a time. Situations when there is no engine in the car yet (at the factory) or it no longer exists (in the
car repair shop) are equivalent to the fact that we broke the source code of the program.
An example of aggregation is the composition of groups of students for studies of certain courses: a
group for each course includes several students, and any of them can belong to other groups (if
listening to several subjects). The group "has" listeners. The exit of a student from the group does not
affect the educational process of the group (the rest continue to study).
Finally, to demonstrate the idea of association, consider a computer and a printer. We can say that the
computer uses the printer to print. The printer can be turned on or off as needed, and the same printer
can be used from different computers. All computers and printers exist independently of each other but
can be shared.
As for the characteristics that are customary to guide the design of classes, the most famous include:
·DRY (Don't repeat yourself) – instead, move common parts into parent (possibly abstract) classes.
·SRP (Single Responsibility Principle) – one class should perform one task, and if this is not the
case, you need to split it into smaller ones.
·OCP (Open-Closed Principle) – "write code open for extension but closed for modification". If
several calculation options are hardcoded in the X class and new ones may appear, make a base
(abstract) class for a separate calculation and create specific options ("extension" of the
functionality) on its basis, connected to class X without modifying it.
These are just a few of the class design best practices. After mastering the basics of OOP within the
scope of this book, it may be helpful to look at other specialized sources of information on the topic, as
they provide ready-made solutions for object decomposition in many common situations.
3.2.6 Class definition
The class definition statement has many optional components that affect its characteristics. In a
generalized form, it can be represented as follows:
class class_name [: modifier_access name_parent_class ...]
{
  [ modifier_access:]
     [description_member...]
  ...
};
To make the presentation easier, we will start with the minimum sufficient syntax and will expand it as
we move through the material.
As a starting ground, we use a task with a conditional drawing program that supports several types of
shapes.
To define a new class, use the class keyword, followed by the class identifier and a block of code in
curly brackets. Like all statements, such a definition must end with a semicolon.

---

## Page 185

Part 3. Object Oriented Programming
1 85
3.2 Classes and interfaces
The code block can be empty. For example, a compilable template of class Shape for a drawing
program looks like this:
class Shape
{
};
From the previous chapters of the book, we know that curly brackets denote the context or scope of
variables. When such blocks occur in a function definition, they define its local context. In addition to it,
there is a global context in which the functions themselves are defined, as well as global variables.
This time, the parentheses in the class definition define a new kind of context, the class context. It is a
container for both variables and functions declared inside the class.
The description of variables for storing class properties is done by the usual statements inside the block
(Shapes1 .mq5).
class Shape
{
   int x, y;              // center coordinates
   color backgroundColor; // fill color
};
Here we have declared some of the fields discussed in the theoretical sections: the coordinates of the
shape center and the fill color.
After such a description, the user-defined type Shape becomes available in the program along with the
built-in types. In particular, we can create a variable of this type, and it will contain the specified fields
inside. However, we cannot yet do anything with them and even make sure that they are there.
void OnStart()
{
   Shape s;
   // errors: cannot access private member declared in class 'Shape'
   Print(s.x, " ", s.y);
}
Class members are private by default, and therefore cannot be accessed from other parts of the code
external to the class. This is the principle of encapsulation in action.
If we try to output a shape to the log, the result will disappoint us for several reasons.
The most straightforward approach will cause the "objects are only passed by reference" error (we've
seen this with structures too):
Print(s); // 's' - objects are passed by reference only
Objects may consist of many fields, and because of their large size, it is inefficient to pass them by
value. Therefore, the compiler requires object type parameters to be passed by reference, while Print
takes values.
From the section about function parameters (see section Value parameters and reference parameters),
we know that the symbol '&' is used to describe references. It would be logical to assume that in order
to obtain a reference to a variable (in this case, an object s of type Shape) it is necessary to put the
same sign before its name.

---

## Page 186

Part 3. Object Oriented Programming
1 86
3.2 Classes and interfaces
Print(&s);
This statement compiles and runs without problem but does not quite do what was expected.
The program outputs some integer number during execution, for example, 1  or 20971 52 (it will most
likely be different). An ampersand sign in front of a variable name means getting a pointer to this
variable, not a reference (as opposed to a function parameter description).
Pointers will be discussed in detail in a separate section. However, note that MQL5 does not provide
direct access to memory, and the pointer to an object is a descriptor, or in a simple way, a unique
object number (it is assigned by the terminal itself). But even if the pointer pointed to an address in
memory (as it does in C++), that would not provide a legal way to read the object's contents.
To output the contents of Shape objects to the log or whatever, a class member function is required.
Let's call it toString: it should return a string with some description of the object. We can decide later
what to display in it. Let's also reserve the draw method for drawing the shape. For now, it will act as a
declaration of the future object programming interface.
class Shape
{
   int x, y;              // center coordinates
   color backgroundColor; // fill color
   
   string toString()
   {
      ...
   }
   
   void draw() { /* future drawing interface stub */ }
};
The definition of method functions is done in the usual way, with the only difference being that they are
located inside the block of code that forms the class.
In the future, we will learn how to separate the declaration of a function inside the class block and
its definition outside the block. This approach is often used to put declarations in a header file and
"hide" definitions in an mq5 file. This makes the code more understandable (due to the fact that
the programming interface is presented separately, in a compact form, without implementation). It
also allows software libraries to be distributed as ex5 files if needed (without the main source code
but providing a header file that is sufficient to call the external interface methods).
Because the method toString is part of the class, it has access to variables and can convert them to a
string. For example,
string toString()
{
  return (string)x + " " + (string)y;
}
However, now toString and draw are private, as are the rest of the fields. We need to make them
available from outside the class.

---

## Page 187

Part 3. Object Oriented Programming
1 87
3.2 Classes and interfaces
3.2.7 Access rights
A special syntax is provided for editing access to class members (we already met it in the chapter on
structures). Anywhere in the block, before the description of class members, you can insert a modifier:
one of the three keywords — private, protected, public — and a colon sign.
All members following the modifier, until another modifier is encountered, or up to the end of the class,
will receive the corresponding visibility constraint.
For example, the following entry is identical to the previous description of the class Shape, because the
mode private is assumed for classes without modifiers:
class Shape
{
private:
   int x, y;              // center coordinates
   color backgroundColor; // fill color
   ...
};
If we wanted to open access to all fields, we would change the modifier to public
class Shape
{
public:
   int x, y;              // center coordinates
   ...
};
But that would violate the principle of encapsulation, and we won't do that. Instead, we insert the
modifier protected: it allows access to members from derived classes while leaving them hidden from
the outside world. We are planning to extend the class Shape to several other shape classes that will
need access to the parent's variables.
class Shape
{
protected:
   int x, y;              // center coordinates
   color backgroundColor; // fill color
   
public:
   string toString() const
   {
      return (string)x + " " + (string)y;
   }
   
   void draw() { /* shape drawing interface stub */ }
};
Along the way, we made both functions public.
Modifiers can be interleaved in the class description in an arbitrary way and repeated many times.
However, in order to improve the readability of the code, it is recommended to make one section of
public, protected, and private members, and withstand the same order in all classes of the project.

---

## Page 188

Part 3. Object Oriented Programming
1 88
3.2 Classes and interfaces
Note that we added the keyword const to the end of the header of the toString function. It means that
the function does not change the state of the object fields. Although not required, it helps prevent
accidental corruption of variables and also lets users of the class and the compiler know that calling the
function will not result in any side effects.
In the toString function, as in any class method, the fields are accessible by their names. Later, we'll
see how to declare methods as static: they are related entirely to the class, not to object instances,
and therefore fields cannot be accessed.
Now we can call the method toString from the object variable s:
void OnStart()
{
   Shape s;
   Print(s.toString());
}
Here we see the use of the dot character '.' as a special dereference operator: it provides access to
the members of the object – fields and methods. To the left of it should be an object, and to the right –
the identifier of one of the available properties.
The method toString is public, and therefore accessible from an external to the class function OnStart.
If we tried in OnStart to "reach out" to the fields s.x or s.y through dereference, we would get a
compilation error "cannot access protected member declared in class 'Shape'".
For C++ professionals, we note that MQL5 does not support so-called "friends" (for the rest, let's
explain that in C++ it is possible, if necessary, to make a kind of "whitelist" of third-party classes and
methods that have extended rights, although they are not "relatives").
When we run the program, we will see that it outputs a couple of numbers. However, the coordinate
values will be random. Even if you are lucky enough to see nulls, it does not guarantee that they will
appear the next time you run the script. As a rule, if the list of executing MQL programs does not
change in the terminal, repeated launches of any script result in the allocation of the same memory
area to it, which may give the deceptive impression that the state of the object is stable. In fact, the
fields of an object, as in the case of local variables, are not initialized with anything by default (see
section Initialization).
To initialize them, special class functions, constructors, are used.
3.2.8 Constructors: default, parametric, and copying
We have already encountered constructors in the chapter on structures (see section Constructors and
destructors). For classes, they work in much the same way. Let's get back to the main points and
consider further features.
A constructor is a method having the same name as the class and is of type void, meaning it does not
return a value. Usually, the keyword void is omitted before the constructor name. A class can have
several constructors: they must differ in the number or type of parameters. When a new object is
created, the program calls the constructor so that it can set the initial values for the fields.
One of the ways to create an object that we used is the description in the code of the variable of the
corresponding class. The constructor will be called on this string. It happens automatically.  
Depending on the presence and types of parameters, constructors are divided into:

---

## Page 189

Part 3. Object Oriented Programming
1 89
3.2 Classes and interfaces
• default constructor: no parameters;
• copy constructor: with a single parameter which is the type of a reference to an object of the same
class;
• parametric constructor: with an arbitrary set of parameters, except for a single reference for
copying shown above.
Default constructor
The simplest constructor, without parameters, is called the default constructor. Unlike C++, MQL5
does not consider a default constructor to be a constructor that has parameters and all of them have
default values   (that is, all parameters are optional, see section Optional parameters).
Let's define a default constructor for the class Shape.
class Shape
{
   ...
public:
   Shape()
   {
      ...
   }
};
Of course, it should be done in the public section of the class.
Constructors are sometimes deliberately made protected or private to control how objects are created,
for example, through factory methods. But in this case, we are considering the standard version of
class composition.
To set initial values for object variables, we could use the usual assignment statements:
public:
   Shape()
   {
      x = 0;
      y = 0;
      ...
   }
However, the constructor syntax provides another option. It is called the initialization list and is written
after the function header, separated by a colon. The list itself is a comma-separated sequence of field
names, with the desired initial value in parentheses to the right of each name.
For example, for the constructor Shape it can be written as follows:

---

## Page 190

Part 3. Object Oriented Programming
1 90
3.2 Classes and interfaces
public:
   Shape() :
      x(0), y(0),
      backgroundColor(clrNONE)
   {
   }
This syntax is preferred over assigning variables in the body of a constructor for several reasons.
First, the assignment in the function body is made after the corresponding variable has been created.
Depending on the type of the variable, this may mean that the default constructor was first called for it
and then the new value was overwritten (and this means extra expenses). In the case of an initialization
list, the variable is immediately created with the desired value. It is likely that the compiler will be able
to optimize the assignment in the absence of an initialization list, but in the general case, this is not
guaranteed.
Secondly, some class fields can be declared with the const modifier. Then they can only be set in the
initialization list.
Thirdly, field variables of user-defined types may not have a default constructor (that is, all available
constructors in their class have parameters). This means that when you create a variable, you need to
pass actual parameters to it, and the initialization list allows you to do this: the argument values are
specified inside parentheses, as if in an explicit constructor call. An initialization list can be used in
constructor definitions, but not in other methods.
Parametric constructor
A parametric constructor, by definition, has multiple parameters (one or more).
For example, imagine that for coordinates x and y a special structure with a parametric constructor is
described:
struct Pair
{
   int x, y;
   Pair(int a, int b): x(a), y(b) { }
};
Then we can use the coordinates field of the new type Pair instead of the two integer fields x and y in
the Shape class. This construction of objects is called inclusion or compositional aggregation. The Pair
object is an integral part of the object Shape. A coordinate pair is automatically created and destroyed
along with the "host" object.
Because Pair does not have a parameterless constructor, the coordinates field must be specified in the
initialization list of the Shape constructor, with two parameters (int, int):

---

## Page 191

Part 3. Object Oriented Programming
1 91 
3.2 Classes and interfaces
class Shape
{
protected:
   // int x, y;
   Pair coordinates;  // center coordinates (object inclusion)
   ...
public:
   Shape() :
      // x(0), y(0),
      coordinates(0, 0), //object initialization
      backgroundColor(clrNONE) 
   {
   }
};
Without an initialization list, such automatic objects cannot be created.
Given the change in how coordinates are stored in the object, we need to update the toStringmethod:
   string toString() const
   {
      return (string)coordinates.x + " " + (string)coordinates.y;
   }
But this is not the final version: we will make some more changes soon.
Recall that automatic variables were described in the Declaration/Definition Instructions section.
They are called automatic because the compiler creates them (allocates memory) automatically,
and also automatically deletes them when program execution leaves the context (block of code) in
which the variable was created.
In the case of object variables, automatic creation means not only memory allocation but also a
constructor call. The automatic deletion of an object is accompanied by a call to its destructor (see
below section Destructors). Moreover, if the object is part of another object, then its lifetime
coincides with the lifetime of its "owner", as in the case of the field coordinates — an instance of
Pair in the object Shape.
Static (including global) objects are also managed automatically by the compiler.
An alternative to automatic allocation is dynamic object creation and manipulation via pointers.
In the inheritance section, we will learn how one class can be inherited from another. In this case, the
initialization list is the only way to call the parametric constructor of the base class (the compiler is not
able to automatically generate a constructor call with parameters, as it does implicitly for the default
constructor).
Let's add another constructor to the class Shape 
that allows you to set specific values   to variables. It
will just be a parametric constructor (you can create as many of them as you like: for different
purposes and with a different set of parameters).

---

## Page 192

Part 3. Object Oriented Programming
1 92
3.2 Classes and interfaces
   Shape(int px, int py, color back) :
      coordinates(px, py),
      backgroundColor(back)
   {
   }
The initialization list ensures that when the body of the constructor is executed, all internal fields
(including nested objects, if any) have already been created and initialized.
The order of initialization of class members does not correspond to the initialization list but to the
sequence of their declaration in the class.
If a constructor with parameters is declared in a class, and it is required to allow the creation of
objects without arguments, the programmer must explicitly implement the default constructor
In the event that there are no constructors at all in the class, the compiler implicitly provides a default
constructor in the form of a stub, which is responsible for initializing fields of the following types:
strings, dynamic arrays, and automatic objects with a default constructor. If there are no such fields,
the implicit default constructor does nothing. Fields of other types are not affected by the implicit
constructor, so they will contain random "garbage". To avoid this, the programmer must explicitly
declare the constructor and set the initial values.
Copy constructor
The copy constructor allows you to create an object based on another object passed by reference as
the only parameter.
For example, for the class Shape, the copy constructor might look like this:
class Shape
{
   ...
   Shape(const Shape &source) :
      coordinates(source.coordinates.x, source.coordinates.y),
      backgroundColor(source.backgroundColor)
   {
   }
   ...
};
Note that protected and private members of another object are available in the current object because
permissions work at the class level. In other words, two objects of the same class can access each
other's data when given a reference (or pointer).
If there is such a constructor, you can create objects using one of two syntax types:

---

## Page 193

Part 3. Object Oriented Programming
1 93
3.2 Classes and interfaces
void OnStart()
{
   Shape s;
   ...
   Shape s2(s);   // ok: syntax 1 - copying
   Shape s3 = s;  // ok: syntax 2 - copying via initialization
                  //                   (if there is copy constructor)
                  //                 - or assignment
                  //                   (if there is no copy constructor,
                  //                    but there is default constructor)
   
   Shape s4;      // definition
   s4 = s;        // assignment, not copy constructor!
}
It is necessary to distinguish between initialization of an object during creation and assignment.
The second option (marked with the "syntax 2" comment) will work even if there is no copy
constructor, but there is a default constructor. In this case, the compiler will generate less efficient
code: first, using the default constructor, it will create an empty instance of the receiving variable (s3,
in this case), and then copy the fields of the sample (s, in this case) element by element. In fact, the
same case will turn out as with the variable s4, for which the definition and assignment are performed
by separate statements.
If there is no copy constructor, then attempting to use the first syntax will result in a "parameter
conversion not allowed" error, as the compiler will try to take some other constructor available with a
different set of parameters.
Keep in mind that if the class has fields with the modifier const, assigning such objects is prohibited for
obvious reasons: a constant field cannot be changed, it can only be set once when creating an object.
Therefore, the copy constructor becomes the only way to duplicate an object.
In particular, in the following sections, we will complete our Shape1 .mq5 example, and the following
field will appear in the Shape class (with a description string type). Then the assignment operator will
generate errors (in particular, for such lines as with the variable s4):
attempting to reference deleted function
   'void Shape::operator=(const Shape&)'
function 'void Shape::operator=(const Shape&)' was implicitly deleted
   because member 'type' has 'const' modifier
Thanks to the detailed wording of the compiler, you can understand the essence and reasons for what
is happening: first, the assignment operator ('=') is mentioned, and not the copy constructor; second,
it is reported that the assignment operator was implicitly removed due to the presence of the modifier
const. Here we encounter concepts that are yet unknown, which we will study later: operator
overloading in classes, object type conversion, and the ability to mark methods as deleted.
In the section Inheritance, after we learn how to describe derived classes, we need to make some
clarifications about copy constructors in class hierarchies.

---

## Page 194

Part 3. Object Oriented Programming
1 94
3.2 Classes and interfaces
3.2.9 Destructors
In the chapter on structures, we learned about destructors (see the section about Constructors and
destructors). Let's briefly recap: a destructor is a method that is called when an object is destroyed.
The destructor shares the same name as the class but is prefixed with a tilde character (~).
Destructors do not return values and do not have any parameters. A class can only have one
destructor.
Even if the class has no destructor or the destructor is empty, the compiler will implicitly perform
"garbage collection" of the following types of fields: strings, dynamic arrays, and automatic objects.
Usually, the destructor is placed in the public section of the class, however, in some specific cases, the
developer can move it to a group of private or protected members. A private or protected destructor
will not allow you to declare an automatic variable of this class in the code. However, we will see
dynamic object creation a little later, and for them, such a restriction might make sense.
In particular, some objects can be implemented in such a way that they must delete themselves when
they are no longer needed (the concept of determining demand may be different). In other words, while
objects are used by any part of the program, they exist, and as soon as the task is completed, they are
self-destructed (a private destructor leaves the possibility to delete the object from class methods).
For experienced C++ programmers, it is worth noting that destructors are always virtual in MQL5
(more on virtual methods will be covered in the section about Virtual methods (virtual and override)).
This factor does not affect the syntax of the description.
In the example of the drawing program, technically, a destructor may not be necessary for shapes.
However, for the purpose of tracing the sequence of calls to constructors and destructors, we will
include one. Let's start with a simplified outline that "prints" the full name of the method:
class Shape
{
   ...
   ~Shape()
   {
      Print(__FUNCSIG__);
   }
};
We will soon add to this and other methods so that we can distinguish one instance of an object from
another.
Consider the following example. A pair of objects Shape are described in two different contexts: global
(outside functions) and local (inside OnStart). The global object constructor will be called after the
script is loaded and before OnStart is called, and the destructor will be called before the script is
unloaded. The local object's constructor will be called in the line with the variable definition, and the
destructor will be called when the code block containing the variable definition exits, in this case the
function OnStart.

---

## Page 195

Part 3. Object Oriented Programming
1 95
3.2 Classes and interfaces
// the global constructor and destructor are related to script loading and unloading
Shape global;
// object reference does not create a copy and does not affect lifetime
void ProcessShape(Shape &shape)
{
   // ...
}
void OnStart()
{
   // ...
   Shape local; // <- local constructor call
   // ...
   ProcessShape(local);
   // ...
} // <- local destructor call
Passing an object by reference to other functions does not create copies of it and does not call the
constructor and destructor.
3.2.1 0 Self-reference: this
In the context of each class, in its methods code, there is a special reference to the current object:
this. Basically, it is an implicitly defined variable. All the methods of working with object variables are
applicable to it. In particular, it can be dereferenced to refer to an object field or to call a method. For
example, the following statements in a method of the Shape class are identical (we use the draw
method for demonstration purposes only):
class Shape
{
   ...
   void draw()
   {
      backgroundColor = clrBlue;
      this.backgroundColor = clrBlue;
   }
};
It might be necessary to use the long form if there are other variables/parameters with the same name
in the same context. This practice is generally not welcomed, but if necessary, the keyword this allows
you to refer to the overridden members of an object.
The compiler issues a warning if the name of any local variable or method parameter overlaps the name
of a class member variable.
In the following hypothetical example, we have implemented the draw method, which takes an optional
string parameter backgroundColor with the color name. Because the parameter name is the same as
the class member Shape, the compiler issues the first warning "the definition of 'backgroundColor'
hides the field".
The consequence of the overlap is that the subsequent erroneous assignment of the clrBlue value works
on the parameter and not on the class member, and because the value and parameter types do not

---

## Page 196

Part 3. Object Oriented Programming
1 96
3.2 Classes and interfaces
match, the compiler will issue a second warning, "implicit number to string conversion" (the number
here is a constant clrBlue). But the line this.backgroundColor = clrBlue writes the value to the field of
the object.
   void draw(string backgroundColor = NULL) //warning 1:
                // declaration of 'backgroundColor' hides member
   {
      ...
      backgroundColor = clrBlue; // warning 2:
        // implicit conversion from 'number' to 'string'
      this.backgroundColor = clrBlue; // ok
      
      {
         bool backgroundColor = false; // warning 3:
             // declaration of 'backgroundColor' hides local variable
         ...
         this.backgroundColor = clrRed; // ok
      }
      ...
   }
The subsequent definition of the local boolean variable backgroundColor (in the nested block of curly
brackets) overrides the previous definitions of that name once again (which is why we get the third
warning). However, by dereferencing this, the statement this.backgroundColor = clrRed also refers to an
object field.
Without this specified, the compiler always chooses the closest (by context) name definition.
There is also a need for this of another kind: to pass the current object as a parameter to another
function. In particular, an approach is taken in which objects of the same class are responsible for
creating/deleting objects of another class, and the subordinate object must know its "boss". Then the
dependent objects are created in the "boss" class using the constructor, and this of the "boss" object
is passed into it. This technique typically uses dynamic object allocation and pointers, and due to this a
relevant example will be shown in the section pointers.
Another common use of this is to return a pointer to the current object from a member function. This
allows you to arrange member function calls in a chain. As we have yet to study pointers in detail, it will
be enough to know that a pointer to an object of some class is described by adding the character '*' to
the class name, and you can work with an object through a pointer in the same way as you would do
directly.
For example, we can provide the user with several methods to set the properties of a shape individually:
change color, move horizontally or vertically. Each of them will return a pointer to the current object.

---

## Page 197

Part 3. Object Oriented Programming
1 97
3.2 Classes and interfaces
   Shape *setColor(const color c)
   {
      backgroundColor = c;
      return &this;
   }
   
   Shape *moveX(const int x)
   {
      coordinates.x += x;
      return &this;
   }
   Shape *moveY(const int y)
   {
      coordinates.y += y;
      return &this;
   }
Then it is possible to conveniently arrange calls to these methods in a chain.
   Shape s;
   s.setColor(clrWhite).moveX(80).moveY(-50);
When there are many properties in a class, this approach allows you to compactly and selectively
configure an object.
In the section Class definition, we tried to log an object variable but discovered that we could use its
name with only an ampersand (in a Print call) to get a pointer, or, in fact, a unique number (handle). In
an object context, the same handle is available via &this.
For debugging purposes, you can identify objects by their descriptor. We're going to explore class
inheritance, and when there is more than one of those, identification will come in handy. Because of it,
in all constructors and destructors, we add (and will add in the future in derived classes) the following
Print call:
   ~Shape()
   {
      Print(__FUNCSIG__, " ", &this);
   }
Now all creation and deletion steps will be marked in the log with the class name and object number.
We implement similar constructors and destructors in the Pair structure, however in structures,
unfortunately, pointers are not supported, i.e. writing &this is impossible. Therefore, we can identify
them only by their content (in this case, by their coordinates):

---

## Page 198

Part 3. Object Oriented Programming
1 98
3.2 Classes and interfaces
struct Pair
{
   int x, y;
   Pair(int a, int b): x(a), y(b)
   {
      Print(__FUNCSIG__, " ", x, " ", y);
   }
   ...
};
3.2.1 1  Inheritance
When defining a class, a developer can inherit it from another class, thereby embodying the concept of
inheritance. To do this, the class name is followed by a colon sign, an optional access rights modifier
(one of the keywords public, protected, private), and the name of the parent class. For example, here's
how we can define a class Rectangle that derives from Shape:
class Rectangle : public Shape
{
};
Access modifiers in the class header control the "visibility" of the members of the parent class included
in the child class:
·public – all inherited members retain their rights and limitations
·protected – changes the rights of inherited public members to protected
·private – makes all inherited members private (private)
The modifier public is used in the vast majority of definitions. The other two options make sense only in
exceptional cases because they violate the basic principle of inheritance: objects of a derived class
should be "is a" — full-fledged representatives of the parent family, and if we "truncate" their rights,
they lose part of their characteristics. Structures can also be inherited from each other in a similar
way. It is forbidden to inherit classes from structures or structures from classes.
Unlike C++, MQL5 does not support multiple inheritance. A class can have at most one parent.
A derived class object has a base class object built into it. Considering that the base class can, in turn,
be inherited from some other parent class, the created object can be compared to matryoshka dolls
nested one inside the other.
In the new class, we need a constructor that fills in the fields of the object in the same way as it was
done in the base class.

---

## Page 199

Part 3. Object Oriented Programming
1 99
3.2 Classes and interfaces
class Rectangle : public Shape
{
public:
   Rectangle(int px, int py, color back) :
      Shape(px, py, back)
   {
      Print(__FUNCSIG__, " ", &this);
   }
};
In this case, the initialization list has become a single call to the Shape constructor. You cannot
directly set base class variables in an initialization list, because the base constructor is responsible for
initializing them. However, if necessary, we could change the protected fields of the base class from the
body of the constructor Rectangle (the statements in the function body are executed after the base
constructor has completed its call in the initialization list).
The rectangle has two dimensions, so let's add them as protected fields dx and dy. To set their values,
you need to supplement the list of constructor parameters.
class Rectangle : public Shape
{
protected:
   int dx, dy; // dimensions (width, height)
   
public:
   Rectangle(int px, int py, int sx, int sy, color back) :
      Shape(px, py, back), dx(sx), dy(sy)
   {
   }
};
It is important to note that the Rectangle objects implicitly contain the toString function inherited from
Shape (however, draw is also present there, but it is still empty). Therefore, the following code is
correct:
void OnStart()
{
   Rectangle r(100, 200, 50, 75, clrBlue);
   Print(r.toString());
};
This demonstrates not only calling toString but also creating a rectangle object using our new
constructor.
There is no default constructor (with no parameters) in the class Rectangle. This means that the user
of the class cannot create rectangle objects in a simple way, without arguments:
   Rectangle r; // 'Rectangle' - wrong parameters count
The compiler will show an error "Invalid number of arguments".
Let's create another daughter class — Ellipse. For now, it will not differ from Rectangle in any way,
except for the name. Later we will introduce the differences between them.

---

## Page 200

Part 3. Object Oriented Programming
200
3.2 Classes and interfaces
class Ellipse : public Shape
{
protected:
   int dx, dy; // dimensions (large and small radii)
public:
   Ellipse(int px, int py, int rx, int ry, color back) :
      Shape(px, py, back), dx(rx), dy(ry)
   {
      Print(__FUNCSIG__, " ", &this);
   }
};
As the number of classes increases, it would be great to display the class name in the toString method.
In the Special sizeof and typename operators section, we described the typename operator. Let's try
using it.
Recall that typename expects one parameter, for which the type name is returned. For example, if we
create a pair of objects s and r of classes Shape and Rectangle, respectively, we can find out their type
in the following way:
void OnStart()
{
   Shape s;
   Rectangle r(100, 200, 75, 50, clrRed);
   Print(typename(s), " ", typename(r));      // Shape Rectangle
}
But we need to get this name inside the class somehow. For this purpose, let's add a string parameter
to the parametric constructor Shape and store it in a new string field type (pay attention to the
protected section and the modifier const: this field is hidden from the outside world and cannot be
edited after the object has been created):
class Shape
{
protected:
   ...
   const string type;
   
public:
   Shape(int px, int py, color back, string t) :
      coordinates(px, py),
      backgroundColor(back),
      type(t)
   {
      Print(__FUNCSIG__, " ", &this);
   }
   ...
};
In the constructors of derived classes, we fill in this parameter of the base constructor using
typename(this):

---

