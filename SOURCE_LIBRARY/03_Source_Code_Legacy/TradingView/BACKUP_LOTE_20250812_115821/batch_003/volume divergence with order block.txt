//@version=5

FV = format.volume,FP = format.percent
indicator('Volume Divergence with Order Blocks',format=FV, max_bars_back=5000, max_labels_count=500)

//------------------------------------------
//                Settings                 | 
//------------------------------------------
// Inputs Table
usecandle = input.bool(true,title = 'Volume on Candles')


C_Up      = input.color(#12cef8,title = 'Volume Buy', inline = ' ',group = "Style")
C_Down    = input.color(#fe3f00,title = 'Volume Buy', inline = ' ',group = "Style")
P_        = input.string(position.top_right,"Position",options = [position.top_right,position.top_center,position.middle_right,
                                                           position.middle_left,position.bottom_center,position.middle_center,
                                                           position.bottom_left,position.bottom_right,position.top_left],
                                                           group = "Style")
sL  = input.string(size.small , 'Size Label', options =[size.tiny, size.small, size.normal, size.large],group = "Style")
sT  = input.string(size.normal , 'Size Table', options =[size.tiny, size.small, size.normal, size.large],group = "Style")
Label     = input.bool(false,inline = 'l') , History   = input.bool(true,inline = 'l')
Plot_Candle = input.bool(false) 
// Inputs for EMA lengths and volume confirmation
EV = input.bool(true,title = 'EMA Volume Confirmed',group = "EMA Volume")
emaFastLength = input(12, title="Fast EMA Length",group = "EMA Volume")
emaSlowLength = input(26, title="Slow EMA Length",group = "EMA Volume")
volumeConfirmationLength = input(6, title="Volume Confirmation Length",group = "EMA Volume")

//------------------------------------------
//             UDT_identifier              | 
//------------------------------------------
// Define User Defined Type (UDT) for OHLCV data with default values
type OHLCV
    float O = open
    float H = high
    float L = low
    float C = close
    float V = volume

// Define UDT for Volume Data
type VolumeData
    float  buyVol
    float  sellVol
    float  pcBuy        // Stores percentage of buy volume
    float  pcSell       // Stores percentage of sell volume
    bool   isBuyGreater // Indicates if buy volume is greater True = Buy; otherwise, sell.
    float  higherVol    // Stores the higher volume value
    float  lowerVol     // Stores the lower volume value
    color  higherCol    // Stores the color for the higher volume bar
    color  lowerCol     // Stores the color for the lower volume bar

//------------------------------------------
//   Calculate volumes and percentages     | 
//------------------------------------------
calcVolumes(OHLCV ohlcv) =>
    var VolumeData data = VolumeData.new()
    data.buyVol       := ohlcv.V * (ohlcv.C - ohlcv.L) / (ohlcv.H - ohlcv.L) // Calculate buy volume using the formula: volume * (close - low) / (high - low)
    data.sellVol      := ohlcv.V - data.buyVol                               // Calculate sell volume by subtracting buy volume from total volume
    data.pcBuy        := data.buyVol / ohlcv.V * 100                         // Calculate the percentage of buy volume
    data.pcSell       := 100 - data.pcBuy                                    // Calculate the percentage of sell volume (100% - buy percentage)
    data.isBuyGreater := data.buyVol > data.sellVol                          // Determine if buy volume is greater than sell volume
    data.higherVol    := data.isBuyGreater ? data.buyVol  : data.sellVol     // Assign the higher volume value based on the comparison
    data.lowerVol     := data.isBuyGreater ? data.sellVol : data.buyVol      // Assign the lower volume value based on the comparison
    data.higherCol    := data.isBuyGreater ? C_Up     : C_Down               // Assign the color for the higher volume bar based on the comparison
    data.lowerCol     := data.isBuyGreater ? C_Down   : C_Up                 // Assign the color for the lower volume bar based on the comparison
    data

//------------------------------------------
//             Get volume data             | 
//------------------------------------------
// Instantiate OHLCV without explicit values (uses defaults)
ohlcv   = OHLCV.new()
volData = calcVolumes(ohlcv)

// Plot volumes and create labels 
//if Plot_Candle
plot(ohlcv.V, color=color.new(volData.higherCol, 90) , style=plot.style_columns, title='Total',display = display.all - display.status_line)
plot(ohlcv.V, color=volData.higherCol, style=plot.style_stepline_diamond, title='Total2', linewidth = 2,display = display.pane)
plot(volData.higherVol, color=volData.higherCol, style=plot.style_columns, title='Higher Volume', display = display.all - display.status_line)
plot(volData.lowerVol , color=volData.lowerCol, style=plot.style_columns, title='Lower Volume',display = display.all - display.status_line)

// Format percentages and volumes as strings before using in label text
S(D,F)=>str.tostring(D,F)
volStr              = S(math.sign(ta.change(ohlcv.C)) * ohlcv.V, FV)
buyVolStr           = S(volData.buyVol   , FV )
sellVolStr          = S(volData.sellVol  , FV )
buyPercentStr       = S(volData.pcBuy    , FP )
sellPercentStr      = S(volData.pcSell   , FP )
totalbuyPercentC_   = volData.buyVol  / (volData.buyVol + volData.sellVol) * 100

TC = text.align_center,CW = color.white
// Create table and set header
var table tb = table.new(P_, 6, 6, bgcolor = na, frame_width = 2, frame_color = chart.fg_color,border_width = 1, border_color = CW)
if barstate.islast
    // Title
    tb.cell(0, 0, text = "Volume Candles",text_color = #FFBF00, bgcolor = #0E2841, text_halign = TC, text_valign = TC,text_size = sT)
    tb.merge_cells( 0, 0, 5, 0)
    
    tb.cell( 0, 1, text = "Current Volume",text_color = CW, bgcolor = #0B3040, text_halign = TC, text_valign = TC,text_size = sT)
    tb.merge_cells( 0, 1, 1, 1)

    tb.cell( 0, 2, text = "Buy",text_color = #000000, bgcolor = #92D050, text_halign = TC, text_valign = TC,text_size = sT)
    tb.cell( 1, 2, text = "Sell",text_color = #000000, bgcolor = #FF0000, text_halign = TC, text_valign = TC,text_size = sT)

    tb.cell( 0, 3, text = buyVolStr,text_color = CW, bgcolor = #074F69, text_halign = TC, text_valign = TC,text_size = sT)
    tb.cell( 1, 3, text = sellVolStr,text_color = CW, bgcolor = #074F69, text_halign = TC, text_valign = TC,text_size = sT)
   
    tb.cell( 0, 5, text = "Net: "+volStr,text_color = CW, bgcolor = #074F69, text_halign = TC, text_valign = TC,text_size = sT)
    tb.merge_cells( 0, 5, 1, 5)

    tb.cell( 0, 4, text = buyPercentStr,text_color = CW, bgcolor = #074F69, text_halign = TC, text_valign = TC,text_size = sT)
    tb.cell( 1, 4, text = sellPercentStr,text_color = CW, bgcolor = #074F69, text_halign = TC, text_valign = TC,text_size = sT)

    //Fill the cell with color, setting 20 cells to 100% area. Then, loop according to the % volume of all trades.
    cellCount   = 20 // 4 columns x 5 rows = 20 cells
    filledCells = 0
    for r = 5 to 1
        for c = 2 to 5
            if filledCells < cellCount * (totalbuyPercentC_ / 100)
                tb.cell(c, r, text = "", bgcolor = C_Up)
            else
                tb.cell(c, r, text = "", bgcolor = C_Down)
            filledCells := filledCells + 1

if Label
    sp = '               '
    l = label.new(bar_index, ohlcv.V, 
                  text=str.format('Net: {0}\nBuy: {1} ({2})\nSell: {3} ({4})\n{5}/\\\n {5}l\n {5}l', 
                                  volStr, buyVolStr, buyPercentStr, sellVolStr, sellPercentStr, sp), 
                  style=label.style_none, textcolor=volData.higherCol, size=sL, textalign=text.align_left)
    if not History
        label.delete(l[1])

//------------------------------------------
// Draw volume levels on the candlesticks  | 
//------------------------------------------
// Define base and value for gradient candles
float base  = na,float value1 = na
// Calculate base and value based on buy/sell volume and open/close relationship
if volData.isBuyGreater
    base  := math.min(ohlcv.O, ohlcv.C) // Start from the lower of open/close for buy
    value1 := base + math.abs(ohlcv.O - ohlcv.C) * (volData.pcBuy  / 100) // Extend to the percentage of buy volume
else
    base  := math.max(ohlcv.O, ohlcv.C) // Start from the higher of open/close for sell
    value1 := base - math.abs(ohlcv.O - ohlcv.C) * (volData.pcSell / 100) // Extend to the percentage of sell volume

// Plot candles with gradient color
//barcolor(color.new(na, na),display = usecandle? display.all:display.none)
//UseC = usecandle? volData.higherCol:color.new(na, na)
//plotcandle(usecandle?base:na, usecandle?base:na, usecandle?value:na, usecandle?value:na,
           //title='Body', color=UseC, bordercolor=na, wickcolor=UseC, 
          // display = display.pane, force_overlay=true,editable=false)
//plotcandle(usecandle?ohlcv.O:na, usecandle?ohlcv.H:na, usecandle?ohlcv.L:na, usecandle?ohlcv.C:na,
           //title='Fill', color=color.new(UseC,80), bordercolor=UseC, wickcolor=UseC,
          // display = display.pane, force_overlay=true,editable=false)
//------------------------------------------------------------
// Plot the EMA and filter out the noise with volume control. | 
//------------------------------------------------------------
// Calculate EMAs
float emaFast = ta.ema(ohlcv.C, emaFastLength)
float emaSlow = ta.ema(ohlcv.C, emaSlowLength)
bool signal1 = emaFast > emaSlow
color c_signal1 = signal1? C_Up : C_Down
// Calculate volume moving average
float volumeMA = ta.sma(ohlcv.V, volumeConfirmationLength)
// Determine crossover and crossunder conditions
bool crossover = ta.crossover(emaFast, emaSlow)
bool crossunder = ta.crossunder(emaFast, emaSlow)

// Function to check for volume confirmation
isVolumeConfirmed(source, length, ma) =>
    math.sum(source > ma ? source : 0, length) >= math.sum(source < ma ? source : 0, length)

// Check for volume confirmation on crossover and crossunder
crossoverConfirmed = crossover and isVolumeConfirmed(ohlcv.V, volumeConfirmationLength, volumeMA)
crossunderConfirmed = crossunder and isVolumeConfirmed(ohlcv.V, volumeConfirmationLength, volumeMA)

// Plot EMAs with fill based on gradient
PF = EV?emaFast:na , PS = EV?emaSlow:na
p11 = plot(PF, color=c_signal1, editable = false , force_overlay=true,display =display.pane)
//plot(PF, color=color.new(c_signal1,80), linewidth=10, editable = false , force_overlay=true,display =display.pane)
//plot(PF, color=color.new(c_signal1,90), linewidth=20, editable = false , force_overlay=true,display =display.pane)
//plot(PF, color=color.new(c_signal1,95), linewidth=30, editable = false , force_overlay=true,display =display.pane)
//plot(PF, color=color.new(c_signal1,98), linewidth=45, editable = false , force_overlay=true,display =display.pane)
p22 = plot(PS, color=c_signal1, editable = false , force_overlay=true,display =display.pane)
//plot(PS, color=color.new(c_signal1,80), linewidth=10, editable = false , force_overlay=true,display =display.pane)
//plot(PS, color=color.new(c_signal1,90), linewidth=20, editable = false , force_overlay=true,display =display.pane)
//plot(PS, color=color.new(c_signal1,95), linewidth=30, editable = false , force_overlay=true,display =display.pane)
//plot(PS, color=color.new(c_signal1,98), linewidth=45, editable = false , force_overlay=true,display =display.pane)

// Fill area between EMAs based on crossover and volume confirmation
fill(p11, p22, top_value=crossover ? emaFast : emaSlow,
     bottom_value     =crossover ? emaSlow : emaFast,
     top_color        =color.new(c_signal1, 80),
     bottom_color     =color.new(c_signal1, 95)
     )
plotshape(crossoverConfirmed and EV, style=shape.triangleup, location=location.belowbar, color=C_Up, size=size.small, force_overlay=true,display =display.pane)
plotshape(crossunderConfirmed and EV, style=shape.triangledown, location=location.abovebar, color=C_Down, size=size.small, force_overlay=true,display =display.pane)

/////////////////////////////////////////////
//

// Developer By ALCON ALGO


//@version = 5


//indicator(shorttitle='Oscillator Vision', title='Alcon Oscillator Vision', overlay=false)
n1 = input(13, 'Channel length')
n2 = input(8, 'Average length')
reaction_wt = input.int(defval=1, title='Reaction in change of direction', minval=1)

nsc = input.float(53, 'Levels About Buys', minval=0.0)
nsv = input.float(-53, 'Levels About Sells', maxval=-0.0)

Buy_sales = input(true, title='Only Smart Buy Reversal')
Sell_sales = input(true, title='Only Smart Sell Reversal')

Histogram = input(true, title='Show Histogarm')
//Trendx = input(false, title='Show Trendx')
barras = input(true, title='Divergence on chart(Bars)')
divregbull = input(true, title='Regular Divergence Bullish')
divregbear = input(true, title='Regular Divergence Bearish')
divhidbull = input(true, title='Show Divergence Hidden Bullish')
divhidbear = input(true, title='Show Divergence Hidden Bearish')
Tags = input(true, title='Show Divergence Lable')
amme = input(false, title='Activar media movil Extra para WT')

White = #FDFEFE
Black = #000000
Bearish = #e91e62
Bullish = #18e0ff
Strong_Bullish = #2962ff
Bullish2 = #00bedc
Blue1 = #00D4FF
Blue2 = #009BBA
orange = #FF8B00
yellow = #FFFB00
LEZ = #0066FF
purp = #FF33CC

// Colouring


tf(_res, _exp, gaps_on) =>
    gaps_on == 0 ? request.security(syminfo.tickerid, _res, _exp) : gaps_on == true ? request.security(syminfo.tickerid, _res, _exp, barmerge.gaps_on, barmerge.lookahead_off) : request.security(syminfo.tickerid, _res, _exp, barmerge.gaps_off, barmerge.lookahead_off)

ha_htf = ''
show_ha = input.bool(true, "Show HA Plot/ Market Bias", group="HA Market Bias")
ha_len = input(7, 'Period', group="HA Market Bias")
ha_len2 = input(10, 'Smoothing', group="HA Market Bias")

// Calculations {
o = ta.ema(open, ha_len)
c = ta.ema(close, ha_len)
h = ta.ema(high, ha_len)
l = ta.ema(low, ha_len)

haclose = tf(ha_htf, (o + h + l + c) / 4, 0)
xhaopen = tf(ha_htf, (o + c) / 2, 0)
haopen = na(xhaopen[1]) ? (o + c) / 2 : (xhaopen[1] + haclose[1]) / 2
hahigh = math.max(h, math.max(haopen, haclose))
halow = math.min(l, math.min(haopen, haclose))


o2 = tf(ha_htf, ta.ema(haopen, ha_len2), 0)
c2 = tf(ha_htf, ta.ema(haclose, ha_len2), 0)
h2 = tf(ha_htf, ta.ema(hahigh, ha_len2), 0)
l2 = tf(ha_htf, ta.ema(halow, ha_len2), 0)

ha_avg = (h2 + l2) / 2
// }
    
osc_len = 8

osc_bias = 100 *(c2 - o2)
osc_smooth = ta.ema(osc_bias, osc_len)

sigcolor = 
  (osc_bias > 0) and (osc_bias >= osc_smooth) ? color.new(Bullish, 35) : 
  (osc_bias > 0) and (osc_bias < osc_smooth) ? color.new(Bullish2, 75) : 
  (osc_bias < 0) and (osc_bias <= osc_smooth) ? color.new(Bearish, 35) : 
  (osc_bias < 0) and (osc_bias > osc_smooth) ? color.new(Bearish, 75) :
  na
// }



nsc1 = nsc
nsc2 = nsc + 5
nsc3 = nsc + 10
nsc4 = nsc + 15
nsc5 = nsc + 20
nsc6 = nsc + 25
nsc7 = nsc + 30
nsc8 = nsc + 35
nsv1 = nsv - 5
nsv2 = nsv - 10
nsv3 = nsv - 15
nsv4 = nsv - 20
nsv5 = nsv - 25
nsv6 = nsv - 30
nsv7 = nsv - 35
nsv8 = nsv - 40


ap = hlc3
esa = ta.ema(ap, n1)
d = ta.ema(math.abs(ap - esa), n1)
ci = (ap - esa) / (0.015 * d)
tci = ta.ema(ci, n2)

wt1 = tci
wt2 = ta.sma(wt1, 4)

direction = 0
direction := ta.rising(wt1, reaction_wt) ? 1 : ta.falling(wt1, reaction_wt) ? -1 : nz(direction[1])
Change_of_direction = ta.change(direction, 1)
pcol = direction > 0 ? Strong_Bullish : direction < 0 ? Bearish : na

obLevel1 = input(60, 'Over Bought Level 1')
obLevel2 = input(53, 'Over Bought Level 2')
osLevel1 = input(-60, 'Over Sold Level 1')
osLevel2 = input(-53, 'Over Sold Level 2')

rsi = ta.rsi(close,14)
color greengrad = color.from_gradient(rsi, 10, 90, #00ddff, #007d91)
color redgrad = color.from_gradient(rsi, 10, 90, #8b002e, #e91e62)



ob1  = plot(obLevel1, color=#e91e6301)
os1 = plot(osLevel1, color=#00dbff01)
ob2 = plot(obLevel2, color=#e91e6301)
os2 = plot(osLevel2, color=#00dbff01)

p1 = plot(wt1, color=#00dbff01)
p2 = plot(wt2, color=#e91e6301)
plot(wt1 - wt2, color=wt2 - wt1 > 0 ? redgrad : greengrad, style=plot.style_columns)

// fill(p1,p2,color = wt2 - wt1 > 0 ? redgrad: greengrad) // old

fill(p1,p2,color = sigcolor) // new


fill(ob1,ob2,color = #e91e6350)
fill(os1,os2,color = #00dbff50)

midpoint = (nsc + nsv) / 2
ploff = (nsc - midpoint) / 8

BullSale = ta.crossunder(wt1, wt2) and wt1 >= nsc and Buy_sales == true
BearSale = ta.crossunder(wt1, wt2) and Buy_sales == false

Bullishh = ta.crossover(wt1, wt2) and wt1 <= nsv and Sell_sales == true
Bearishh = ta.crossover(wt1, wt2) and Sell_sales == false

//plot(BullSale ? wt2[1] + ploff : na, style=plot.style_circles, color=color.new(Bearish, 0), linewidth=3, title='BuysG')
//plot(BearSale ? wt2[1] + ploff : na, style=plot.style_circles, color=color.new(Bearish, 0), linewidth=3, title='SellsG')

//plot(Bullishh ? wt2[1] - ploff : na, style=plot.style_circles, color=color.new(Strong_Bullish, 0), linewidth=3, title='Buys On Sale')
//plot(Bearishh ? wt2[1] - ploff : na, style=plot.style_circles, color=color.new(Strong_Bullish, 0), linewidth=3, title='Sells on Sale')

//plot(Histogram ? wt1 - wt2 : na, style=plot.style_area, color=color.new(Blue2, 80), linewidth=1, title='Histograma')

//barcolor(barras == true and Bullishh == true or barras == true and Bearishh == true ? Bullish2 : na)
//barcolor(barras == true and BullSale == true or barras == true and BearSale == true ? Bearish : na)

/////// Divergence ///////

f_top_fractal(_src) =>
    _src[4] < _src[2] and _src[3] < _src[2] and _src[2] > _src[1] and _src[2] > _src[0]
f_bot_fractal(_src) =>
    _src[4] > _src[2] and _src[3] > _src[2] and _src[2] < _src[1] and _src[2] < _src[0]
f_fractalize(_src) =>
    f_top_fractal(_src) ? 1 : f_bot_fractal(_src) ? -1 : 0

fractal_top1 = f_fractalize(wt1) > 0 ? wt1[2] : na
fractal_bot1 = f_fractalize(wt1) < 0 ? wt1[2] : na

high_prev1 = ta.valuewhen(fractal_top1, wt1[2], 0)[2]
high_price1 = ta.valuewhen(fractal_top1, high[2], 0)[2]
low_prev1 = ta.valuewhen(fractal_bot1, wt1[2], 0)[2]
low_price1 = ta.valuewhen(fractal_bot1, low[2], 0)[2]

regular_bearish_div1 = fractal_top1 and high[2] > high_price1 and wt1[2] < high_prev1 and divregbear == true
hidden_bearish_div1 = fractal_top1 and high[2] < high_price1 and wt1[2] > high_prev1 and divhidbear == true
regular_bullish_div1 = fractal_bot1 and low[2] < low_price1 and wt1[2] > low_prev1 and divregbull == true
hidden_bullish_div1 = fractal_bot1 and low[2] > low_price1 and wt1[2] < low_prev1 and divhidbull == true

col1 = regular_bearish_div1 ? Bearish : hidden_bearish_div1 ? Bearish : na
col2 = regular_bullish_div1 ? Strong_Bullish : hidden_bullish_div1 ? Strong_Bullish : na

plot(title='Divergence Bearish', series=fractal_top1 ? wt1[2] : na, color=col1, linewidth=2, transp=0)
plot(title='Divergence Bullish', series=fractal_bot1 ? wt1[2] : na, color=col2, linewidth=2, transp=0)

plotshape(regular_bearish_div1 and divregbear and Tags ? wt1[1] + ploff * 1 : na, title='Divergence Regular Bearish', text='Bear', location=location.top, style=shape.labeldown, size=size.normal, color=color.new(Bearish, 0), textcolor=color.new(White, 0))
plotshape(hidden_bearish_div1 and divhidbear and Tags ? wt1[1] + ploff * 1 : na, title='Divergence Hidden Bearish', text='H Bear', location=location.top, style=shape.labeldown, size=size.normal, color=color.new(Bearish, 0), textcolor=color.new(White, 0))

plotshape(regular_bullish_div1 and divregbull and Tags ? wt1[1] - ploff * 1 : na, title='Divergence Regular Bullish', text='Bull', location=location.bottom, style=shape.labelup, size=size.normal, color=color.new(Strong_Bullish, 0), textcolor=color.new(White, 0))
plotshape(hidden_bullish_div1 and divhidbull and Tags ? wt1[1] - ploff * 1 : na, title='Divergence Hidden Bullish', text='H Bull', location=location.bottom, style=shape.labelup, size=size.normal, color=color.new(Strong_Bullish, 0), textcolor=color.new(White, 0))


/////// Unfazed Alerts  //////

//alertcondition(BullSale, title='Smart Bullish Reversal')
//alertcondition(BearSale, title='Smart Bearish Reversal')

//alertcondition(Bullishh, title='Bullish Reversal')
//alertcondition(Bearishh, title='Bearish Reversal')

//alertcondition(BullSale or Bullishh, title='Any Bullish reversal')
//alertcondition(BearSale or Bearishh, title='Any Bearish Reversal')

//alertcondition(Change_of_direction, title='Change In Direction WT')

/////// Extra Alerts //////

//alertcondition(BullSale, title='Overbought Reversal')
//alertcondition(BearSale, title='All Reversal')

//alertcondition(Bullishh, title='Oversold Buys')
//alertcondition(Bearishh, title='All Buys')

//alertcondition(BullSale or Bullishh, title='Buys/Reversal Overbought/Oversold')
//alertcondition(BearSale or Bearishh, title='All Reversal/Buys')

//alertcondition(Change_of_direction, title='WT Direction Change')




////////////////////////////////////////////////-MISTERMOTA MOMENTUM-/////////////////////////////////////



source = input(close)
responsiveness = math.max(0.00001, input.float(0.9, minval=0.0, maxval=1.0))
periodd = input(21)
sd = ta.stdev(source, 50) * responsiveness

var worm = source
diff = source - worm
delta = math.abs(diff) > sd ? math.sign(diff) * sd : diff
worm += delta
ma = ta.sma(source, periodd)
raw_momentum = (worm - ma) / worm
current_med = raw_momentum
min_med = ta.lowest(current_med, periodd)
max_med = ta.highest(current_med, periodd)
temp = (current_med - min_med) / (max_med - min_med)
value = 0.5 * 2
value *= (temp - .5 + .5 * nz(value[1]))
value := value > .9999 ? .9999 : value
value := value < -0.9999 ? -0.9999 : value
temp2 = (1 + value) / (1 - value)
momentum = .25 * math.log(temp2)
momentum += .5 * nz(momentum[1])

//momentum := raw_momentum
signal = nz(momentum[1])
trend = math.abs(momentum) <= math.abs(momentum[1])






////////////////////////////////////////////////-GROWING/FAILING-//////////////////////////////////////////



length = input.int(title="MOM Period", minval=1, defval=14, group="MOM Settings")
src = input(title="MOM Source", defval=hlc3, group="MOM Settings")


txtcol_grow_above = input(#1a7b24, "Above   Grow", group="MOM Settings", inline="Above")
txtcol_fall_above = input(#672ec5, "Fall", group="MOM Settings", inline="Above")
txtcol_grow_below = input(#F37121, "Below Grow", group="MOM Settings", inline="Below")
txtcol_fall_below = input(#be0606, "Fall", group="MOM Settings", inline="Below")


ma(source, length, type) =>
    switch type
        "SMA" => ta.sma(source, length)
        "EMA" => ta.ema(source, length)
        "SMMA (RMA)" => ta.rma(source, length)
        "WMA" => ta.wma(source, length)
        "VWMA" => ta.vwma(source, length)

typeMA = input.string(title = "Method", defval = "SMA", options=["SMA", "EMA", "SMMA (RMA)", "WMA", "VWMA"], group="MA Settings")
smoothingLength = input.int(title = "Length", defval = 5, minval = 1, maxval = 100, group="MA Settings")


smoothingLine = ma(delta, smoothingLength, typeMA)



deltaText=(delta > 0 ? (delta > delta[1]? " MOM  > 0 and ▲ Growing, MOM = " + str.tostring(delta[0], "#.##") :" MOM > 0 and ▼ Falling, MOM = " + str.tostring(delta[0], "#.##") ) : (delta > delta[1] ? "MOM < 0 and ▲ Growing, MOM = " + str.tostring(delta[0], "#.##"): " MOM < 0 and ▼ Falling, MOM = " + str.tostring(delta[0], "#.##")))


oneDay = 24 * 60 * 60 * 1000
barsAhead = 3
tmf = if timeframe.ismonthly
    barsAhead * oneDay * 30
else if timeframe.isweekly
    barsAhead * oneDay * 7
else if timeframe.isdaily
    barsAhead * oneDay
else if timeframe.isminutes
    barsAhead * oneDay * timeframe.multiplier / 1440
else if timeframe.isseconds
    barsAhead * oneDay * timeframe.multiplier / 86400
else
    0
  

angle(_src) =>
    rad2degree = 180 / 3.14159265359  //pi 
    ang = rad2degree * math.atan((_src[0] - _src[1]) / ta.atr(14))
    ang

emae = angle(smoothingLine)
emaanglestat = emae > emae[1] ? "▲  Growing": "▼  Falling"
deltaTextxxx = "MOM MA/ATR angle value is " + str.tostring(emae, "#.##") + "° and is " + emaanglestat
deltacolorxxx = emae >0 and emae >=emae[1] ? txtcol_grow_above : txtcol_fall_below
// Label
label lpt1 = label.new(time, -30, text=deltaTextxxx[0], color=deltacolorxxx, xloc=xloc.bar_time, style=label.style_label_left, textcolor=color.white, textalign=text.align_left, size=size.normal)
label.set_x(lpt1, label.get_x(lpt1) + tmf)
label.delete(lpt1[1])

txtdeltaColors  = (delta > 50 ? (delta[1] < delta ? txtcol_grow_above : txtcol_fall_above) : (delta[1] < delta ? txtcol_grow_below : txtcol_fall_below))

label ldelta1 = label.new(time, 30, text=deltaText[0], color=txtdeltaColors, xloc=xloc.bar_time, style=label.style_label_left, textcolor=color.white, textalign=text.align_left, size=size.normal)
label.set_x(ldelta1, label.get_x(ldelta1) + tmf)
label.delete(ldelta1[1])

////////////////////////////Order Block Indicator//////////////////////////////////

//indicator('Order Block Finder', overlay=true)

colors = input.string(title='Color Scheme', defval='DARK', options=['DARK', 'BRIGHT'])
periods = input(5, 'Relevant Periods to identify OB')  // Required number of subsequent candles in the same direction to identify Order Block
threshold = input.float(0.0, 'Min. Percent move to identify OB', step=0.1)  // Required minimum % move (from potential OB close to last subsequent candle to identify Order Block)
usewicks = input(false, 'Use whole range [High/Low] for OB marking?')  // Display High/Low range for each OB instead of Open/Low for Bullish / Open/High for Bearish
showbull = input(true, 'Show latest Bullish Channel?')  // Show Channel for latest Bullish OB?
showbear = input(true, 'Show latest Bearish Channel?')  // Show Channel for latest Bearish OB?
showdocu = input(false, 'Show Label for documentation tooltip?')  // Show Label which shows documentation as tooltip?
info_pan = input(false, 'Show Latest OB Panel?')  // Show Info Panel with latest OB Stats

ob_period = periods + 1  // Identify location of relevant Order Block candle
absmove = math.abs(close[ob_period] - close[1]) / close[ob_period] * 100  // Calculate absolute percent move from potential OB to last candle of subsequent candles
relmove = absmove >= threshold  // Identify "Relevant move" by comparing the absolute move to the threshold

// Color Scheme
bullcolor = colors == 'DARK' ? color.white : color.green
bearcolor = colors == 'DARK' ? color.blue : color.red

// Bullish Order Block Identification
bullishOB = close[ob_period] < open[ob_period]  // Determine potential Bullish OB candle (red candle)

int upcandles = 0
for i = 1 to periods by 1
    upcandles += (close[i] > open[i] ? 1 : 0)  // Determine color of subsequent candles (must all be green to identify a valid Bearish OB)
    upcandles

OB_bull = bullishOB and upcandles == periods and relmove  // Identification logic (red OB candle & subsequent green candles)
OB_bull_high = OB_bull ? usewicks ? high[ob_period] : open[ob_period] : na  // Determine OB upper limit (Open or High depending on input)
OB_bull_low = OB_bull ? low[ob_period] : na  // Determine OB lower limit (Low)
OB_bull_avg = (OB_bull_high + OB_bull_low) / 2  // Determine OB middle line


// Bearish Order Block Identification
bearishOB = close[ob_period] > open[ob_period]  // Determine potential Bearish OB candle (green candle)

int downcandles = 0
for i = 1 to periods by 1
    downcandles += (close[i] < open[i] ? 1 : 0)  // Determine color of subsequent candles (must all be red to identify a valid Bearish OB)
    downcandles

OB_bear = bearishOB and downcandles == periods and relmove  // Identification logic (green OB candle & subsequent green candles)
OB_bear_high = OB_bear ? high[ob_period] : na  // Determine OB upper limit (High)
OB_bear_low = OB_bear ? usewicks ? low[ob_period] : open[ob_period] : na  // Determine OB lower limit (Open or Low depending on input)
OB_bear_avg = (OB_bear_low + OB_bear_high) / 2  // Determine OB middle line


// Plotting

plotshape(OB_bull, title='Bullish OB', style=shape.triangleup, color=bullcolor, textcolor=bullcolor, size=size.tiny, location=location.belowbar, offset=-ob_period, text='Bullish OB',force_overlay=true,display =display.pane)  // Bullish OB Indicator
bull1 = plot(OB_bull_high, title='Bullish OB High', style=plot.style_linebr, color=bullcolor, offset=-ob_period, linewidth=3, force_overlay=true,display =display.pane)  // Bullish OB Upper Limit
bull2 = plot(OB_bull_low, title='Bullish OB Low', style=plot.style_linebr, color=bullcolor, offset=-ob_period, linewidth=3, force_overlay=true,display =display.pane)  // Bullish OB Lower Limit
fill(bull1, bull2, color=bullcolor, title='Bullish OB fill', transp=0)  // Fill Bullish OB
plotshape(OB_bull_avg, title='Bullish OB Average', style=shape.cross, color=bullcolor, size=size.normal, location=location.absolute, offset=-ob_period, force_overlay=true,display =display.pane)  // Bullish OB Average


plotshape(OB_bear, title='Bearish OB', style=shape.triangledown, color=bearcolor, textcolor=bearcolor, size=size.tiny, location=location.abovebar, offset=-ob_period, text='Bearish OB', force_overlay=true,display =display.pane)  // Bearish OB Indicator
bear1 = plot(OB_bear_low, title='Bearish OB Low', style=plot.style_linebr, color=bearcolor, offset=-ob_period, linewidth=3, force_overlay=true,display =display.pane)  // Bearish OB Lower Limit
bear2 = plot(OB_bear_high, title='Bearish OB High', style=plot.style_linebr, color=bearcolor, offset=-ob_period, linewidth=3, force_overlay=true,display =display.pane)  // Bearish OB Upper Limit
fill(bear1, bear2, color=bearcolor, title='Bearish OB fill', transp=0)  // Fill Bearish OB
plotshape(OB_bear_avg, title='Bearish OB Average', style=shape.cross, color=bearcolor, size=size.normal, location=location.absolute, offset=-ob_period, force_overlay=true,display =display.pane)  // Bullish OB Average

var line linebull1 = na  // Bullish OB average 
var line linebull2 = na  // Bullish OB open
var line linebull3 = na  // Bullish OB low
var line linebear1 = na  // Bearish OB average
var line linebear2 = na  // Bearish OB high
var line linebear3 = na  // Bearish OB open


if OB_bull and showbull
    line.delete(linebull1)
    linebull1 := line.new(x1=bar_index, y1=OB_bull_avg, x2=bar_index - 1, y2=OB_bull_avg, extend=extend.left, color=bullcolor, style=line.style_solid, width=1)

    line.delete(linebull2)
    linebull2 := line.new(x1=bar_index, y1=OB_bull_high, x2=bar_index - 1, y2=OB_bull_high, extend=extend.left, color=bullcolor, style=line.style_dashed, width=1)

    line.delete(linebull3)
    linebull3 := line.new(x1=bar_index, y1=OB_bull_low, x2=bar_index - 1, y2=OB_bull_low, extend=extend.left, color=bullcolor, style=line.style_dashed, width=1)
    linebull3

if OB_bear and showbear
    line.delete(linebear1)
    linebear1 := line.new(x1=bar_index, y1=OB_bear_avg, x2=bar_index - 1, y2=OB_bear_avg, extend=extend.left, color=bearcolor, style=line.style_solid, width=1)

    line.delete(linebear2)
    linebear2 := line.new(x1=bar_index, y1=OB_bear_high, x2=bar_index - 1, y2=OB_bear_high, extend=extend.left, color=bearcolor, style=line.style_dashed, width=1)

    line.delete(linebear3)
    linebear3 := line.new(x1=bar_index, y1=OB_bear_low, x2=bar_index - 1, y2=OB_bear_low, extend=extend.left, color=bearcolor, style=line.style_dashed, width=1)
    linebear3


// Alerts for Order Blocks Detection

//alertcondition(OB_bull, title='New Bullish OB detected', message='New Bullish OB detected - This is NOT a BUY signal!')
//alertcondition(OB_bear, title='New Bearish OB detected', message='New Bearish OB detected - This is NOT a SELL signal!')

// Print latest Order Blocks in Data Window

var latest_bull_high = 0.0  // Variable to keep latest Bull OB high
var latest_bull_avg = 0.0  // Variable to keep latest Bull OB average
var latest_bull_low = 0.0  // Variable to keep latest Bull OB low
var latest_bear_high = 0.0  // Variable to keep latest Bear OB high
var latest_bear_avg = 0.0  // Variable to keep latest Bear OB average
var latest_bear_low = 0.0  // Variable to keep latest Bear OB low

// Assign latest values to variables
if OB_bull_high > 0
    latest_bull_high := OB_bull_high
    latest_bull_high

if OB_bull_avg > 0
    latest_bull_avg := OB_bull_avg
    latest_bull_avg

if OB_bull_low > 0
    latest_bull_low := OB_bull_low
    latest_bull_low

if OB_bear_high > 0
    latest_bear_high := OB_bear_high
    latest_bear_high

if OB_bear_avg > 0
    latest_bear_avg := OB_bear_avg
    latest_bear_avg

if OB_bear_low > 0
    latest_bear_low := OB_bear_low
    latest_bear_low

// Plot invisible characters to be able to show the values in the Data Window
//plotchar(latest_bull_high, char=' ', location=location.abovebar, color=color.new(#777777, 100), size=size.tiny, title='Latest Bull High')
//plotchar(latest_bull_avg, char=' ', location=location.abovebar, color=color.new(#777777, 100), size=size.tiny, title='Latest Bull Avg')
//plotchar(latest_bull_low, char=' ', location=location.abovebar, color=color.new(#777777, 100), size=size.tiny, title='Latest Bull Low')
//plotchar(latest_bear_high, char=' ', location=location.abovebar, color=color.new(#777777, 100), size=size.tiny, title='Latest Bear High')
//plotchar(latest_bear_avg, char=' ', location=location.abovebar, color=color.new(#777777, 100), size=size.tiny, title='Latest Bear Avg')
//plotchar(latest_bear_low, char=' ', location=location.abovebar, color=color.new(#777777, 100), size=size.tiny, title='Latest Bear Low')


//InfoPanel for latest Order Blocks

//draw_InfoPanel(_text, _x, _y, font_size) =>
    //var label la_panel = na
    //label.delete(la_panel)
    //la_panel := label.new(x=_x, y=_y, text=_text, xloc=xloc.bar_time, yloc=yloc.price, color=color.new(#383838, 5), style=label.style_label_left, textcolor=color.white, size=font_size)
    //la_panel

//info_panel_x = time_close + math.round(ta.change(time) * 100)
////info_panel_y = close

//title = 'LATEST ORDER BLOCKS'
//row0 = '-----------------------------------------------------'
//row1 = ' Bullish - High: ' + str.tostring(latest_bull_high, '#.##')
//row2 = ' Bullish - Avg: ' + str.tostring(latest_bull_avg, '#.##')
//row3 = ' Bullish - Low: ' + str.tostring(latest_bull_low, '#.##')
//row4 = '-----------------------------------------------------'
//row5 = ' Bearish - High: ' + str.tostring(latest_bear_high, '#.##')
//row6 = ' Bearish - Avg: ' + str.tostring(latest_bear_avg, '#.##')
//row7 = ' Bearish - Low: ' + str.tostring(latest_bear_low, '#.##')

//panel_text = '\n' + title + '\n' + row0 + '\n' + row1 + '\n' + row2 + '\n' + row3 + '\n' + row4 + '\n\n' + row5 + '\n' + row6 + '\n' + row7 + '\n'

//if info_pan
    //draw_InfoPanel(panel_text, info_panel_x, info_panel_y, size.normal)


// === Label for Documentation/Tooltip ===
///chper = time - time[1]
//chper := ta.change(chper) > 0 ? chper[1] : chper

// === Tooltip text ===

//var vartooltip = 'Indicator to help identifying instituational Order Blocks. Often these blocks signal the beginning of a strong move, but there is a high probability, that these prices will be revisited at a later point in time again and therefore are interesting levels to place limit orders. \nBullish Order block is the last down candle before a sequence of up candles. \nBearish Order Block is the last up candle before a sequence of down candles. \nIn the settings the number of required sequential candles can be adjusted. \nFurthermore a %-threshold can be entered which the sequential move needs to achieve in order to validate a relevant Order Block. \nChannels for the last Bullish/Bearish Block can be shown/hidden.'

// === Print Label ===
//var label l_docu = na
//label.delete(l_docu)
//
//if showdocu
   // l_docu := label.new(x=time + chper * 35, y=close, text='DOCU OB', color=color.gray, textcolor=color.white, style=label.style_label_center, xloc=xloc.bar_time, yloc=yloc.price, size=size.tiny, textalign=text.align_left, tooltip=vartooltip)
    //l_docu
