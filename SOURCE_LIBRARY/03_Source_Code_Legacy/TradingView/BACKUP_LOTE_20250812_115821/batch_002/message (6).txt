#include <bits/stdc++.h>

using namespace std;

#define int float

template<typename T>
class History{
public:
    T value;
    vector<T> history;

    History(T& init){
        value = init;
    }
    History(){
        value = NULL;
    }

    void change(T& n){
        if (value){
            history.push_back(value);
        }
        value = n;
    }

    int getMaxWithinK(int k){
        int n = history.size();
        if (n == 0){
            return 0;
        }
        int ans = history.back();
        for (int i = n-1; i >= 0 && i >= n-k; --i){
            ans = max(ans, history[i]);
        }
        return ans;
    }
    
    int getMinWithinK(int k){
        int n = history.size();
        if (n == 0){
            return 0;
        }
        int ans = history.back();
        for (int i = n-1; i >= 0 && i >= n-k; --i){
            ans = min(ans, history[i]);
        }
        return ans;
    }

};

class Cell {
public:

    // you gotta add in your own update performance function
    //the entirety of grid search is dependant on it
    //so i will leave it blank depending on how you want to calculate performance.
    //feel free to add more variables to fit whatever you are hypeorptimizing for.

    int par1, par2;
    int performance, normalizedPerformance;
    int direction; // trend direction for classification -> not needed

    void updatePerformance(){
        //this is the bit of code you have to write.
        //update other values as well here.
    }

    Cell(int par1_, int par2_){
        par1 = par1_;
        par2 = par2_;
        direction = 1;
    }
};

class GridSearch {
public:
    int rows, cols;
    vector<vector<Cell>> grid;
    History<float> directionHistory;
    
    GridSearch(int par1min, int par1max, int par1step, int par2min, int par2max, int par2step){
        for (int par1 = par1min; par1 <= par1max; par1+=par1step) {
            grid.push_back({});
            for (int par2 = par2min; par2 <= par2max; par2+=par2step){
                grid.back().push_back(Cell(par1, par2));
            }
        }
    }

    void updatePerformance(){
        for (auto& row : grid){
            for (auto& cell : row){
                cell.updatePerformance();
            }
        }
        normalizePerformance();
    }

    //if you use updateperformance every itaration you can remove normalize performance from the functions below.

    void normalizePerformance(){
        int maxPerf = INT_MIN, minPerf = INT_MAX;
        for (auto& row : grid){
            for (auto & cell : row){
                maxPerf = max(maxPerf, cell.performance);
                minPerf = min(minPerf, cell.performance);
            }   
        }
        
        for (auto & row : grid){
            for (auto & cell : row){
                cell.normalizedPerformance = (cell.performance-minPerf)/(maxPerf-minPerf);
            }
        }
    }

    int getBestPar1(){
        int sum1 = 0, sum2 = 0;

        normalizePerformance();
       
        for (auto & row : grid){
            for (auto & cell : row){
                sum1 += cell.normalizedPerformance*cell.par1;
                sum2 += cell.normalizedPerformance;                
            }
        }
        return sum1/sum2;

    }
    int getBestPar2(){
        int sum1 = 0, sum2 = 0;

        normalizePerformance();

        for (auto & row : grid){
            for (auto & cell : row){
                sum1 += cell.normalizedPerformance*cell.par2;
                sum2 += cell.normalizedPerformance;                
            }
        }
        return sum1/sum2;

    }

    //this is no longer generic -> this is for signal classification
    int getClassification(){
        normalizePerformance();
        int directionScore = 0;
        
        for (auto & row : grid){
            for (auto & cell : row){
                directionScore += cell.performance*cell.direction;
            }
        }
        directionHistory.change(directionScore);
        int maxScore = directionHistory.getMaxWithinK(directionHistory.history.size());
        int minScore = directionHistory.getMinWithinK(directionHistory.history.size());
        return (directionScore - minScore)/(maxScore-minScore)*4;

    }
};

int main(){
    
}