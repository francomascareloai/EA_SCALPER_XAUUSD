// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © Llopezf

//@version=5
indicator("Targets with Market Structure Break & Order Block by LEO", shorttitle = "Targets with MSB-OB by LEO", overlay = true, max_lines_count = 500, max_labels_count = 500, max_bars_back=4900, max_boxes_count=500)

//-----------------------------------------------------------------------------}
//Target 1
//-----------------------------------------------------------------------------{
showLabels = input(true, 'Show Target Labels', inline = 'style')
candleColoring = input(true, 'Candle Coloring', inline = 'style')

//Condition Rule
enableTarget1 = input(true, 'Enable Target'
  , inline    = 'enable'
  , group     = 'Target 1')

isLong1       = input(true, 'Long Position Target'
  , inline    = 'enable'
  , group     = 'Target 1')

_ = input.string('Source A', 'New Target Condition', options = ['Source A']
  , inline    = 'targetRule1'
  , group     = 'Target 1')

target1Condition = input.string('CrossOver', ''
  , options   = ['CrossOver', 'CrossUnder', 'Cross', 'Equal']
  , inline    = 'targetRule1'
  , group     = 'Target 1')

_ = input.string('Source B', '', options = ['Source B']
  , inline    = 'targetRule1'
  , group     = 'Target 1')  

//Source A
targetSource1A = input.string('External', 'Source A'
  , options   = ['External', 'ACCDIST', 'ATR', 'BB Middle', 'BB Upper', 'BB Lower', 'CCI', 'CMO', 'COG', 'DC High', 'DC Mid', 'DC Low'
              , 'DEMA', 'EMA', 'HMA', 'III', 'KC Middle', 'KC Upper', 'KC Lower', 'LINREG', 'MACD', 'MACD-signal', 'MACD-histogram', 'MEDIAN'
              , 'MFI', 'MODE', 'MOM', 'NVI', 'OBV', 'PVI', 'PVT', 'RMA', 'ROC', 'RSI', 'SMA', 'STOCH', 'Supertrend'
              , 'TEMA', 'VWAP', 'VWMA', 'WAD', 'WMA', 'WVAD', '%R']
  , inline    = 'A'
  , group     = 'Target 1')

targetExternal1A = input(close, 'External'
  , inline    = 'A'
  , group     = 'Target 1')

targetTiSettings1A = input.string('', 'Settings'
  , inline    = 'A'
  , group     = 'Target 1')

//Source B
targetSource1B = input.string('Supertrend', 'Source B'
  , options   = ['External', 'Value', 'ACCDIST', 'ATR', 'BB Middle', 'BB Upper', 'BB Lower', 'CCI', 'CMO', 'COG', 'DC High', 'DC Mid', 'DC Low'
              , 'DEMA', 'EMA', 'HMA', 'III', 'KC Middle', 'KC Upper', 'KC Lower', 'LINREG', 'MACD', 'MACD-signal', 'MACD-histogram', 'MEDIAN'
              , 'MFI', 'MODE', 'MOM', 'NVI', 'OBV', 'PVI', 'PVT', 'RMA', 'ROC', 'RSI', 'SMA', 'STOCH', 'Supertrend'
              , 'TEMA', 'VWAP', 'VWMA', 'WAD', 'WMA', 'WVAD', '%R']
  , inline    = 'B'
  , group     = 'Target 1')

targetExternal1B = input(open, 'External'
  , inline    = 'B'
  , group     = 'Target 1')

targetTiSettings1B = input.string('10,3', 'Settings'
  , inline    = 'B'
  , group     = 'Target 1')

targetValue1B = input(0, 'Source B Value'
  , inline    = 'B_'
  , group     = 'Target 1')

target1Css    = input(#089981c1, 'Target Color '
  , inline    = 'style'
  , group     = 'Target 1')

target1Style  = input.string('· · ·', '    Levels Style'
  , options   = ['──','- - -','· · ·']
  , inline    = 'style'
  , group     = 'Target 1')

showSource1   = input.bool(false, 'Show Source Values'
  , group     = 'Target 1')

//-----------------------------------------------------------------------------}
//Target 1 Logic
//-----------------------------------------------------------------------------{
waitTarget1   = input(false, 'Wait Until Reached'
  , group     = 'Target 1 Logic')

newTarget1    = input(false, 'New Target When Reached'
  , group     = 'Target 1 Logic')

useWicks1     = input(true, 'Evaluate Wicks'
  , group     = 'Target 1 Logic')

distTarget1   = input.float(3, 'Target Distance From Price'
  , inline    = 'dist1'
  , group     = 'Target 1 Logic')

distOptions1  = input.string('ATR', ''
  , options   = ['Currencies', '%', 'ATR', 'Ticks', 'External Value']
  , inline    = 'dist1'
  , group     = 'Target 1 Logic')

externalDist1 = input(close, 'External Distance Value'
  , group     = 'Target 1 Logic')

//-----------------------------------------------------------------------------}
//Target 2
//-----------------------------------------------------------------------------{
//Condition Rule
enableTarget2 = input(true, 'Enable Target'
  , inline    = 'enable'
  , group     = 'Target 2')

isLong2 = input(false, 'Long Position Target'
  , inline    = 'enable'
  , group     = 'Target 2')

_ = input.string('Source A', 'New Target Condition', options = ['Source A']
  , inline    = 'targetRule2'
  , group     = 'Target 2')

target2Condition = input.string('CrossUnder', ''
  , options   = ['CrossOver', 'CrossUnder', 'Cross', 'Equal']
  , inline    = 'targetRule2'
  , group     = 'Target 2')

_ = input.string('Source B', '', options = ['Source B']
  , inline    = 'targetRule2'
  , group     = 'Target 2')

//Source A
targetSource2A = input.string('External', 'Source A'
  , options   = ['External', 'ACCDIST', 'ATR', 'BB Middle', 'BB Upper', 'BB Lower', 'CCI', 'CMO', 'COG', 'DC High', 'DC Mid', 'DC Low'
              , 'DEMA', 'EMA', 'HMA', 'III', 'KC Middle', 'KC Upper', 'KC Lower', 'LINREG', 'MACD', 'MACD-signal', 'MACD-histogram', 'MEDIAN'
              , 'MFI', 'MODE', 'MOM', 'NVI', 'OBV', 'PVI', 'PVT', 'RMA', 'ROC', 'RSI', 'SMA', 'STOCH', 'Supertrend'
              , 'TEMA', 'VWAP', 'VWMA', 'WAD', 'WMA', 'WVAD', '%R']
  , inline    = 'A'
  , group     = 'Target 2')

targetExternal2A = input(close, 'External'
  , inline    = 'A'
  , group     = 'Target 2')

targetTiSettings2A = input.string('', 'Settings'
  , inline    = 'A'
  , group     = 'Target 2')

//Source B
targetSource2B = input.string('Supertrend', 'Source B'
  , options   = ['External', 'Value', 'ACCDIST', 'ATR', 'BB Middle', 'BB Upper', 'BB Lower', 'CCI', 'CMO', 'COG', 'DC High', 'DC Mid', 'DC Low'
              , 'DEMA', 'EMA', 'HMA', 'III', 'KC Middle', 'KC Upper', 'KC Lower', 'LINREG', 'MACD', 'MACD-signal', 'MACD-histogram', 'MEDIAN'
              , 'MFI', 'MODE', 'MOM', 'NVI', 'OBV', 'PVI', 'PVT', 'RMA', 'ROC', 'RSI', 'SMA', 'STOCH', 'Supertrend'
              , 'TEMA', 'VWAP', 'VWMA', 'WAD', 'WMA', 'WVAD', '%R']
  , inline    = 'B'
  , group     = 'Target 2')

targetExternal2B = input(open, 'External'
  , inline    = 'B'
  , group     = 'Target 2')

targetTiSettings2B = input.string('10,3', 'Settings'
  , inline    = 'B'
  , group     = 'Target 2')

targetValue2B = input(0, 'Source B Value'  
  , inline    = 'B_'
  , group     = 'Target 2')

target2Css    = input(#f23646c0, 'Target Color '
  , inline    = 'style'
  , group     = 'Target 2')

target2Style  = input.string('· · ·', '    Levels Style'
  , options   = ['──','- - -','· · ·']
  , inline    = 'style'
  , group     = 'Target 2')

showSource2   = input.bool(false, 'Show Source Values'
  , group     = 'Target 2')

//-----------------------------------------------------------------------------}
//Target 2 Logic
//-----------------------------------------------------------------------------{
waitTarget2   = input(false, 'Wait Until Reached'
  , group     = 'Target 2 Logic')

newTarget2    = input(false, 'New Target When Reached'
  , group     = 'Target 2 Logic')

useWicks2     = input(true, 'Evaluate Wicks'
  , group     = 'Target 2 Logic')

distTarget2   = input.float(3, 'Target Distance From Price'
  , inline    = 'dist1'
  , group     = 'Target 2 Logic')

distOptions2  = input.string('ATR', ''
  , options   = ['Currencies', '%', 'ATR', 'Ticks', 'External Value']
  , inline    = 'dist1'
  , group     = 'Target 2 Logic')

externalDist2 = input(close, 'External Distance Value   '
  , group     = 'Target 2 Logic')

//-----------------------------------------------------------------------------}
//Target 2 Logic
//-----------------------------------------------------------------------------{
showDash      = input.bool     (    false      , 'Show Dashboard'                                                     , group= 'Dashboard')
dashLoc       = input.string   (  'Top Right' , 'Location'  , options = ['Top Right', 'Bottom Right', 'Bottom Left'] , group= 'Dashboard')
textSize      = input.string   (   'Normal'   , 'Size'      , options =          ['Tiny', 'Small', 'Normal']         , group= 'Dashboard')

//-----------------------------------------------------------------------------}
//UDT
//-----------------------------------------------------------------------------{
type lshape
    line v
    line h

type target
    float  value
    int    loc
    bool   reached
    bool   islong
    bool   active
    lshape lines
    label  lbl

//-----------------------------------------------------------------------------}
//Functions
//-----------------------------------------------------------------------------{
n = bar_index

INV = color.new(color.blue, 100)

aNoVisuals = array.from('ACCDIST', 'ATR', 'CCI', 'CMO', 'COG', 'III', 'MACD', 'MACD-signal', 'MACD-histogram', 'MFI', 'MOM', 'NVI', 'OBV', 'PVI', 'PVT', 'ROC', 'RSI', 'STOCH', 'WAD', 'WVAD', '%R')

a_1Val       = array.from( 'ATR'  ,  'CCI'  ,  'CMO'  ,  'COG'  , 'DC High', 'DC Mid', 'DC Low', 'DEMA'  ,  'EMA'  ,  'HMA'  , 'MEDIAN',  'MFI'  ,  'MODE' ,  'MOM'  ,  'RMA'  ,  'ROC'  ,  'RSI'  ,  'SMA'  , 'STOCH' , 'TEMA'  , 'VWMA'  ,  'WMA'  ,   '%R'  )
a_1ValValues = array.from('Length', 'Length', 'Length', 'Length', 'Length' , 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length')

a_2Val       = array.from( 'BB Middle'     ,   'BB Upper'     ,   'BB Lower'     ,  'KC Middle'     ,   'KC Upper'     ,   'KC Lower'     ,    'LINREG'      ,     'Supertrend'    )
a_2ValValues = array.from('Length, Mult'   , 'Length, Mult'   , 'Length, Mult'   , 'Length, Mult'   , 'Length, Mult'   , 'Length, Mult'   , 'Length, Offset' , 'ATR Length, Factor')

a_3Val       = array.from(              'MACD'             ,           'MACD-signal'          ,         'MACD-histogram'         )
a_3ValValues = array.from('Short, Long & Signal EMA Length', 'Short, Long & Signal EMA Length', 'Short, Long & Signal EMA Length')

method set_target(target id, css, lstyle)=>
    style = switch lstyle
        '- - -' => line.style_dashed
        '· · ·' => line.style_dotted
        =>         line.style_solid
    
    id.lines := lshape.new(line.new(n, close, n, id.value, color = css, style = style),
      line.new(n, id.value, n, id.value, color = css, style = style))

method delete(target id)=>
    id.lines.v.delete()
    id.lines.h.delete()

method getSetting(array<string> id , idx) => int(str.tonumber(id.get(idx)))

method getStFloat(array<string> id , idx) =>     str.tonumber(id.get(idx))

method isString  (array<string> settings) =>
    isS = false 
    for s in settings 
        if na(str.tonumber(s) / 1)
            isS := true 
            break 
    txt = isS ? 'Please, use numbers' : ''

method ema(int len, float source) => 
    alpha = 2 / (len + 1)
    float ema = na
    sma = ta.sma(source, len)
    ema := alpha * source + (1 - alpha) * nz(ema[1], sma[1])

method rma(int len, float source) =>
    alpha = 1 / len, float sum = 0
    sum := na(sum[1]) ? ta.sma(source, len) : alpha * source + (1 - alpha) * nz(sum[1])

method value(string choice, array<string> setting, float targetExternal, float targetValue) => 
  
    sZ  =  setting.size() , float value = na
    int int1 = na 

    if sZ > 0
        for  i  = setting.size ( ) -1 to 0
            get = setting.get  (i) 
            if  get == ''   or get == ' '
             or get == '  ' or get == '   '
                setting.remove (i)

    isS = setting.isString()
    txt = switch 
        isS != '' => isS
        a_1Val.includes(choice) =>
            if setting.size() != 1
                str.format    (   'Please enter 1 value for {0}: {1}'        , choice, a_1ValValues.get(a_1Val.indexof(choice)))
            else 
                if setting.getSetting(0) - setting.getStFloat(0) != 0
                    str.format('{0} ({1}) -> Length must be an Integer value', choice, a_1ValValues.get(a_1Val.indexof(choice)))
        
        a_2Val.includes(choice) =>
            if setting.size() != 2
                str.format    (   'Please enter 2 values for {0}: {1}'       , choice, a_2ValValues.get(a_2Val.indexof(choice)))
            else 
                if setting.getSetting(0) - setting.getStFloat(0) != 0
                    str.format('{0} ({1}) -> Length must be an Integer value', choice, a_2ValValues.get(a_2Val.indexof(choice)))

        a_3Val.includes(choice) =>
            if setting.size() != 3
                str.format    (   'Please enter 3 values for {0}: {1}'       , choice, a_3ValValues.get(a_3Val.indexof(choice)))
            else                
                if  setting.getSetting(0) - setting.getStFloat(0) != 0                
                 or setting.getSetting(1) - setting.getStFloat(1) != 0
                 or setting.getSetting(2) - setting.getStFloat(2) != 0
                    'Each Number must be an Integer value'

    float shortEMA = na, float longEMA = na, float macd    = na, float signal  = na, float hist = na
    float BBmiddle = na, float BBupper = na, float BBlower = na
    float KCmiddle = na, float KCupper = na, float KClower = na

    if txt == '' 
        if str.contains(choice, 'BB')
            len           = setting.getSetting(0)
            BBmiddle     := ta.sma(close, len)
            float dev     = setting.getStFloat(1) * ta.stdev(close, len)
            BBupper      := BBmiddle + dev 
            BBlower      := BBmiddle - dev

        if str.contains(choice, 'KC')
            KCmiddle     := setting.getSetting(0).ema(close)
            KCrange       = setting.getSetting(0).ema(ta.tr) 
            KCupper      := KCmiddle + KCrange * setting.getStFloat(1)
            KClower      := KCmiddle - KCrange * setting.getStFloat(1)

        if str.contains(choice, 'MACD')
            shortEMA     := setting.getSetting(0).ema(close) 
            longEMA      := setting.getSetting(1).ema(close) 
            macd         := shortEMA - longEMA
            signal       := setting.getSetting(2).ema(macd)
            hist         := macd - signal 

        value := switch choice 

            'ACCDIST'        => ta.accdist

            'ATR'            => setting.getSetting(0).rma(ta.tr(true))

            'BB Middle'      => BBmiddle 
            'BB Upper'       => BBupper
            'BB Lower'       => BBlower

            'CCI'            => ta.cci(close, setting.getSetting(0))

            'CMO'            => ta.cmo(close, setting.getSetting(0))

            'COG'            => ta.cog(close, setting.getSetting(0))

            'DC High'        =>                                             ta.highest(setting.getSetting(0))             
            'DC Mid'         => math.avg(ta.highest(setting.getSetting(0)), ta.lowest (setting.getSetting(0)))
            'DC Low'         =>                                             ta.lowest (setting.getSetting(0)) 

            'DEMA'           =>  
                len  = setting.getSetting(0)
                ema1 = len.ema(close)
                ema2 = len.ema(ema1 )
                2    * ema1 -  ema2       

            'EMA'            => setting.getSetting(0).ema(close)

            'External'       => targetExternal

            'HMA'            => 
                len = setting.getSetting(0)
                ta.wma(2 * ta.wma(close, math.floor(len / 2)) - ta.wma(close, len), math.floor(math.sqrt(len)))

            'III'            => ta.iii 

            'KC Middle'      => KCmiddle
            'KC Upper'       => KCupper
            'KC Lower'       => KClower

            'LINREG'         => 
                len = setting.getSetting(0), off = setting.getSetting(1)
                float sX     = 0, float sY = 0, float sXSqr = 0, float sXY = 0
                for i = 1   to len
                    val      = close[len-i], per = i+1, sX += per, sY += val
                    sXSqr   += math.pow(per, 2), sXY += val * per
                slope        = (sXY * len - sX * sY) / (sXSqr * len - math.pow(sX, 2))
                intcp        = ta.sma(close, len) - slope * sX / len + slope
                intcp + slope * (len - off)

            'MACD'           => macd 
            'MACD-signal'    => signal
            'MACD-histogram' => hist

            'MEDIAN'         => ta.median(close, setting.getSetting(0))

            'MFI'            => ta.mfi(close, setting.getSetting(0))  

            'MODE'           => ta.mode(close, setting.getSetting(0))

            'MOM'            => ta.mom(close, setting.getSetting(0))  

            'NVI'            => ta.nvi

            'OBV'            => ta.obv

            'PVI'            => ta.pvi

            'PVT'            => ta.pvt 

            'SMA'            => ta.sma(close, setting.getSetting(0))

            'RMA'            => setting.getSetting(0).rma(close)

            'ROC'            => ta.roc(close, setting.getSetting(0))

            'RSI'            => 
                len  = setting.getSetting(0), var num = 0., var den = 0., d = nz(close - close[1])
                num += (math.max(d, 0) - num) / len, den += (math.abs(d   ) - den) / len
                num / den * 100        

            'STOCH'          => ta.stoch(close, high, low, setting.getSetting(0))

            'Supertrend'     => 
                len          = setting.getSetting(0), factor    = setting.getStFloat(1)
                var atr      = 0. , var upper = high, var lower = low, var float trend = na
                atr         += (nz(ta.tr) - atr)  / len
                up           = hl2 + atr * factor   , dn = hl2 - atr * factor
                upper       := close[1] < upper ? math.min(up, upper) : up
                lower       := close[1] > lower ? math.max(dn, lower) : dn
                trend       := close    > upper ? 1 : close < lower ? 0 : trend
                trend       == 1 ? lower : upper

            'TEMA'           => 
                len  = setting.getSetting(0)
                ema1 = len.ema(close)
                ema2 = len.ema(ema1 )
                ema3 = len.ema(ema2 )
                (3 * ema1) - (3 * ema2) + ema3

            'Value'          => targetValue

            'VWAP'           => ta.vwap(close)

            'VWMA'           => ta.vwma(close, setting.getSetting(0))
            
            'WAD'            => ta.wad 

            'WMA'            => ta.wma(close, setting.getSetting(0))

            'WVAD'           => ta.wvad

            '%R'             => ta.wpr(setting.getSetting(0))

    [txt, value]

//-----------------------------------------------------------------------------}
//Set target 1
//-----------------------------------------------------------------------------{
var color css            = na
bool      isNewTarget1   = false
bool      isTgReached1   = false

var int countTargets1   = 0
var int countTgReached1 = 0

var target1_object      = target.new(reached = true, active = false)

var setting1A           = str.split(targetTiSettings1A, ',')
var setting1B           = str.split(targetTiSettings1B, ',')

[txt1A, source1A] = targetSource1A.value(setting1A, targetExternal1A,       na     )
[txt1B, source1B] = targetSource1B.value(setting1B, targetExternal1B, targetValue1B)

target1_condition = switch target1Condition
    'CrossOver'  => ta.crossover (source1A, source1B)
    'CrossUnder' => ta.crossunder(source1A, source1B)
    'Cross'      => ta.cross     (source1A, source1B)
    'Equal'      => source1A == source1B

//Distance
dist1 = switch distOptions1
    'Currencies' => distTarget1
    '%' => close + distTarget1 / 100 * close
    'ATR' => nz(ta.atr(50)) * distTarget1
    'Ticks' => syminfo.mintick * distTarget1
    'External Value' => externalDist1 * distTarget1

if target1_object.active and target1_object.reached == false
    target1_object.lines.h.set_x2(n)
    target1_object.lbl.set_x(n)

if (isLong1 ? (useWicks1 ? high : close) > target1_object.value : (useWicks1 ? low : close) < target1_object.value) and target1_object.active 
    target1_object.reached := true
    target1_object.active  := false 
    isTgReached1           := true
    countTgReached1        += 1
    css := na
    target1_object.lbl.set_color(target1Css)

if enableTarget1 and 
 (
  (target1_condition and (waitTarget1 ? target1_object.reached : true)) 
  or 
  (newTarget1 and target1_object.reached)
 ) 
    target_value = close + (isLong1 ? dist1 : -dist1)

    //Delete label if reached and creating new target
    if newTarget1 and target1_object.reached and showLabels
        target1_object.lbl.delete()

    //Create new target
    target1_object := target.new(target_value, n, false, isLong1, active = true)

    if showLabels
        target1_object.lbl := label.new(n, target_value, 'Target'
          , color = color.new(target1Css, 50)
          , textcolor = color.white
          , size = size.tiny
          , style = label.style_label_left
          , tooltip = str.tostring(target_value, format.mintick))

    css := target1Css

    target1_object.set_target(target1Css, target1Style)

    isNewTarget1  := true 
    countTargets1 += 1

//-----------------------------------------------------------------------------}
//Set target 2
//-----------------------------------------------------------------------------{
bool     isNewTarget2   = false
bool     isTgReached2   = false

var int countTargets2   = 0
var int countTgReached2 = 0

var target2_object      = target.new(reached = true, active = false)

var setting2A           = str.split(targetTiSettings2A, ',')
var setting2B           = str.split(targetTiSettings2B, ',')

[txt2A, source2A] = targetSource2A.value(setting2A, targetExternal2A,       na     )
[txt2B, source2B] = targetSource2B.value(setting2B, targetExternal2B, targetValue2B)

target2_condition = switch target2Condition
    'CrossOver'  => ta.crossover (source2A, source2B)
    'CrossUnder' => ta.crossunder(source2A, source2B)
    'Cross'      => ta.cross     (source2A, source2B)
    'Equal'      => source2A == source2B

//Distance
dist2 = switch distOptions2
    'Currencies' => distTarget2
    '%' => close + distTarget2 / 100 * close
    'ATR' => nz(ta.atr(50)) * distTarget2
    'Ticks' => syminfo.mintick * distTarget2
    'External Value' => externalDist2 * distTarget2

if target2_object.active and target2_object.reached == false
    target2_object.lines.h.set_x2(n)
    target2_object.lbl.set_x(n)

if (isLong2 ? (useWicks2 ? high : close) > target2_object.value : (useWicks2 ? low : close) < target2_object.value) and target2_object.active 
    target2_object.reached := true
    target2_object.active  := false 
    isTgReached2           := true
    countTgReached2        += 1
    css := na
    target2_object.lbl.set_color(target2Css)

if enableTarget2     and
 (
  (target2_condition and (waitTarget2 ? target2_object.reached : true)) 
  or 
  (newTarget2 and target2_object.reached)
 ) 
    target_value = close + (isLong2 ? dist2 : -dist2)

    //Delete label if reached and creating new target
    if newTarget2 and target2_object.reached and showLabels
        target2_object.lbl.delete()

    //Create new target
    target2_object := target.new(target_value, n, false, isLong2, active = true)

    if showLabels
        target2_object.lbl := label.new(n, target_value, 'Target'
          , color = color.new(target2Css, 50)
          , textcolor = color.white
          , size = size.tiny
          , style = label.style_label_left
          , tooltip = str.tostring(target_value, format.mintick))
    
    css := target2Css

    target2_object.set_target(target2Css, target2Style)

    isNewTarget2  := true 
    countTargets2 += 1

//-----------------------------------------------------------------------------}
//Plots
//-----------------------------------------------------------------------------{
noVisuals1 = array.includes(aNoVisuals, targetSource1A) or array.includes(aNoVisuals, targetSource1B) 
noVisuals2 = array.includes(aNoVisuals, targetSource2A) or array.includes(aNoVisuals, targetSource2B) 

plot(showSource1 and enableTarget1 and not noVisuals1 ? source1A : na, 'Target 1, source A', color=#089981)
plot(showSource1 and enableTarget1 and not noVisuals1 ? source1B : na, 'Target 1, source B', color=#2157f3)

plot(showSource2 and enableTarget2 and not noVisuals2 ? source2A : na, 'Target 2, source A', color=#ffe400)
plot(showSource2 and enableTarget2 and not noVisuals2 ? source2B : na, 'Target 2, source B', color=#ff1100)

barcolor(candleColoring ? css : na, title = 'Candle Coloring')

//-----------------------------------------------------------------------------}
//Dashboard
//-----------------------------------------------------------------------------{
var table_position = dashLoc == 'Bottom Left' ? position.bottom_left 
  : dashLoc == 'Top Right' ? position.top_right 
  : position.bottom_right

var table_size = textSize == 'Tiny' ? size.tiny 
  : textSize == 'Small' ? size.small 
  : size.normal

var tb = table.new(table_position, 3, 8 // 4 + countErrors
  , bgcolor      = #1e222d
  , border_color = #373a46
  , border_width = 1
  , frame_color  = #373a46
  , frame_width  = 1)

countErrors  = 0
countErrors += txt1A != '' ? 1 : 0
countErrors += txt1B != '' ? 1 : 0
countErrors += txt2A != '' ? 1 : 0
countErrors += txt2B != '' ? 1 : 0

if showDash

    if barstate.isfirst
        if enableTarget1 or enableTarget2
            tb.cell(0, 0,             ''           , text_color = color.white, text_size = table_size)
            tb.cell(1, 0,          'Count'         , text_color = color.white, text_size = table_size)
            tb.cell(2, 0,    'Target\nReached'     , text_color = color.white, text_size = table_size)
            tb.cell(0, 3,         'Total'          , text_color = color.white, text_size = table_size)

        if enableTarget1
            tb.cell(0, 1,        'Target 1'        , text_color = color.white, text_size = table_size)
        if enableTarget2
            tb.cell(0, 2,        'Target 2'        , text_color = color.white, text_size = table_size)
        
        if enableTarget1 and txt1A != '' 
            tb.merge_cells(0, 4, 2, 4)
            tb.cell(0, 4, str.format("Target 1, Source A: {0}\n", txt1A), text_color=#FF0000, text_halign=text.align_left)
        if enableTarget1 and txt1B != '' 
            tb.merge_cells(0, 5, 2, 5)
            tb.cell(0, 5, str.format("Target 1, Source B: {0}\n", txt1B), text_color=#FF0000, text_halign=text.align_left)
        if enableTarget2 and txt2A != '' 
            tb.merge_cells(0, 6, 2, 6)
            tb.cell(0, 6, str.format("Target 2, Source A: {0}\n", txt2A), text_color=#FF0000, text_halign=text.align_left)
        if enableTarget2 and txt2B != '' 
            tb.merge_cells(0, 7, 2, 7)
            tb.cell(0, 7, str.format("Target 2, Source B: {0}\n", txt2B), text_color=#FF0000, text_halign=text.align_left)

    if barstate.islast

        totT = countTargets1   + countTargets2        
        totR = countTgReached1 + countTgReached2
 
        if enableTarget1
            tb.cell(1, 1, str.tostring(countTargets1)                                                                       , text_color = color.white, text_size = table_size)
            tb.cell(2, 1, str.format  ('{0} ({1}%)', countTgReached1 , math.round(100 / countTargets1 * countTgReached1, 1)), text_color = color.white, text_size = table_size)
        if enableTarget2
            tb.cell(1, 2, str.tostring(countTargets2)                                                                       , text_color = color.white, text_size = table_size)
            tb.cell(2, 2, str.format  ('{0} ({1}%)', countTgReached2 , math.round(100 / countTargets2 * countTgReached2, 1)), text_color = color.white, text_size = table_size)
        if enableTarget1 or enableTarget2
            tb.cell(1, 3, str.tostring(     totT    )                                                                       , text_color = color.white, text_size = table_size)
            tb.cell(2, 3, str.format  ('{0} ({1}%)',       totR      , math.round(100 /      totT     *       totR     , 1)), text_color = color.white, text_size = table_size)

//-----------------------------------------------------------------------------}
//Alerts
//-----------------------------------------------------------------------------{
alertcondition(isNewTarget1, "Target 1 New"    , "Target 1 New"    )
alertcondition(isTgReached1, 'Target 1 Reached', 'Target 1 Reached')

alertcondition(isNewTarget2, "Target 2 New"    , "Target 2 New"    )
alertcondition(isTgReached2, 'Target 2 Reached', 'Target 2 Reached')


//-----------------------------------------------------------------------------}
//Market Structure Break & Order Block
//-----------------------------------------------------------------------------{
settings = "Settings"
zigzag_len = input.int(9, "ZigZag Length", group=settings)
show_zigzag = input.bool(false, "Show Zigzag", group=settings)
fib_factor = input.float(0.273, "Fib Factor for breakout confirmation", 0, 1, 0.01, group=settings)

text_size = input.string(size.tiny, "Text Size", [size.tiny, size.small, size.normal, size.large, size.huge], group=settings)

delete_boxes = input.bool(true, "Delete Old/Broken Boxes", group=settings)

bu_ob_inline_color = "Bu-OB Colors"
be_ob_inline_color = "Be-OB Colors"
bu_bb_inline_color = "Bu-BB Colors"
be_bb_inline_color = "Be-BB Colors"

bu_ob_display_settings = "Bu-OB Display Settings"
bu_ob_color = input.color(color.new(color.green, 70), "Color", group=bu_ob_display_settings, inline=bu_ob_inline_color)
bu_ob_border_color = input.color(color.rgb(76, 175, 79, 70), "Border Color", group=bu_ob_display_settings, inline=bu_ob_inline_color)
bu_ob_text_color = input.color(color.rgb(76, 175, 79, 70), "Text Color", group=bu_ob_display_settings, inline=bu_ob_inline_color)

be_ob_display_settings = "Be-OB Display Settings"
be_ob_color = input.color(color.new(color.red, 70), "Color", group=be_ob_display_settings, inline=be_ob_inline_color)
be_ob_border_color = input.color(color.rgb(255, 82, 82, 70), "Border Color", group=be_ob_display_settings, inline=be_ob_inline_color)
be_ob_text_color = input.color(color.rgb(255, 82, 82, 70), "Text Color", group=be_ob_display_settings, inline=be_ob_inline_color)

bu_bb_display_settings = "Bu-BB & Bu-MB Display Settings"
bu_bb_color = input.color(color.new(color.green, 70), "Color", group=bu_bb_display_settings, inline=bu_bb_inline_color)
bu_bb_border_color = input.color(color.rgb(76, 175, 79, 70), "Border Color", group=bu_bb_display_settings, inline=bu_bb_inline_color)
bu_bb_text_color = input.color(color.rgb(76, 175, 79, 70), "Text Color", group=bu_bb_display_settings, inline=bu_bb_inline_color)

be_bb_display_settings = "Be-BB & Be-MB Display Settings"
be_bb_color = input.color(color.new(color.red, 70), "Color", group=be_bb_display_settings, inline=be_bb_inline_color)
be_bb_border_color = input.color(color.rgb(255, 82, 82, 70), "Border Color", group=be_bb_display_settings, inline=be_bb_inline_color)
be_bb_text_color = input.color(color.rgb(255, 82, 82, 70), "Text Color", group=be_bb_display_settings, inline=be_bb_inline_color)


var float[] high_points_arr = array.new_float(5)
var int[] high_index_arr = array.new_int(5)
var float[] low_points_arr = array.new_float(5)
var int[] low_index_arr = array.new_int(5)

var box[] bu_ob_boxes = array.new_box(5)
var box[] be_ob_boxes = array.new_box(5)
var box[] bu_bb_boxes = array.new_box(5)
var box[] be_bb_boxes = array.new_box(5)

to_up = high >= ta.highest(zigzag_len)
to_down = low <= ta.lowest(zigzag_len)

trend = 1
trend := nz(trend[1], 1)
trend := trend == 1 and to_down ? -1 : trend == -1 and to_up ? 1 : trend

last_trend_up_since = ta.barssince(to_up[1])
low_val = ta.lowest(nz(last_trend_up_since > 0 ? last_trend_up_since : 1, 1))
low_index = bar_index - ta.barssince(low_val == low)

last_trend_down_since = ta.barssince(to_down[1])
high_val = ta.highest(nz(last_trend_down_since > 0 ? last_trend_down_since : 1, 1))
high_index = bar_index - ta.barssince(high_val == high)

if ta.change(trend) != 0
    if trend == 1
        array.push(low_points_arr, low_val)
        array.push(low_index_arr, low_index)
    if trend == -1
        array.push(high_points_arr, high_val)
        array.push(high_index_arr, high_index)


f_get_high(ind) =>
    [array.get(high_points_arr, array.size(high_points_arr) - 1 - ind), array.get(high_index_arr, array.size(high_index_arr) - 1 - ind)]


f_get_low(ind) =>
    [array.get(low_points_arr, array.size(low_points_arr) - 1 - ind), array.get(low_index_arr, array.size(low_index_arr) - 1 - ind)]


f_delete_box(box_arr) =>
    if delete_boxes
        box.delete(array.shift(box_arr))
    else
        array.shift(box_arr)
    0


[h0, h0i] = f_get_high(0)
[h1, h1i] = f_get_high(1)

[l0, l0i] = f_get_low(0)
[l1, l1i] = f_get_low(1)

if ta.change(trend) != 0 and show_zigzag
    if trend == 1
        line.new(h0i, h0, l0i, l0)
    if trend == -1
        line.new(l0i, l0, h0i, h0)

market = 1
market := nz(market[1], 1)
// market := market == 1 and close < l0 and low < l0 - math.abs(h0 - l0) * fib_factor ? -1 : market == -1 and close > h0 and high > h0 + math.abs(h0 - l0) * fib_factor ? 1 : market
last_l0 = ta.valuewhen(ta.change(market) != 0, l0, 0)
last_h0 = ta.valuewhen(ta.change(market) != 0, h0, 0)
market := last_l0 == l0 or last_h0 == h0 ? market : market == 1 and l0 < l1 and l0 < l1 - math.abs(h0 - l1) * fib_factor ? -1 : market == -1 and h0 > h1 and h0 > h1 + math.abs(h1 - l0) * fib_factor ? 1 : market

bu_ob_index = bar_index
bu_ob_index := nz(bu_ob_index[1], bar_index)
for i=h1i to l0i[zigzag_len]
    index = bar_index - i 
    if open[index] > close[index]
        bu_ob_index := bar_index[index]

bu_ob_since = bar_index - bu_ob_index

be_ob_index = bar_index
be_ob_index := nz(be_ob_index[1], bar_index)
for i=l1i to h0i[zigzag_len]
    index = bar_index - i 
    if open[index] < close[index]
        be_ob_index := bar_index[index]

be_ob_since = bar_index - be_ob_index

be_bb_index = bar_index
be_bb_index := nz(be_bb_index[1], bar_index)
for i=h1i - zigzag_len to l1i
    index = bar_index - i
    if open[index] > close[index]
        be_bb_index := bar_index[index]

be_bb_since = bar_index - be_bb_index

bu_bb_index = bar_index
bu_bb_index := nz(bu_bb_index[1], bar_index)
for i=l1i - zigzag_len to h1i
    index = bar_index - i
    if open[index] < close[index]
        bu_bb_index := bar_index[index]

bu_bb_since = bar_index - bu_bb_index

if ta.change(market) != 0
    if market == 1
        line.new(h1i, h1, h0i, h1, color=color.rgb(76, 175, 79, 100), width=1)
        label.new(int(math.avg(h1i, l0i)), h1, "MSB", color=color.new(color.black, 100), style=label.style_label_down, textcolor=color.rgb(76, 175, 79, 100), size=size.small)
        bu_ob = box.new(bu_ob_index, high[bu_ob_since], bar_index + 10, low[bu_ob_since], bgcolor=bu_ob_color, border_color=bu_ob_border_color, text="Bu-OB", text_color=bu_ob_text_color, text_halign=text.align_right, text_size=text_size)
        bu_bb = box.new(bu_bb_index, high[bu_bb_since], bar_index + 10, low[bu_bb_since], bgcolor=bu_bb_color, border_color=bu_bb_border_color, text=l0 < l1 ? "Bu-BB" : "Bu-MB", text_color=bu_bb_text_color, text_halign=text.align_right, text_size=text_size)
        array.push(bu_ob_boxes, bu_ob)
        array.push(bu_bb_boxes, bu_bb)
    if market == -1
        line.new(l1i, l1, l0i, l1, color=color.rgb(255, 82, 82, 100), width=1)
        label.new(int(math.avg(l1i, h0i)), l1, "MSB", color=color.new(color.black, 100), style=label.style_label_up, textcolor=color.rgb(255, 82, 82, 100), size=size.small)
        be_ob = box.new(be_ob_index, high[be_ob_since], bar_index + 10, low[be_ob_since], bgcolor=be_ob_color, border_color=be_ob_border_color, text="Be-OB", text_color=be_ob_text_color, text_halign=text.align_right, text_size=text_size)
        be_bb = box.new(be_bb_index, high[be_bb_since], bar_index + 10, low[be_bb_since], bgcolor=be_bb_color, border_color=be_bb_border_color, text=h0 > h1 ? "Be-BB" : "Be-MB", text_color=be_bb_text_color, text_halign=text.align_right, text_size=text_size)
        array.push(be_ob_boxes, be_ob)
        array.push(be_bb_boxes, be_bb)

for bull_ob in bu_ob_boxes
    bottom = box.get_bottom(bull_ob)
    top = box.get_top(bull_ob)
    if close < bottom
        f_delete_box(bu_ob_boxes)
    else if close < top
        alert("Price in the BU-OB zone")
    else
        box.set_right(bull_ob, bar_index + 10)
    
for bear_ob in be_ob_boxes
    top = box.get_top(bear_ob)
    bottom = box.get_bottom((bear_ob))
    if close > top
        f_delete_box(be_ob_boxes)
    if close > bottom
        alert("Price in the BE-OB zone")
    else
        box.set_right(bear_ob, bar_index + 10)
        
for bear_bb in be_bb_boxes
    top = box.get_top(bear_bb)
    bottom = box.get_bottom(bear_bb)
    if close > top
        f_delete_box(be_bb_boxes)
    else if close > bottom
        alert("Price in the BE-BB zone")
    else
        box.set_right(bear_bb, bar_index + 10)
        
for bull_bb in bu_bb_boxes
    bottom = box.get_bottom(bull_bb)
    top = box.get_top(bull_bb)
    if close < bottom
        f_delete_box(bu_bb_boxes)
    else if close < top
        alert("Price in the BU-BB zone")
    else
        box.set_right(bull_bb, bar_index + 10)


alertcondition(ta.change(market) != 0, "MSB", "MSB")

//-----------------------------------------------------------------------------}
//SUPPLY AND DEMAND
//-----------------------------------------------------------------------------{
//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
per = input.float(10., 'Threshold %', minval = 0, maxval = 100)
div = input.int(50, 'Resolution'    , minval = 2, maxval = 500)
tf  = input.timeframe('', 'Intrabar TF')

//Colors
showSupply = input(true ,'Supply        ', inline = 'supply', group = 'Style')
supplyCss  = input(#2156f321, ''         , inline = 'supply', group = 'Style')
supplyArea = input(true ,'Area'          , inline = 'supply', group = 'Style')
supplyAvg  = input(true ,'Average'       , inline = 'supply', group = 'Style')
supplyWavg = input(true ,'Weighted'      , inline = 'supply', group = 'Style')

showEqui   = input(false ,'Equilibrium'   , inline = 'equi'  , group = 'Style')
equiCss    = input(color.gray, ''      , inline = 'equi'  , group = 'Style')
equiAvg    = input(true ,'Average'       , inline = 'equi'  , group = 'Style')
equiWavg   = input(true ,'Weighted'      , inline = 'equi'  , group = 'Style')

showDemand = input(true ,'Demand    '    , inline = 'demand', group = 'Style')
demandCss  = input(#ff5e0020, ''         , inline = 'demand', group = 'Style')
demandArea = input(true ,'Area'          , inline = 'demand', group = 'Style')
demandAvg  = input(true ,'Average'       , inline = 'demand', group = 'Style')
demandWavg = input(true ,'Weighted'      , inline = 'demand', group = 'Style')

//-----------------------------------------------------------------------------}
//UDT's
//-----------------------------------------------------------------------------{
type bin
    float lvl
    float prev
    float sum
    float prev_sum
    float csum
    float avg
    bool isreached

type area
    box  bx
    line avg 
    line wavg 

//-----------------------------------------------------------------------------}
//Functions
//-----------------------------------------------------------------------------{

get_hlv()=> [high, low, volume]

method set_area(area id, x1, top, btm, avg, wavg, showArea, showAvg, showWavg)=>
    if showArea
        id.bx.set_lefttop(x1, top)
        id.bx.set_rightbottom(n, btm)    
    
    if showAvg
        id.avg.set_xy1(x1, avg)
        id.avg.set_xy2(n, avg)
    
    if showWavg
        id.wavg.set_xy1(x1, wavg)
        id.wavg.set_xy2(n, wavg)

//-----------------------------------------------------------------------------}
//Main variables
//-----------------------------------------------------------------------------{
var max1  = 0. 
var min1  = 0.
var x1   = 0
var csum = 0.

//Intrabar data
[h, l, v] = request.security_lower_tf(syminfo.tickerid, tf, get_hlv())

//Init on left bar
if time == chart.left_visible_bar_time
    max1 := high
    min1 := low
    csum := volume
    x1 := n
else //Accumulate
    max1 := math.max(high, max1)
    min1 := math.min(low, min1)
    csum += volume

//-----------------------------------------------------------------------------}
//Set zones
//-----------------------------------------------------------------------------{
var supply_area = area.new(
  box.new(na, na, na, na, na, bgcolor = color.new(supplyCss, 90))
  , line.new(na, na, na, na, color = supplyCss)
  , line.new(na, na, na, na, color = supplyCss, style = line.style_dashed))

var demand_area = area.new(
  box.new(na, na, na, na, na, bgcolor = color.new(demandCss, 90))
  , line.new(na, na, na, na, color = demandCss)
  , line.new(na, na, na, na, color = demandCss, style = line.style_dashed))

var equi  = line.new(na, na, na, na, color = equiCss)
var wequi = line.new(na, na, na, na, color = equiCss, style = line.style_dashed)

var float supply_wavg = na
var float demand_wavg = na

if time == chart.right_visible_bar_time
    r = (max1 - min1) / div
    supply = bin.new(max1, max1, 0, 0, 0, 0, false)
    demand = bin.new(min1, min1, 0, 0, 0, 0, false)

    //Loop trough intervals
    for i = 0 to div-1
        supply.lvl -= r
        demand.lvl += r

        //Accumulated volume column
        if not supply.isreached and showSupply and supplyArea
            box.new(x1, supply.prev, x1 + int(supply.sum / csum * (n - x1)), supply.lvl, na
              , bgcolor = color.new(supplyCss, 50))
        
        if not demand.isreached and showDemand and demandArea
            box.new(x1, demand.lvl, x1 + int(demand.sum / csum * (n - x1)), demand.prev, na
              , bgcolor = color.new(demandCss, 50))
        
        //Loop trough bars
        for j = 0 to (n - x1)-1
            //Loop trough intrabars
            for k = 0 to (v[j]).size()-1
                //Accumulate if within upper internal
                supply.sum      += (h[j]).get(k) > supply.lvl and (h[j]).get(k) < supply.prev ? (v[j]).get(k) : 0
                supply.avg      += supply.lvl * (supply.sum - supply.prev_sum)
                supply.csum     += supply.sum - supply.prev_sum
                supply.prev_sum := supply.sum

                //Accumulate if within lower interval
                demand.sum      += (l[j]).get(k) < demand.lvl and (l[j]).get(k) > demand.prev ? (v[j]).get(k) : 0
                demand.avg      += demand.lvl * (demand.sum - demand.prev_sum)
                demand.csum     += demand.sum - demand.prev_sum
                demand.prev_sum := demand.sum
                
            //Test if supply accumulated volume exceed threshold and set box
            if supply.sum / csum * 100 > per and not supply.isreached
                avg = math.avg(max1, supply.lvl)
                supply_wavg := supply.avg / supply.csum

                //Set Box/Level coordinates
                if showSupply
                    supply_area.set_area(x1, max1, supply.lvl, avg, supply_wavg, supplyArea, supplyAvg, supplyWavg)

                supply.isreached := true
            
            //Test if demand accumulated volume exceed threshold and set box
            if demand.sum / csum * 100 > per and not demand.isreached and showDemand
                avg = math.avg(min1, demand.lvl)
                demand_wavg := demand.avg / demand.csum
                
                //Set Box/Level coordinates
                if showDemand
                    demand_area.set_area(x1, demand.lvl, min1, avg, demand_wavg, demandArea, demandAvg, demandWavg)

                demand.isreached := true
            
            if supply.isreached and demand.isreached
                break
        
        if supply.isreached and demand.isreached and showEqui
            //Set equilibrium
            if equiAvg
                avg = math.avg(max1, min1)
                equi.set_xy1(x1, avg)
                equi.set_xy2(n, avg)
            
            //Set weighted equilibrium
            if equiWavg
                wavg = math.avg(supply_wavg, demand_wavg)
                wequi.set_xy1(x1, wavg)
                wequi.set_xy2(n, wavg)

            break
        
        supply.prev := supply.lvl
        demand.prev := demand.lvl

//-----------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------}
//MACD Based Price Forecasting
//---------------------------------------------------------------------------------------------------------------------{
//---------------------------------------------------------------------------------------------------------------------}
//Settings
//---------------------------------------------------------------------------------------------------------------------{
//MACD
fast = input.int(12, 'Fast Length', minval = 2, group = 'MACD')
slow = input.int(26, 'Slow Length', minval = 2, group = 'MACD')
sigLen = input.int(9, 'Signal Length', minval = 2, group = 'MACD')

trend1 = input.string('MACD - Signal', 'Trend Determination',
  options = ['MACD', 'MACD - Signal'],
  group = 'MACD')

//Forecast
maxMemory = input.int(50, 'Maximum Memory', minval = 2, group = 'Forecast')
fcast = input.int(100, 'Forecasting Length', minval = 1, group = 'Forecast')
upPer = input(80, 'Top Percentile', group = 'Forecast')
midPer = input(50, 'Average Percentage', group = 'Forecast')
dnPer = input(20, 'Bottom Percentile', group = 'Forecast')

//Style
upLine = input(#3179f5, 'Line Color', inline = 'css', group = 'Style')
dnLine = input(#ff5d00, '', inline = 'css', group = 'Style')

upArea = input(color.new(#3179f5, 80), 'Areas', inline = 'areas', group = 'Style')
dnArea = input(color.new(#ff5d00, 80), '', inline = 'areas', group = 'Style')

signalArea = input(true, 'Signal Area', inline = 'signal', group = 'Style')
signalBull = input(color.new(#089981, 50), '', inline = 'signal', group = 'Style')
signalBear = input(color.new(#f23645, 50), '', inline = 'signal', group = 'Style')

//---------------------------------------------------------------------------------------------------------------------}
//Types
//---------------------------------------------------------------------------------------------------------------------{
type vector
    array<float> id

type holder
    array<vector> id

//---------------------------------------------------------------------------------------------------------------------}
//Methods/Functions
//---------------------------------------------------------------------------------------------------------------------{

method populate(holder get_holder, idx, init_price)=>
    if get_holder.id.size() < idx+1
        get_holder.id.push(vector.new(array.new<float>(0)))

    get_holder.id.get(idx).id.unshift(close - init_price)
    
    //Remove last element if array size is greater than specified limit
    if get_holder.id.get(idx).id.size() > maxMemory
        get_holder.id.get(idx).id.pop()

method forecast(holder get_holder, idx, init_price, upper_coords, mid_coords, lower_coords)=>
    max_horizon = get_holder.id.size()

    x = 0
    for i = idx-1 to math.min(idx+fcast, max_horizon-1)
        get_vector = get_holder.id.get(i)
        
        //Compute forecasts
        upper = init_price + get_vector.id.percentile_linear_interpolation(upPer)
        mid   = init_price + get_vector.id.percentile_linear_interpolation(midPer)
        lower = init_price + get_vector.id.percentile_linear_interpolation(dnPer)

        //Append coordinates
        upper_coords.push(chart.point.from_index(n+x, upper))
        mid_coords.push(chart.point.from_index(n+x, mid))
        lower_coords.unshift(chart.point.from_index(n+x, lower))
        x += 1

//---------------------------------------------------------------------------------------------------------------------}
//Calculations
//---------------------------------------------------------------------------------------------------------------------{
var memory = map.new<int, holder>()
var up_idx = 0
var dn_idx = 0
var uptrend_init_price = close
var downtrend_init_price = close

//Compute MACD
[macd, signal, _] = ta.macd(close, fast, slow, sigLen)

//Populate map
if barstate.isfirst
    memory.put(1, holder.new(array.new<vector>(0)))
    memory.put(0, holder.new(array.new<vector>(0)))

trigger = switch trend1
    'MACD' => ta.cross(macd, 0)
    => ta.cross(macd, signal)

uptrend = trend1 == 'MACD' ? macd > 0 : macd > signal
downtrend = trend1 == 'MACD' ? macd < 0 : macd < signal

//Reference prices
uptrend_init_price := uptrend and not uptrend[1] ? close : uptrend_init_price
downtrend_init_price := downtrend and not downtrend[1] ? close : downtrend_init_price
init_value = uptrend ? uptrend_init_price : downtrend_init_price

//Uptrend
if uptrend
    get_holder = memory.get(1)
    get_holder.populate(up_idx, uptrend_init_price)

//Downtrend
if downtrend
    get_holder = memory.get(0)
    get_holder.populate(dn_idx, downtrend_init_price)

//Indices
up_idx := not uptrend ? 0 : up_idx + 1
dn_idx := not downtrend ? 0 : dn_idx + 1

if trigger
    upper_coords = array.new<chart.point>(0)
    mid_coords = array.new<chart.point>(0)
    lower_coords = array.new<chart.point>(0)

    if uptrend
        get_holder = memory.get(1)
        get_holder.forecast(up_idx, uptrend_init_price, upper_coords, mid_coords, lower_coords)
    else
        get_holder = memory.get(0)
        get_holder.forecast(dn_idx, downtrend_init_price, upper_coords, mid_coords, lower_coords)
    
    polyline.delete(polyline.new(mid_coords, line_color = uptrend ? upLine : dnLine)[1])

    //Area
    polyline.delete(polyline.new(array.concat(upper_coords, lower_coords)
      , line_color = na
      , fill_color = uptrend ? upArea : dnArea)
      [1])

//---------------------------------------------------------------------------------------------------------------------}
//Plots
//---------------------------------------------------------------------------------------------------------------------{
init_plot = plot(init_value, "Reference Price", init_value != init_value[1] ? na : color.rgb(120, 123, 134, 80))
price_plot = plot(close, editable = false, display = display.none)

top_css = not signalArea ? na : uptrend ? signalBull : color.new(chart.bg_color, 100)
btm_css = not signalArea ? na : uptrend ? color.new(chart.bg_color, 100) : signalBear

//Price to Reference Area
fill(init_plot, price_plot,
  top_value = math.max(close, uptrend ? uptrend_init_price : downtrend_init_price),
  bottom_value = math.min(close, uptrend ? uptrend_init_price : downtrend_init_price),
  top_color = top_css,
  bottom_color = btm_css)

//---------------------------------------------------------------------------------------------------------------------}
//---------------------------------------------------------------------------------------------------------------------}
//Market Structure with Inducements & Sweeps
//---------------------------------------------------------------------------------------------------------------------{
//---------------------------------------------------------------------------------------------------------------------}
//Settings
//---------------------------------------------------------------------------------------------------------------------{
len = input(50, 'CHoCH Detection Period')
shortLen = input(3, 'IDM Detection Period')

//Styling
bullCss = input(#08998100, 'Bullish Elements', group = 'Style')
bearCss = input(#ff525200, 'Bearish Elements', group = 'Style')

showChoch = input(false, "Show CHoCH", group = 'Style')
showBos = input(false, "Show BOS", group = 'Style')

showIdm = input(false, "Show Inducements", inline = 'idm', group = 'Style')
idmCss = input(color.gray, "", inline = 'idm', group = 'Style')

showSweeps = input(false, "Show Sweeps", inline = 'sweeps', group = 'Style')
sweepsCss = input(color.gray, "", inline = 'sweeps', group = 'Style')

showCircles = input(true, "Show Swings", group = 'Style')

//---------------------------------------------------------------------------------------------------------------------}
//Functions
//---------------------------------------------------------------------------------------------------------------------{
//Swings detection/measurements

swings(len)=>
    var os = 0
    var int topx = na
    var int btmx = na
    
    upper = ta.highest(len)
    lower = ta.lowest(len)

    os := high[len] > upper ? 0 : low[len] < lower ? 1 : os[1]

    top = os == 0 and os[1] != 0 ? high[len] : na
    topx := os == 0 and os[1] != 0 ? n[len] : topx

    btm = os == 1 and os[1] != 1 ? low[len] : na
    btmx := os == 1 and os[1] != 1 ? n[len] : btmx

    [top, topx, btm, btmx]

//---------------------------------------------------------------------------------------------------------------------}
//Swings
//---------------------------------------------------------------------------------------------------------------------{
[top, topx, btm, btmx] = swings(len)
[stop, stopx, sbtm, sbtmx] = swings(shortLen)

var os = 0
var top_crossed = false
var btm_crossed = false

var float max = na
var float min = na

var int max_x1 = na
var int min_x1 = na

var float topy = na
var float btmy = na
var stop_crossed = false
var sbtm_crossed = false    

//---------------------------------------------------------------------------------------------------------------------}
//CHoCH Detection
//---------------------------------------------------------------------------------------------------------------------{
if top
    topy := top
    top_crossed := false
if btm
    btmy := btm
    btm_crossed := false

//Test for CHoCH
if close > topy and not top_crossed
    os := 1
    top_crossed := true
if close < btmy and not btm_crossed
    os := 0
    btm_crossed := true

//Display CHoCH
if os != os[1]
    max := high
    min := low
    max_x1 := n
    min_x1 := n
    stop_crossed := false
    sbtm_crossed := false

    if os == 1 and showChoch
        line.new(topx, topy, n, topy, color = bullCss, style = line.style_dashed)
        label.new(int(math.avg(n, topx)), topy, 'CHoCH', color = color(na), style = label.style_label_down, textcolor = bullCss, size = size.tiny)
    else if showChoch
        line.new(btmx, btmy, n, btmy, color = bearCss, style = line.style_dashed)
        label.new(int(math.avg(n, btmx)), btmy, 'CHoCH', color = color(na), style = label.style_label_up, textcolor = bearCss, size = size.tiny)

stopy = fixnan(stop)
sbtmy = fixnan(sbtm)

//---------------------------------------------------------------------------------------------------------------------}
//Bullish BOS
//---------------------------------------------------------------------------------------------------------------------{
//IDM
if low < sbtmy and not sbtm_crossed and os == 1 and sbtmy != btmy
    if showIdm
        line.new(sbtmx, sbtmy, n, sbtmy, color = color.gray, style = line.style_dotted)
        label.new(int(math.avg(n, sbtmx)), sbtmy, 'IDM', color = color(na), style = label.style_label_up, textcolor = color.gray, size = size.tiny)
    
    sbtm_crossed := true

//BOS
if close > max and sbtm_crossed and os == 1
    if showBos
        line.new(max_x1, max, n, max, color = bullCss)
        label.new(int(math.avg(n, max_x1)), max, 'BOS', color = color(na), style = label.style_label_down, textcolor = bullCss, size = size.tiny)
    
    sbtm_crossed := false

//---------------------------------------------------------------------------------------------------------------------}
//Bearish BOS
//---------------------------------------------------------------------------------------------------------------------{
//IDM
if high > stopy and not stop_crossed and os == 0 and stopy != topy
    if showIdm
        line.new(stopx, stopy, n, stopy, color = color.gray, style = line.style_dotted)
        label.new(int(math.avg(n, stopx)), stopy, 'IDM', color = color(na), style = label.style_label_down, textcolor = color.gray, size = size.tiny)
    
    stop_crossed := true

//BOS
if close < min and stop_crossed and os == 0
    if showBos
        line.new(min_x1, min, n, min, color = bearCss)
        label.new(int(math.avg(n, min_x1)), min, 'BOS', color = color(na), style = label.style_label_up, textcolor = bearCss, size = size.tiny)
    
    stop_crossed := false

//---------------------------------------------------------------------------------------------------------------------}
//Sweeps
//---------------------------------------------------------------------------------------------------------------------{
if high > max and close < max and os == 1 and n - max_x1 > 1 and showSweeps
    line.new(max_x1, max, n, max, color = color.gray, style = line.style_dotted)
    label.new(int(math.avg(n, max_x1)), max, 'x', color = color(na), style = label.style_label_down, textcolor = color.gray)

if low < min and close > min and os == 0 and n - min_x1 > 1 and showSweeps
    line.new(min_x1, min, n, min, color = color.gray, style = line.style_dotted)
    label.new(int(math.avg(n, min_x1)), min, 'x', color = color(na), style = label.style_label_up, textcolor = color.gray)

//Trailing max/min
max := math.max(high, max)
min := math.min(low, min)

if max > max[1]
    max_x1 := n
if min < min[1]
    min_x1 := n

//---------------------------------------------------------------------------------------------------------------------}
//Extensions
//---------------------------------------------------------------------------------------------------------------------{
var ext_choch = line.new(na,na,na,na, style = line.style_dashed)
var ext_bos   = line.new(na,na,na,na)
var ext_idm   = line.new(na,na,na,na, style = line.style_dotted, color = idmCss)

var ext_choch_lbl = label.new(na,na, 'CHoCH', color = color(na), size = size.tiny)
var ext_bos_lbl   = label.new(na,na, 'BOS'  , color = color(na), size = size.tiny)
var ext_idm_lbl   = label.new(na,na, 'IDM'  , color = color(na), size = size.tiny, textcolor = idmCss)

if barstate.islast
    if os == 1
        ext_choch.set_xy1(btmx, btmy), ext_choch.set_xy2(n, btmy), ext_choch.set_color(bearCss)    
        ext_choch_lbl.set_xy(n, btmy), ext_choch_lbl.set_style(label.style_label_up), ext_choch_lbl.set_textcolor(bearCss)
        
        ext_bos.set_xy1(max_x1, max), ext_bos.set_xy2(n, max), ext_bos.set_color(bullCss)    
        ext_bos_lbl.set_xy(n, max), ext_bos_lbl.set_style(label.style_label_down), ext_bos_lbl.set_textcolor(bullCss)
        
        if not sbtm_crossed
            ext_idm.set_xy1(sbtmx, sbtmy), ext_idm.set_xy2(n+15, sbtmy)   
            ext_idm_lbl.set_xy(n+15, sbtmy), ext_idm_lbl.set_style(label.style_label_up)
            ext_idm.set_color(idmCss), ext_idm_lbl.set_textcolor(idmCss)
        else
            ext_idm.set_color(na)
            ext_idm_lbl.set_textcolor(na)
    else
        ext_choch.set_xy1(topx, topy), ext_choch.set_xy2(n, topy), ext_choch.set_color(bullCss)    
        ext_choch_lbl.set_xy(n, topy), ext_choch_lbl.set_style(label.style_label_down), ext_choch_lbl.set_textcolor(bullCss)
        
        ext_bos.set_xy1(min_x1, min), ext_bos.set_xy2(n, min), ext_bos.set_color(bearCss)    
        ext_bos_lbl.set_xy(n, min), ext_bos_lbl.set_style(label.style_label_up), ext_bos_lbl.set_textcolor(bearCss)

        if not stop_crossed
            ext_idm.set_xy1(stopx, stopy), ext_idm.set_xy2(n+15, stopy)   
            ext_idm_lbl.set_xy(n+15, stopy), ext_idm_lbl.set_style(label.style_label_down)
            ext_idm.set_color(idmCss), ext_idm_lbl.set_textcolor(idmCss)
        else
            ext_idm.set_color(na)
            ext_idm_lbl.set_textcolor(na)

//---------------------------------------------------------------------------------------------------------------------}
//Plots
//---------------------------------------------------------------------------------------------------------------------{
plot(showCircles ? top : na, 'Swing High', color.new(signalBear, 50), 5, plot.style_circles, offset = -len)
plot(showCircles ? btm : na, 'Swing Low', color.new(signalBull, 50), 5, plot.style_circles, offset = -len)

//---------------------------------------------------------------------------------------------------------------------}