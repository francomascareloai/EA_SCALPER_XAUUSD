// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© Zahid Kashmiri Ai Charts@traderschatroom88

// made on 13/01/2025 By zahid Kashmiri 

//@version=6
indicator(title = 'Oscillator Plus', shorttitle = 'test no 5', max_lines_count = 500, max_labels_count = 500, overlay = false, max_bars_back = 5000)


// ############# Oscillator Plus #####################

// Tick Volume
tick = syminfo.mintick
rng = close - open
tickrng = tick
tickrng := math.abs(rng) < tick ? nz(tickrng[1]) : rng
tickvol = math.abs(tickrng) / tick
volumen = nz(volume) != 0 ? volume : tickvol

enhanced_vwma(_series, _length) =>
    vol = volumen
    vmp = _series * vol
    VWMA = math.sum(vmp, _length) / math.sum(vol, _length)
    VWMA

// ALMA  Arnaud Legoux Moving Average
enhanced_alma(_series, _length, _offset, _sigma) =>
    length = int(_length) // Floating point protection
    numerator = 0.0
    denominator = 0.0
    m = _offset * (length - 1)
    s = length / _sigma
    for i = 0 to length - 1 by 1
        weight = math.exp(-((i - m) * (i - m)) / (2 * s * s))
        numerator := numerator + weight * _series[length - 1 - i]
        denominator := denominator + weight
        denominator
    numerator / denominator

//T3 Moving Average 
f_t3(srcww, len) =>
    x1 = ta.ema(srcww, len) //(hlcc, 8)
    x2 = ta.ema(x1, len)
    x3 = ta.ema(x2, len)
    x4 = ta.ema(x3, len)
    x5 = ta.ema(x4, len)
    x6 = ta.ema(x5, len)
    b = 0.7 //Volume Factor
    c1 = -math.pow(b, 3)
    c2 = 3 * math.pow(b, 2) + 3 * math.pow(b, 3)
    c3 = -6 * math.pow(b, 2) - 3 * b - 3 * math.pow(b, 3)
    c4 = 1 + 3 * b + math.pow(b, 3) + 3 * math.pow(b, 2)
    c1 * x6 + c2 * x5 + c3 * x4 + c4 * x3

// Kaufman's Adaptive Moving Average - Fast and Slow Ends
kama(x, t) =>
    fastK = 0.666 // KAMA Fast End
    slowK = 0.0645 // KAMA Slow End
    dist = math.abs(x[0] - x[1])
    signal_x = math.abs(x - x[t])
    noise = math.sum(dist, t)
    effr = noise != 0 ? signal_x / noise : 1
    sc = math.pow(effr * (fastK - slowK) + slowK, 2)
    KAma = x
    KAma := nz(KAma[1]) + sc * (x - nz(KAma[1]))
    KAma

// Jurik Moving Average 
jma(srcww, length, power, phase) =>
    phaseRatio = phase < -100 ? 0.5 : phase > 100 ? 2.5 : phase / 100 + 1.5
    beta = 0.45 * (length - 1) / (0.45 * (length - 1) + 2)
    alpha = math.pow(beta, power)
    Jma = 0.0
    e0 = 0.0
    e0 := (1 - alpha) * srcww + alpha * nz(e0[1])
    e1 = 0.0
    e1 := (srcww - e0) * (1 - beta) + beta * nz(e1[1])
    e2 = 0.0
    e2 := (e0 + phaseRatio * e1 - nz(Jma[1])) * math.pow(1 - alpha, 2) + math.pow(alpha, 2) * nz(e2[1])
    Jma := e2 + nz(Jma[1])
    Jma

// VAMA - Volume Adjusted Moving Average 
vama(_src, _len, _fct, _rul, _nvb) => // vama(source,length,factor,rule,sample)
    tvb = 0 // total volume bars used in sample            
    tvb := _nvb == 0 ? nz(tvb[1]) + 1 : _nvb
    tvs = _nvb == 0 ? ta.cum(volumen) : math.sum(volumen, _nvb) // total volume in sample
    v2i = volumen / (tvs / tvb * _fct) // ratio of volume to increments of volume                                                  
    wtd = _src * v2i // weighted prices 
    nmb = 1 // initialize number of bars summed back               
    wtdSumB = 0.0 // initialize weighted prices summed back
    v2iSumB = 0.0 // initialize ratio of volume to increments of volume summed back
    for i = 1 to _len * 10 by 1 // set artificial cap for strict to VAMA length * 10 to help reduce edge case timeout errors
        strict = _rul ? false : i == _len // strict rule N bars' v2i ratios >= vama length, else <= vama length
        wtdSumB := wtdSumB + nz(wtd[i - 1]) // increment number of bars' weighted prices summed back
        v2iSumB := v2iSumB + nz(v2i[i - 1]) // increment number of bars' v2i's summed back
        if v2iSumB >= _len or strict // if chosen rule met
            break // break (exit loop)
        nmb := nmb + 1 // increment number of bars summed back counter
        nmb
    nmb // number of bars summed back to fulfill volume requirements or vama length
    wtdSumB // number of bars' weighted prices summed back
    v2iSumB // number of bars' v2i's summed back
    vama = (wtdSumB - (v2iSumB - _len) * _src[nmb]) / _len // volume adjusted moving average
    vama

// Smoother

UltimateSmoother(float srcww, int period) =>
    float a1 = math.exp(-1.414 * math.pi / period)
    float c2 = 2.0 * a1 * math.cos(1.414 * math.pi / period)
    float c3 = -a1 * a1
    float c1 = (1.0 + c2 - c3) / 4.0
    float us = srcww
    if bar_index >= 4
        us := (1.0 - c1) * srcww + (2.0 * c1 - c2) * srcww[1] - (c1 + c3) * srcww[2] + c2 * nz(us[1]) + c3 * nz(us[2])
        us
    us

ma(_type, _source, _length) =>
    switch _type
        'SMA' => ta.sma(_source, _length)
        'EMA' => ta.ema(_source, _length)
        'WMA' => ta.wma(_source, _length)
        'D_WMA' => ta.wma(ta.wma(_source, _length), _length) // Double Weighted Moving Average
        'D_EMA' => ta.ema(ta.ema(_source, _length), _length)
        'D_SMA' => ta.sma(ta.sma(_source, _length), _length)
        'VWMA' => enhanced_vwma(_source, _length)
        'D_VWMA' => enhanced_vwma(enhanced_vwma(_source, _length), _length)
        'ALMA' => enhanced_alma(_source, _length, 0.85, 6)
        'Wilder' => 
    	    wild = _source // Wilder's moving average
    	    wild := nz(wild[1]) + (_source - nz(wild[1])) / _length
    	    wild
        'T3' => f_t3(_source, _length)
        'HMA' => ta.hma(_source, _length)
        'VAMA' => vama(_source, _length, 0.67, true, 0)
        'KAMA' => kama(_source, _length)
        'JMA' => jma(_source, _length, 2, 50)
        'Ultimate Smoother' => UltimateSmoother(_source, _length)

type bar
	float o = open
	float h = high
	float l = low
	float c = close

type osc
	float o = na
	float s = na
	float h = na

type alerts
	bool s = false
	bool b = false
	bool u = false
	bool d = false
	bool x = false
	bool y = false

type prompt
	string s = ''
	bool c = false

method notify(prompt p) =>
    if p.c
        alert(p.s, alert.freq_once_per_bar_close)

method any(alerts a) =>
    string s = switch 
        a.s => 'OS Signal'
        a.b => 'OB Signal'
        a.u => 'Bullish Trend'
        a.d => 'Bearish Trend'
        a.x => 'Bullish Swing'
        a.y => 'Bearish Swing'

        => na

    prompt.new(s, not na(s))

method src(bar b, simple string srcww) =>
    float x = switch srcww
        'open' => b.o
        'high' => b.h
        'low' => b.l
        'close' => b.c
        'oc2' => math.avg(b.o, b.c)
        'hl2' => math.avg(b.h, b.l)
        'hlc3' => math.avg(b.h, b.l, b.c)
        'ohlc4' => math.avg(b.o, b.h, b.l, b.c)
        'hlcc4' => math.avg(b.h, b.l, b.c, b.c)
        'vwap(Close)' => ta.vwap(b.c)
        'vwap(Open)' => ta.vwap(b.o)
        'vwap(High)' => ta.vwap(b.h)
        'vwap(Low)' => ta.vwap(b.l)
    x

method stdev(float srcww, simple int len) =>
    float sq = 0.
    float psq = 0.
    float sum = 0.

    for k = 0 to len - 1 by 1
        val = nz(srcww[k])
        psq := sq
        sq := sq + (val - sq) / (1 + k)
        sum := sum + (val - sq) * (val - psq)
        sum

    math.sqrt(sum / (len - 1))

method wave(bar b, simple string srcww, simple int clen, simple int alen, simple int slen, string _type) =>
    float x = b.src(srcww)
    float m = ma(_type, x, clen) //ta.ema(x, clen)
    float d = x.stdev(clen)
    float o = ma(_type, (x - m) / d * 100, alen) //ta.ema((x - m) / d * 100, alen)
    float s = ta.sma(o, slen)

    osc.new(o, s, o - s)

f_getWT(fuente, clen, alen, slen) =>
    esa = ta.ema(fuente, clen)
    dev_st = stdev(fuente, clen)
    com = (fuente - esa) / dev_st * 100
    wt1 = ta.ema(com, alen)
    wt2 = ta.sma(wt1, slen)
    [wt1, wt2]

// Indicators activation section
show_WT = input.bool(true, 'â†ª Show WaveTrend â†© â€ƒ', inline = 'w0')
midL = input.bool(true, 'â–¶ Show Midline', inline = 'w0')
show_black = input.bool(false, 'Use Black Background', inline = 'w0')
revb = input.bool(true, '', inline = 'reve')
revt = input.int(100, 'ã€‹Reversion Threshold [75, 125]', 75, 125, inline = 'reve')
char_dn = input.string('OB', 'Overbought Symbol', inline = 'reve2')
char_up = input.string('OS', 'Oversold Symbol', inline = 'reve2')
colb = input.string('Extremities', 'ã€‹Background Color', ['None', 'Midline Cross', 'Extremities', 'Reversions', 'Slope'], inline = 'reve3')
show_cross = input.bool(false, 'Show the crossings', inline = 'reve3')
compare = input.bool(false, 'Compare with Symbol', inline = 'CPR')
symbol = input.symbol('CME_MINI:ES1!', '', inline = 'CPR')
extSrc = request.security(symbol, timeframe.period, hlc3, barmerge.gaps_off, barmerge.lookahead_on)

show_mom = input.bool(false, 'â†ª Show Momentum â†©â€ƒ', inline = 'mom0')
mom_mode = input.string('Histogram', 'Plot', options = ['Columns', 'Area', 'Histogram'], inline = 'mom0')
mode = mom_mode == 'Columns' ? plot.style_columns : mom_mode == 'Area' ? plot.style_area : plot.style_histogram
show_mom_sig = input.bool(false, 'Use Signal Line', inline = 'stren')
show_strength = input.bool(false, 'Show Strength(MOM)', inline = 'stren')
show_arrows = input.bool(false, 'Show â–² â–¼ ', inline = 'stren')
char_sqz = input.string('ðŸŸ¢', 'Squeeze symbol', inline = 'sqz0')
tooltip_sqz = 'The Squeeze Indicator measures the relationship between Bollinger Bands and Keltner\'s Channels to help identify consolidations and signal when prices are likely to break out (whether up or down). ' + 'The Squeeze Indicator finds sections of the Bollinger Bands which fall inside the Keltner\'s Channels and in this case the market is said to be in a squeeze (indicator turns off, displayed with grey dot shapes in this study). ' + 'When the volatility increases, so does the distance between the bands, conversely, when the volatility declines, the distance also decreases and in such cases the squeeze is said to be released (indicator turns on, displayed with triangle up or triangle down shapes)'
show_sqz = input.bool(false, 'â–¶ Show Squeeze Indicator â€ƒ', tooltip = tooltip_sqz, inline = 'sqz0')

show_EWO = input.bool(false, 'â†ª Show EWO â†© â€ƒ', inline = '0_ewo')
show_bands = input.bool(true, 'Use Breaking Bands', inline = '0_ewo')
show_signal = input.bool(false, 'Use Signal Line', inline = '0_ewo')
candles_XTL = input.bool(true, ' Expert Trend Locator Bars Color')

// Inputs : WaveTrend Oscillator {
const string gw = 'âŽ†âŽ† WaveTrend Oscillator'
type_wt = input.string('EMA', 'Type', inline = 'w1', group = gw, options = ['Ultimate Smoother', 'ALMA', 'T3', 'WMA', 'EMA', 'SMA', 'Wilder', 'D_WMA', 'D_SMA', 'D_EMA', 'VWMA', 'D_VWMA', 'HMA', 'JMA', 'VAMA', 'KAMA'])
srcww = input.string('hlc3', 'Source', inline = 'w1', group = gw, options = ['open', 'high', 'low', 'close', 'oc2', 'hl2', 'hlc3', 'ohlc4', 'hlcc4', 'vwap(Close)', 'vwap(Open)', 'vwap(High)', 'vwap(Low)'])
clen = input.int(10, 'Channel Length', 3, 55, 1, inline = 'w2', group = gw)
alen = input.int(21, 'Average Length', 3, 55, 1, inline = 'w2', group = gw)
slen = input.int(4, 'Signal  Length', 2, 20, 1, inline = 'w3', group = gw)
// }

// Inputs : Squeeze Momentum Indicator {
const string gm = 'âŽ†âŽ† Squeeze Momentum Indicator'
momLength = input.int(20, 'Length', minval = 1, inline = 'mom2', group = gm)
src_mom = input.string('close', 'Source', ['open', 'high', 'low', 'close', 'oc2', 'hl2', 'hlc3', 'ohlc4', 'hlcc4', 'vwap(Close)', 'vwap(Open)', 'vwap(High)', 'vwap(Low)'], inline = 'mom2', group = gm)
signalLength = input.int(5, 'Signal Length', minval = 2, inline = 's0', group = gm)
type_signal = input.string('SMA', 'Type', inline = 's0', group = gm, options = ['Ultimate Smoother', 'T3', 'WMA', 'EMA', 'SMA', 'Wilder', 'D_WMA', 'ALMA', 'VWMA', 'HMA'])
sqzLength = input.int(20, 'Squeeze (KC|BB) Length', minval = 1, group = gm)
bbMult = input.float(2.0, 'Bollinger Bands MultFactor', step = 0.05, minval = 0.25, group = gm)
kcMult = input.float(1.25, 'Keltner\'s Channel MultFactor', step = 0.05, minval = 0.25, group = gm)
useTrueRange = input.bool(true, 'Use TrueRange (Keltner\'s Channel)', group = gm)
// }

// Inputs : Elliott Wave Oscillator (EWO) Breaking Bands {
const string g_ewo = 'âŽ†âŽ† Elliott Wave Oscillator'
SRC_x = input.string('hl2', 'â€ƒã€‹Source', inline = 'ewo0', group = g_ewo, options = ['open', 'high', 'low', 'close', 'oc2', 'hl2', 'hlc3', 'ohlc4', 'hlcc4', 'vwap(Close)', 'vwap(Open)', 'vwap(High)', 'vwap(Low)'])
bg_EWO = input.bool(false, 'Background', inline = 'ewo0', group = g_ewo)
color_bar_ewo = input.bool(false, 'Bar color', inline = 'ewo0', group = g_ewo)
ma_fast = input.int(5, 'Fast MA', inline = 'F', group = g_ewo)
type_fast = input.string('SMA', 'Fast MA Type', inline = 'F', group = g_ewo, options = ['Ultimate Smoother', 'T3', 'SMA', 'EMA', 'WMA', 'D_WMA', 'VWMA', 'ALMA', 'Wilder', 'D_SMA', 'D_EMA', 'HMA', 'JMA', 'VAMA', 'KAMA'])
ma_slow = input.int(34, 'Slow MA', inline = 'S', group = g_ewo)
type_slow = input.string('SMA', 'Slow MA Type', inline = 'S', group = g_ewo, options = ['Ultimate Smoother', 'T3', 'SMA', 'EMA', 'WMA', 'D_WMA', 'VWMA', 'ALMA', 'Wilder', 'D_SMA', 'D_EMA', 'HMA', 'JMA', 'VAMA', 'KAMA'])
Len_signal = input.int(7, 'Signal Length', minval = 1, inline = 'signal', group = g_ewo)
ewo_signal = input.string('EMA', 'Type', inline = 'signal', group = g_ewo, options = ['Ultimate Smoother', 'T3', 'SMA', 'EMA', 'WMA', 'D_WMA', 'VWMA', 'ALMA', 'Wilder', 'D_SMA', 'D_EMA', 'HMA', 'JMA', 'VAMA', 'KAMA'])
show_L_S = input.bool(false, 'Show â–²Long/Shortâ–¼', inline = 'ls', group = g_ewo)
threshold = input.int(13, 'â€ƒStrength Threshold', minval = 1, inline = 'ls', group = g_ewo)
const color col_grow_above = #00FF6B
const color col_fall_above = #00682C
const color col_grow_below = #FE5200
const color col_fall_below = #822A00
// }

// Inputs : The Expert Trend Locator - XTL {
const string g_xtl = 'âŽ†âŽ† Expert Trend Locator [XTL]'
period_xtl = input.int(26, 'Length', minval = 2, inline = 'xtl', group = g_xtl)
MA_Type2 = input.string('D_VWMA', 'Type', inline = 'xtl', group = g_xtl, options = ['Ultimate Smoother', 'T3', 'SMA', 'EMA', 'WMA', 'D_WMA', 'VWMA', 'ALMA', 'Wilder', 'D_SMA', 'D_EMA', 'D_VWMA', 'HMA'])
src_xtl = input.string('hlc3', 'Source', inline = 'xtl', group = g_xtl, options = ['open', 'high', 'low', 'close', 'oc2', 'hl2', 'hlc3', 'ohlc4', 'hlcc4', 'vwap(Close)', 'vwap(Open)', 'vwap(High)', 'vwap(Low)'])
fixed_Value = input.int(37, 'Threshold Level', minval = 10, group = g_xtl, inline = 'xtl2')
uTrad = input.bool(false, 'Use the traditional CCI formula', group = g_xtl, inline = 'xtl2')
detect_bull = input.bool(false, 'â— Alert: Bullish Trend', inline = 'alert_xtl', group = g_xtl)
detect_bear = input.bool(false, 'â— Alert: Bearish Trend', inline = 'alert_xtl', group = g_xtl)
// }

// Inputs : Divergence {
right = input.int(10, 'Divergence Look Right', minval = 0, group = 'Divergence')
left = input.int(15, 'Divergence Look Left', minval = 0, group = 'Divergence')
upper_range = input.int(100, 'Maximum Lookback', minval = 0, group = 'Divergence')
lower_range = input.int(5, 'Minimum Lookback', minval = 0, group = 'Divergence')
labels = input.string('Disabled', 'Show Labels', ['Disabled', 'Symbol', 'Text'], group = 'Divergence')
enable_regular_bullish = input.bool(true, 'Regular Bullish', group = 'Divergence', inline = 'bld')
enable_hidden_bullish = input.bool(false, 'Hidden Bullish', group = 'Divergence', inline = 'bld')
enable_regular_bearish = input.bool(true, 'Regular Bearish', group = 'Divergence', inline = 'brd')
enable_hidden_bearish = input.bool(false, 'Hidden Bearish', group = 'Divergence', inline = 'brd')
regular_bullish_color = input.color(#00ff00, 'Bullish Colors', group = 'Divergence', inline = 'blc')
hidden_bullish_color = input.color(#46c47a, '', group = 'Divergence', inline = 'blc')
regular_bearish_color = input.color(#FF055D, 'Bearish Colors', group = 'Divergence', inline = 'brc')
hidden_bearish_color = input.color(#f82e2e, '', group = 'Divergence', inline = 'brc')
//}

// Enhanced WaveTrend Oscillator

bar b = bar.new()
osc wt = b.wave(srcww, clen, alen, slen, type_wt)
[wt1x, wt2x] = f_getWT(extSrc, clen, alen, slen)

const color colup = #04d50d
const color coldn = #FF055D
const color colhu = #00ff00
const color colhd = #ff000d
const color colnt = #EFEFBF

color color_wt = wt.o > wt.s ? colup : coldn
color color_wtx = wt1x > wt2x ? #00FF6B : #FE5200
color color_wtx2 = wt1x > wt2x ? #00682C : #822A00
color colof = wt.o > wt.s ? color.new(colup, 50) : color.new(coldn, 50)
field_0 = wt.h
field_1 = wt.h
color colh = wt.h > 0 ? wt.h > field_0[1] ? color.new(colhu, 40) : color.new(colhu, 60) : wt.h < field_1[1] ? color.new(colhd, 40) : color.new(colhd, 60)

hline(midL ? 0 : na, 'Mid Line', color.new(colnt, 50), hline.style_dotted)
max = hline(show_WT ? +150 : na, display = display.none)
hh = hline(show_WT ? +125 : na, display = display.none)
lh = hline(show_WT ? +100 : na, display = display.none)
min = hline(show_WT ? -150 : na, display = display.none)
ll = hline(show_WT ? -125 : na, display = display.none)
hl = hline(show_WT ? -100 : na, display = display.none)
h = plot(show_WT ? wt.h * 2 : na, 'WT Histogram', colh, 1, plot.style_columns)
w = plot(show_WT ? wt.o : na, 'WaveTrend', color_wt, 1, plot.style_line)
s = plot(show_WT ? wt.s : na, display = display.none)
char_cross = 'â—'
plotchar(show_cross and ta.cross(wt.o, wt.s) ? wt.s : na, 'Crossing in the WT', char_cross, location.absolute, color_wt, size = size.tiny)

plot(compare ? wt1x : na, 'WaveTrend 2', color_wtx, 1, plot.style_line)
plot(compare ? wt2x : na, 'Signal(WaveTrend 2)', color_wtx2, 1, plot.style_circles)

//@type               A custom type containing information about a ticker.
//@field description  The symbol's description.
//@field tickerType   The type of ticker.
type TickerInfo
	string description
	string tickerType
	//@variable A `TickerInfo` object containing current data.
info = TickerInfo.new(syminfo.description, syminfo.type)
//@variable The `info` requested from the specified `symbol`.
TickerInfo requestedInfo = request.security(symbol, timeframe.period, info)
//@variable The text to display inside the `infoLabel`.
string infoText = na(requestedInfo) ? '' : str.format('{0}\nType: {1}', requestedInfo.description, requestedInfo.tickerType)

if barstate.islast
    label_text = compare ? infoText : na
    label.new(x = time, y = wt1x, text = label_text, xloc = xloc.bar_time, yloc = yloc.price, color = color.rgb(0, 0, 0, 100), style = label.style_label_left, textcolor = color_wtx, size = size.small)

fill(lh, hh, color.new(colhd, 86))
fill(hh, max, color.new(colhd, 79))
fill(ll, hl, color.new(colhu, 87))
fill(ll, min, color.new(colhu, 80))
fill(w, s, colof)

alerts a = alerts.new(ta.crossover(wt.o, wt.s) and wt.o < -revt, ta.crossunder(wt.o, wt.s) and wt.o > revt, ta.crossover(wt.o, 0), ta.crossunder(wt.o, 0), ta.crossover(wt.o, wt.s), ta.crossunder(wt.o, wt.s))

// alertcondition(a.b, 'Overbought', 'WaveTrend : OB Signal')
// alertcondition(a.s, 'Oversold  ', 'WaveTrend : OS Signal')
// alertcondition(a.u, 'Midline Crossover ', 'WaveTrend : Bullish Trend')
// alertcondition(a.d, 'Midline Crossunder', 'WaveTrend : Bearish Trend')
// alertcondition(a.x, 'Oscillator Up', 'WaveTrend : Bullish Swing')
// alertcondition(a.y, 'Oscillator Down', 'WaveTrend : Bearish Swing')

a.any().notify()

bgcolor(show_black ? color.new(#000000, 25) : na, title = 'Black background')
color col = switch colb
    'Midline Cross' => wt.o > 0 ? color.new(colup, 90) : color.new(coldn, 90)
    'Extremities' => wt.o > revt ? color.new(colup, 80) : wt.o < -revt ? color.new(coldn, 80) : na
    'Reversions' => a.b ? color.new(coldn, 70) : a.s ? color.new(colup, 70) : na
    'Slope' => wt.o > wt.s ? color.new(colup, 90) : color.new(coldn, 90)
    'None' => na
bgcolor(col)
// }

// Elliott Wave Oscillator (EWO) Breaking Bands 

src_ewo = b.src(SRC_x)
ewo1 = ma(type_fast, src_ewo, ma_fast) - ma(type_slow, src_ewo, ma_slow)
AvgEWO = ma(ewo_signal, ewo1, Len_signal)

UpperBand = ewo1
UpperBand := nz(UpperBand[1])
if ewo1 > 0
    UpperBand := UpperBand[1] + 0.0555 * (ewo1 - UpperBand[1])
    UpperBand

LowerBand = ewo1
LowerBand := nz(LowerBand[1])
if ewo1 < 0
    LowerBand := LowerBand[1] + 0.0555 * (ewo1 - LowerBand[1])
    LowerBand

color_in = ewo1 > LowerBand and ewo1 < 0 ? col_fall_below : ewo1 > 0 and ewo1 < UpperBand ? col_fall_above : na
background = ewo1 > 0 ? color.new(#00FF6B, 90) : color.new(#FE5200, 90)

color_ewo = ewo1 > UpperBand ? col_grow_above : ewo1 < LowerBand ? col_grow_below : color_in
color_ewo2 = ewo1 >= 0 ? ewo1[1] < ewo1 ? col_grow_above : col_fall_above : ewo1[1] > ewo1 ? col_grow_below : col_fall_below
plot(show_EWO ? ewo1 : na, title = 'EWO', color = show_bands ? color_ewo : color_ewo2, style = plot.style_columns)

color_sig = AvgEWO > AvgEWO[1] ? #5200FE : #FE0052
plot(show_EWO and show_signal ? AvgEWO : na, title = 'Signal(EWO)', color = color_sig, linewidth = 2)

plot(show_EWO and show_bands ? UpperBand : na, title = 'Upper', color = color.new(#EFEFBF, 10))
plot(show_EWO and show_bands ? LowerBand : na, title = 'Lower', color = color.new(#EFEFBF, 10))
//hline(show_EWO ? 0 : na, title="Zero Line", linestyle=hline.style_dotted, color=white)
bgcolor(bg_EWO ? background : na, title = 'EWO Background')
barcolor(color_bar_ewo ? color_ewo : na, title = 'EWO barcolor')

// Elliott Wave Oscillator Signals 

ewo2 = (ma(type_fast, src_ewo, ma_fast) / ma(type_slow, src_ewo, ma_slow) - 1) * 100
ewoSignal = ma(ewo_signal, ewo2, Len_signal)
longAlertCondition = ta.crossover(ewo2, ewoSignal)
shortAlertCondition = ta.crossunder(ewo2, ewoSignal)

plotshape(show_L_S and longAlertCondition and ewo2 < -threshold, 'Strong Long', shape.triangleup, location.bottom, col_grow_above, size = size.tiny, show_last = 252)
plotshape(show_L_S and longAlertCondition and ewo2 > -threshold, 'Long', shape.triangleup, location.bottom, col_fall_above, size = size.tiny, show_last = 252)
plotshape(show_L_S and shortAlertCondition and ewo2 > threshold, 'Strong Short', shape.triangledown, location.top, col_grow_below, size = size.tiny, show_last = 252)
plotshape(show_L_S and shortAlertCondition and ewo2 < threshold, 'Short', shape.triangledown, location.top, col_fall_below, size = size.tiny, show_last = 252)

alertcondition(longAlertCondition, 'Long : Early Warning', 'EWO - Not Confirmed Probable Long Trade Opportunity\n{{exchange}}:{{ticker}}->\nPrice = {{close}},\nTime = {{time}}')
alertcondition(longAlertCondition[1], 'Long : Trading Opportunity', 'EWO - Probable Long Trade Opportunity\n{{exchange}}:{{ticker}}->\nPrice = {{close}},\nTime = {{time}}')

alertcondition(shortAlertCondition, 'Short : Early Warning', 'EWO - Not Confirmed Probable Short Trade Opportunity\n{{exchange}}:{{ticker}}->\nPrice = {{close}},\nTime = {{time}}')
alertcondition(shortAlertCondition[1], 'Short : Trading Opportunity', 'EWO - Probable Short Trade Opportunity\n{{exchange}}:{{ticker}}->\nPrice = {{close}},\nTime = {{time}}')
//}

// The Expert Trend Locator 

media = ma(MA_Type2, b.src(src_xtl), period_xtl)
cciNT = (b.src(src_xtl) - media) / (0.015 * ta.dev(b.src(src_xtl), period_xtl))
cciT = (b.src(src_xtl) - media) / (0.015 * ta.dev(math.abs(b.src(src_xtl) - media), period_xtl))
values = uTrad ? cciT : cciNT

var color color_XTL = na
if values < -fixed_Value
    color_XTL := #ff000d //#FF4000 // Bear
    color_XTL
if -fixed_Value <= values and values <= fixed_Value
    color_XTL := #EFEFBF // Neutral
    color_XTL
if values > fixed_Value
    color_XTL := #00ff00 //#00BFFF // Bull
    color_XTL

cond_bull_xtl = detect_bull and ta.crossover(values, fixed_Value)
cond_bear_xtl = detect_bear and ta.crossunder(values, -fixed_Value)

if cond_bull_xtl
    alert('Symbol = (' + syminfo.tickerid + ') \n TimeFrame = (' + timeframe.period + ') \n Current Price (' + str.tostring(close) + ') \n Bullish Trend [XTL].', alert.freq_once_per_bar_close)
if cond_bear_xtl
    alert('Symbol = (' + syminfo.tickerid + ') \n TimeFrame = (' + timeframe.period + ') \n Current Price (' + str.tostring(close) + ') \n Bearish Trend [XTL].', alert.freq_once_per_bar_close)

barcolor(candles_XTL ? color_XTL : na, title = 'XLT barcolor')
// }

// Squeeze Momentum Indicator A

// Calculations
float source = b.src(src_mom)
[_, bbUpper, bbLower] = ta.bb(source, sqzLength, bbMult)
[_, kcUpper, kcLower] = ta.kc(source, sqzLength, kcMult, useTrueRange)

sqzOn = bbLower > kcLower and bbUpper < kcUpper
sqzOff = bbLower < kcLower and bbUpper > kcUpper
noSqz = sqzOn == false and sqzOff == false

momOsc = ta.linreg(source - math.avg(math.avg(ta.highest(high, momLength), ta.lowest(low, momLength)), ta.sma(source, momLength)), momLength, 0)
signal = ma(type_signal, momOsc, signalLength)
momentum_strength = momOsc - signal

// Plotting 
color color_mom = momOsc >= 0 ? momOsc >= momOsc[1] ? color.new(#15FF00, 0) : color.new(#335E33, 0) : momOsc < momOsc[1] ? color.new(#F44336, 0) : color.new(#B71C1C, 0)
color color_up = color.new(color.green, 0)
color color_dn = color.new(color.red, 0) 

plot(show_mom ? momOsc : na, 'Momentum', color_mom, 2, mode)
plot(show_mom_sig ? signal : na, 'Signal(Mom)', signal > signal[1] ? #00FFBB : #FF1100)

mom_up = sqzOff and momentum_strength >= 0 or not show_sqz and momentum_strength >= 0
mom_dn = sqzOff and momentum_strength < 0 or not show_sqz and momentum_strength < 0
plotshape(show_arrows and mom_up, 'Squeeze Release', shape.triangleup, location.top, color_up)
plotshape(show_arrows and mom_dn, 'Squeeze Release', shape.triangledown, location.top, color_dn)
plotchar(show_sqz and (sqzOn or noSqz) ? true : false, 'In Squeeze', char_sqz, location.top, #EFEFBF)

color_strength = momentum_strength > 0 ? color_up : color_dn
color_strength_cloud = momentum_strength > 0 ? color.new(color_up, 85) : color.new(color_dn, 85)
plot(show_strength ? momentum_strength * 2 : na, 'Momentum Strength', color_strength_cloud, 1, plot.style_columns, display = display.pane)
plot(show_strength ? momentum_strength * 2 : na, 'Momentum Strength', color_strength, 1, plot.style_line, join = true)
// }

// Divergence {
in_range(cond, lower_range, upper_range) =>
    bars = ta.barssince(cond == true)
    lower_range <= bars and bars <= upper_range

color text_color = #111122
float source_div = show_WT ? wt.o : show_mom ? momOsc : show_EWO ? ewo1 : na

divergence(float source, int right, int left, int upper_range, int lower_range, bool enable_regular_bullish, color regular_bullish_color, bool enable_hidden_bullish, color hidden_bullish_color, bool enable_regular_bearish, color regular_bearish_color, bool enable_hidden_bearish, color hidden_bearish_color, string labels, color text_color) =>
    repaint = barstate.ishistory or barstate.isconfirmed

    pl = na(ta.pivotlow(source, left, right)) ? false : true
    ph = na(ta.pivothigh(source, left, right)) ? false : true

    source_hl = source[right] > ta.valuewhen(pl, source[right], 1) and in_range(pl[1], lower_range, upper_range)
    price_ll = low[right] < ta.valuewhen(pl, low[right], 1)
    bullish_condition = enable_regular_bullish and price_ll and source_hl and pl and repaint

    oscLL = source[right] < ta.valuewhen(pl, source[right], 1) and in_range(pl[1], lower_range, upper_range)
    priceHL = low[right] > ta.valuewhen(pl, low[right], 1)
    hidden_bullish_condition = enable_hidden_bullish and priceHL and oscLL and pl and repaint

    oscLH = source[right] < ta.valuewhen(ph, source[right], 1) and in_range(ph[1], lower_range, upper_range)
    priceHH = high[right] > ta.valuewhen(ph, high[right], 1)
    bearish_condition = enable_regular_bearish and priceHH and oscLH and ph and repaint

    oscHH = source[right] > ta.valuewhen(ph, source[right], 1) and in_range(ph[1], lower_range, upper_range)
    priceLH = high[right] < ta.valuewhen(ph, high[right], 1)
    hidden_bearish_condition = enable_hidden_bearish and priceLH and oscHH and ph and repaint

    offset = -right

    var float current_bullish_value = 0
    var int current_bull_idx = 0
    var float last_bullish_value = 0
    var int last_bullish_idx = 0
    var float current_hidden_bullish_value = 0
    var int current_hidden_bullish_idx = 0
    var float last_hidden_bullish_value = 0
    var int last_hidden_bullish_idx = 0
    var float current_bearish_value = 0
    var int current_bearish_idx = 0
    var float last_bearish_value = 0
    var int last_bearish_idx = 0
    var float current_hidden_bearish_value = 0
    var int current_hidden_bearish_idx = 0
    var float last_hidden_bearish_idx = 0
    var int last_hidden_bearish_value = 0

    if pl
        last_bullish_value := current_bullish_value
        last_bullish_idx := current_bull_idx
        current_bullish_value := source[right]
        current_bull_idx := bar_index - right
        last_hidden_bullish_value := current_hidden_bullish_value
        last_hidden_bullish_idx := current_hidden_bullish_idx
        current_hidden_bullish_value := source[right]
        current_hidden_bullish_idx := bar_index - right
        current_hidden_bullish_idx

    if ph
        last_bearish_value := current_bearish_value
        last_bearish_idx := current_bearish_idx
        current_bearish_value := source[right]
        current_bearish_idx := bar_index - right
        last_hidden_bearish_idx := current_hidden_bearish_value
        last_hidden_bearish_value := current_hidden_bearish_idx
        current_hidden_bearish_value := source[right]
        current_hidden_bearish_idx := bar_index - right
        current_hidden_bearish_idx

    label_style_bullish = switch labels
        'Text' => label.style_label_up
        'Symbol' => label.style_triangleup
        => label.style_none

    label_style_bearish = switch labels
        'Text' => label.style_label_down
        'Symbol' => label.style_triangledown
        => label.style_none

    size = switch labels
        'Text' => size.small
        'Symbol' => size.tiny
        => size.auto

    source_atr = ta.sma(ta.rma(ta.highest(source, 10) - ta.lowest(source, 10), 50) / (labels == 'Text' ? 4 : 1), 10)

    if bullish_condition
        line.new(last_bullish_idx, last_bullish_value, current_bull_idx, current_bullish_value, width = 2, color = regular_bullish_color)
        if labels != 'Disabled'
            label.new(bar_index - right, source[right] - source_atr, labels == 'Text' ? 'R' : '', color = regular_bullish_color, textcolor = text_color, style = label_style_bullish, size = size)
    if hidden_bullish_condition
        line.new(last_hidden_bullish_idx, last_hidden_bullish_value, current_hidden_bullish_idx, current_hidden_bullish_value, width = 2, color = hidden_bullish_color)
        if labels != 'Disabled'
            label.new(bar_index - right, source[right] - source_atr, labels == 'Text' ? 'H' : '', color = hidden_bullish_color, textcolor = text_color, style = label_style_bullish, size = size)
    if bearish_condition
        line.new(last_bearish_idx, last_bearish_value, current_bearish_idx, current_bearish_value, width = 2, color = regular_bearish_color)
        if labels != 'Disabled'
            label.new(bar_index - right, source[right] + source_atr, labels == 'Text' ? 'R' : '', color = regular_bearish_color, textcolor = text_color, style = label_style_bearish, size = size)
    if hidden_bearish_condition
        line.new(last_hidden_bearish_value, last_hidden_bearish_idx, current_hidden_bearish_idx, current_hidden_bearish_value, width = 2, color = hidden_bearish_color)
        if labels != 'Disabled'
            label.new(bar_index - right, source[right] + source_atr, labels == 'Text' ? 'H' : '', color = hidden_bearish_color, textcolor = text_color, style = label_style_bearish, size = size)
    [bullish_condition, hidden_bullish_condition, bearish_condition, hidden_bearish_condition]

min_max(source, min, max, enable, clamp) =>
    if enable != 'Disabled'
        if clamp
            (math.max(math.min(1, (source - min) / (max - min)), 0) - 0.5) * 200
        else
            ((source - min) / (max - min) - 0.5) * 200
    else
        source

[regular_bullish, hidden_bullish, regular_bearish, hidden_bearish] = divergence(source_div, right, left, upper_range, lower_range, enable_regular_bullish, regular_bullish_color, enable_hidden_bullish, hidden_bullish_color, enable_regular_bearish, regular_bearish_color, enable_hidden_bearish, hidden_bearish_color, labels, text_color)

alertcondition(regular_bullish, 'Regular Bullish Divergence', 'Regular bullish divergence detected!')
alertcondition(hidden_bullish, 'Hidden Bullish Divergence', 'Hidden bullish divergence detected!')
alertcondition(regular_bearish, 'Regular Bearish Divergence', 'Regular bearish divergence detected!')
alertcondition(hidden_bearish, 'Hidden Bearish Divergence', 'Hidden bearish divergence detected!')
//}

//Signal - Enhanced WaveTrend Oscillator {
plotchar(revb and a.b ? true : false, 'Overbought Signal', char_dn, location.top, coldn, size = size.tiny)
plotchar(revb and a.s ? true : false, 'Oversold Signal', char_up, location.bottom, colup, size = size.tiny)
// }

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Inputs

//-----------------------------------------------------------------------------
//              Input | Settings
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------{
const string FREQ = alert.freq_once_per_bar_close
const color NO_COLOR = color.new(#000000, 100)

const string HIST_INPUT = 'ðŸ“ŠEnhanced Histogram'
showHist = input.bool(false, 'Enhanced Histogram', group = HIST_INPUT, inline = 'hist', display = display.none)
histColorUp = input.color(#00ff00, '', group = HIST_INPUT, inline = 'hist', display = display.none)
histColorDn = input.color(#ff000d, '', group = HIST_INPUT, inline = 'hist', display = display.none)
inputMfiLen = input.int(30, 'Length', minval = 5, group = HIST_INPUT, display = display.none)
smoothHist = input.int(2, 'Smooth', minval = 1, group = HIST_INPUT, display = display.none)
fastMfiLen = math.round(inputMfiLen / 1.33)
slowMfiLen = math.round(inputMfiLen * 1.33)


//------------------------------------------------------------------------------}


//------------------------------------------------------------------------------}

//-----------------------------------------------------------------------------
//              hist
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------{
const int MFI_LEN = 7
const int STOCH_K = 2
const int STOCH_D = 5
const float SMOOTH_LEN = 1.75
const float STOCH_WEIGHT = 0.4
const float OVERBOUGHT = 60.0
const float EXTEND_MULT = 1
var float mfiWeight = 0.4

rsiSrc = hlc3

transform(srcww, mult = 1) =>
    tmp = (srcww / 100 - 0.5) * 2
    mult * 100 * (tmp > 0 ? 1 : -1) * math.pow(math.abs(tmp), 0.75)

//Histogram
fastMfi = ta.mfi(rsiSrc, fastMfiLen)
slowMfi = ta.mfi(rsiSrc, slowMfiLen)
resMfi = transform(ta.sma(fastMfi * 0.5 + slowMfi * 0.5, smoothHist), 0.7)

midLine = plot(0, color = histColorUp, editable = false, display = display.pane)
histColor = showHist ? resMfi >= 0 ? histColorUp : histColorDn : NO_COLOR
longterm = plot(resMfi, color = histColor, editable = false, display = display.pane) //20*macd/ta.highest(absMACD,20) + 50 
fill(longterm, midLine, resMfi, 0, histColor, NO_COLOR, editable = false)


//--------------------------------------------END---------------------